import * as _leafer_interface from '@leafer/interface';
import { INumberMap, IPoint, IPointData, IMatrixData, IBounds, IBoundsData, IMatrix, IAlign, IFourNumber, ISide, IObject, IBoundsDataFn, IRadiusPointData, IMatrixWithLayoutData, IAutoBounds, IAutoBoundsData, ISizeData, IMatrixWithScaleData, ILayoutData, IUnitPointData, IAround, IScrollPointData, IOffsetBoundsData, ITwoPointBoundsData, IRangeSize, IOptionSizeData, IScaleData, IMatrixWithOptionScaleData, IUnitData } from '@leafer/interface';

declare const IncrementId: {
    RUNTIME: string;
    LEAF: string;
    TASK: string;
    CNAVAS: string;
    IMAGE: string;
    types: INumberMap;
    create(typeName: string): number;
};

declare class Point implements IPoint {
    x: number;
    y: number;
    constructor(x?: number | IPointData, y?: number);
    set(x?: number | IPointData, y?: number): IPoint;
    get(): IPointData;
    clone(): IPoint;
    move(x: number | IPointData, y?: number): IPoint;
    scale(scaleX: number, scaleY?: number): IPoint;
    scaleOf(origin: IPointData, scaleX: number, scaleY?: number): IPoint;
    rotate(rotation: number, origin?: IPointData): IPoint;
    rotateOf(origin: IPointData, rotation: number): IPoint;
    getRotation(origin: IPointData, to: IPointData, toOrigin?: IPointData): number;
    toInnerOf(matrix: IMatrixData, to?: IPointData): IPoint;
    toOuterOf(matrix: IMatrixData, to?: IPointData): IPoint;
    getCenter(to: IPointData): IPoint;
    getDistance(to: IPointData): number;
    getDistancePoint(to: IPointData, distance: number, changeTo?: boolean, fromTo?: boolean): IPoint;
    getAngle(to: IPointData): number;
    getAtan2(to: IPointData): number;
    isSame(point: IPointData): boolean;
    reset(): IPoint;
}
declare const tempPoint: Point;

declare class Bounds implements IBounds {
    x: number;
    y: number;
    width: number;
    height: number;
    get minX(): number;
    get minY(): number;
    get maxX(): number;
    get maxY(): number;
    constructor(x?: number | IBoundsData, y?: number, width?: number, height?: number);
    set(x?: number | IBoundsData, y?: number, width?: number, height?: number): IBounds;
    get(): IBoundsData;
    clone(): IBounds;
    move(x: number, y: number): IBounds;
    scale(scaleX: number, scaleY?: number, onlySize?: boolean): IBounds;
    scaleOf(origin: IPointData, scaleX: number, scaleY?: number): IBounds;
    toOuterOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    toInnerOf(matrix: IMatrixData, to?: IBoundsData): IBounds;
    getFitMatrix(put: IBoundsData, baseScale?: number): IMatrix;
    put(put: IBoundsData, align?: IAlign, putScale?: number | 'fit' | 'cover'): void;
    spread(fourNumber: IFourNumber, side?: ISide): IBounds;
    shrink(fourNumber: IFourNumber, side?: ISide): IBounds;
    ceil(): IBounds;
    unsign(): IBounds;
    float(maxLength?: number): IBounds;
    add(bounds: IBoundsData): IBounds;
    addList(boundsList: IBoundsData[]): IBounds;
    setList(boundsList: IBoundsData[]): IBounds;
    addListWithFn(list: IObject[], boundsDataFn: IBoundsDataFn): IBounds;
    setListWithFn(list: IObject[], boundsDataFn: IBoundsDataFn): IBounds;
    setPoint(point: IPointData): IBounds;
    setPoints(points: IPointData[]): IBounds;
    addPoint(point: IPointData): IBounds;
    getPoints(): IPointData[];
    hitPoint(point: IPointData, pointMatrix?: IMatrixData): boolean;
    hitRadiusPoint(point: IRadiusPointData, pointMatrix?: IMatrixWithLayoutData): boolean;
    hit(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    includes(bounds: IBoundsData, boundsMatrix?: IMatrixData): boolean;
    intersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    getIntersect(bounds: IBoundsData, boundsMatrix?: IMatrixData): IBounds;
    isSame(bounds: IBoundsData): boolean;
    isEmpty(): boolean;
    reset(): void;
}
declare const tempBounds: Bounds;

declare class AutoBounds implements IAutoBounds {
    top: number;
    right: number;
    bottom: number;
    left: number;
    width: number;
    height: number;
    constructor(top?: number | IAutoBoundsData, right?: number, bottom?: number, left?: number, width?: number, height?: number);
    set(top?: number, right?: number, bottom?: number, left?: number, width?: number, height?: number): void;
    copy(autoSize: IAutoBoundsData): void;
    getBoundsFrom(parent: ISizeData): IBounds;
}

declare class Matrix implements IMatrix {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    scaleX: number;
    scaleY: number;
    constructor(a?: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number);
    set(a?: number | IMatrixData, b?: number, c?: number, d?: number, e?: number, f?: number): IMatrix;
    setWith(dataWithScale: IMatrixWithScaleData): IMatrix;
    get(): IMatrixData;
    clone(): IMatrix;
    translate(x: number, y: number): IMatrix;
    translateInner(x: number, y: number): IMatrix;
    scale(x: number, y?: number): IMatrix;
    scaleWith(x: number, y?: number): IMatrix;
    pixelScale(pixelRatio: number): IMatrix;
    scaleOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    scaleOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    rotate(angle: number): IMatrix;
    rotateOfOuter(origin: IPointData, angle: number): IMatrix;
    rotateOfInner(origin: IPointData, angle: number): IMatrix;
    skew(x: number, y?: number): IMatrix;
    skewOfOuter(origin: IPointData, x: number, y?: number): IMatrix;
    skewOfInner(origin: IPointData, x: number, y?: number): IMatrix;
    multiply(child: IMatrixData): IMatrix;
    multiplyParent(parent: IMatrixData): IMatrix;
    divide(child: IMatrixData): IMatrix;
    divideParent(parent: IMatrixData): IMatrix;
    invert(): IMatrix;
    invertWith(): IMatrix;
    toOuterPoint(inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(outer: IPointData, to?: IPointData, distance?: boolean): void;
    setLayout(data: ILayoutData, origin?: IPointData, around?: IPointData): IMatrix;
    getLayout(origin?: IPointData, around?: IPointData, firstSkewY?: boolean): ILayoutData;
    withScale(scaleX?: number, scaleY?: number): IMatrixWithScaleData;
    reset(): void;
}
declare const tempMatrix: Matrix;

declare const PointHelper: {
    defaultPoint: IPointData;
    tempPoint: IPointData;
    tempRadiusPoint: IRadiusPointData;
    set(t: IPointData, x?: number, y?: number): void;
    setRadius(t: IRadiusPointData, x: number, y?: number): void;
    copy(t: IPointData, point: IPointData): void;
    copyFrom(t: IPointData, x: number, y: number): void;
    round(t: IPointData, halfPixel?: boolean): void;
    move(t: IPointData, x: number | IPointData, y?: number): void;
    scale(t: IPointData, scaleX: number, scaleY?: number): void;
    scaleOf(t: IPointData, origin: IPointData, scaleX: number, scaleY?: number): void;
    rotate(t: IPointData, rotation: number, origin?: IPointData): void;
    tempToInnerOf(t: IPointData, matrix: IMatrixData): IPointData;
    tempToOuterOf(t: IPointData, matrix: IMatrixData): IPointData;
    tempToInnerRadiusPointOf(t: IRadiusPointData, matrix: IMatrixWithScaleData): IRadiusPointData;
    copyRadiusPoint(t: IRadiusPointData, point: IPointData, x: number, y?: number): IRadiusPointData;
    toInnerRadiusPointOf(t: IRadiusPointData, matrix: IMatrixWithScaleData, to?: IRadiusPointData): void;
    toInnerOf(t: IPointData, matrix: IMatrixData, to?: IPointData): void;
    toOuterOf(t: IPointData, matrix: IMatrixData, to?: IPointData): void;
    getCenter(t: IPointData, to: IPointData): IPointData;
    getCenterX(x1: number, x2: number): number;
    getCenterY(y1: number, y2: number): number;
    getDistance(t: IPointData, point: IPointData): number;
    getDistanceFrom(x1: number, y1: number, x2: number, y2: number): number;
    getMinDistanceFrom(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): number;
    getAngle(t: IPointData, to: IPointData): number;
    getRotation(t: IPointData, origin: IPointData, to: IPointData, toOrigin?: IPointData): number;
    getRadianFrom(fromX: number, fromY: number, originX: number, originY: number, toX: number, toY: number, toOriginX?: number, toOriginY?: number): number;
    getAtan2(t: IPointData, to: IPointData): number;
    getDistancePoint(t: IPointData, to: IPointData, distance: number, changeTo?: boolean, fromTo?: boolean): IPointData;
    toNumberPoints(originPoints: number[] | IPointData[]): number[];
    isSame(t: IPointData, point: IPointData): boolean;
    reset(t: IPointData): void;
};

declare const AroundHelper: {
    directionData: IUnitPointData[];
    tempPoint: IPointData;
    get: typeof get;
    toPoint(around: IAround, box: IBoundsData, to: IPointData, onlyBoxSize?: boolean, content?: IBoundsData, onlyContentSize?: boolean): void;
    getPoint(around: IAround, box: IBoundsData, to?: IPointData): IPointData;
};
declare function get(around: IAround): IUnitPointData;

declare const AlignHelper: {
    toPoint(align: IAlign, content: IBoundsData, box: IBoundsData, to: IPointData, onlyBoxSize?: boolean, onlyContentSize?: boolean): void;
};

declare const BoundsHelper: {
    tempBounds: IBoundsData;
    set(t: IBoundsData, x?: number, y?: number, width?: number, height?: number): void;
    copy(t: IBoundsData, bounds: IBoundsData): void;
    copyAndSpread(t: IBoundsData, bounds: IBoundsData, spread: IFourNumber, isShrink?: boolean, side?: ISide): void;
    minX(t: IBoundsData): number;
    minY(t: IBoundsData): number;
    maxX(t: IBoundsData): number;
    maxY(t: IBoundsData): number;
    move(t: IBoundsData, x: number, y: number): void;
    scroll(t: IBoundsData, data: IScrollPointData): void;
    getByMove(t: IBoundsData, x: number, y: number): IBoundsData;
    toOffsetOutBounds(t: IBoundsData, to?: IOffsetBoundsData, offsetBounds?: IBoundsData): void;
    scale(t: IBoundsData, scaleX: number, scaleY?: number, onlySize?: boolean): void;
    scaleOf(t: IBoundsData, origin: IPointData, scaleX: number, scaleY?: number): void;
    tempToOuterOf(t: IBoundsData, matrix: IMatrixData): IBoundsData;
    getOuterOf(t: IBoundsData, matrix: IMatrixData): IBoundsData;
    toOuterOf(t: IBoundsData, matrix: IMatrixData, to?: IBoundsData): void;
    toInnerOf(t: IBoundsData, matrix: IMatrixData, to?: IBoundsData): void;
    getFitMatrix(t: IBoundsData, put: IBoundsData, baseScale?: number): IMatrix;
    getFitScale(t: ISizeData, put: ISizeData, isCoverMode?: boolean): number;
    put(t: ISizeData, put: ISizeData, align?: IAlign, putScale?: number | "fit" | "cover", changeSize?: boolean, to?: IPointData): void;
    getSpread(t: IBoundsData, spread: IFourNumber, side?: ISide): IBoundsData;
    spread(t: IBoundsData, spread: IFourNumber, side?: ISide): void;
    shrink(t: IBoundsData, shrink: IFourNumber, side?: ISide): void;
    ceil(t: IBoundsData): void;
    unsign(t: IBoundsData): void;
    float(t: IBoundsData, maxLength?: number): void;
    add(t: IBoundsData, bounds: IBoundsData, isPoint?: boolean): void;
    addList(t: IBoundsData, list: IBoundsData[]): void;
    setList(t: IBoundsData, list: IBoundsData[], addMode?: boolean): void;
    addListWithFn(t: IBoundsData, list: IObject[], boundsDataFn: IBoundsDataFn): void;
    setListWithFn(t: IBoundsData, list: IObject[], boundsDataFn: IBoundsDataFn, addMode?: boolean): void;
    setPoints(t: IBoundsData, points: IPointData[]): void;
    setPoint(t: IBoundsData, point: IPointData): void;
    addPoint(t: IBoundsData, point: IPointData): void;
    getPoints(t: IBoundsData): IPointData[];
    hitRadiusPoint(t: IBoundsData, point: IRadiusPointData, pointMatrix?: IMatrixWithScaleData): boolean;
    hitPoint(t: IBoundsData, point: IPointData, pointMatrix?: IMatrixData): boolean;
    hit(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): boolean;
    includes(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): boolean;
    getIntersectData(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): IBoundsData;
    intersect(t: IBoundsData, other: IBoundsData, otherMatrix?: IMatrixData): void;
    isSame(t: IBoundsData, bounds: IBoundsData): boolean;
    isEmpty(t: IBoundsData): boolean;
    hasSize(t: IBoundsData): boolean;
    reset(t: IBoundsData): void;
};

declare const TwoPointBoundsHelper: {
    tempPointBounds: ITwoPointBoundsData;
    setPoint(t: ITwoPointBoundsData, minX: number, minY: number): void;
    addPoint(t: ITwoPointBoundsData, x: number, y: number): void;
    addBounds(t: ITwoPointBoundsData, x: number, y: number, width: number, height: number): void;
    copy(t: ITwoPointBoundsData, pb: ITwoPointBoundsData): void;
    addPointBounds(t: ITwoPointBoundsData, pb: ITwoPointBoundsData): void;
    toBounds(t: ITwoPointBoundsData, setBounds: IBoundsData): void;
};

declare const MathHelper: {
    within(value: number, min: number | IRangeSize, max?: number): number;
    fourNumber: (num: _leafer_interface.IFourNumber, maxValue?: number) => number[];
    formatRotation(rotation: number, unsign?: boolean): number;
    getGapRotation(addRotation: number, gap: number, oldRotation?: number): number;
    float(num: number, maxLength?: number): number;
    sign(num: number): number;
    getScaleData(scale: number | IPointData, size: number | IOptionSizeData, originSize: ISizeData, scaleData?: IScaleData): IScaleData;
    assignScale(scaleData: IScaleData, scale: number | IPointData): void;
    getFloorScale(num: number, min?: number): number;
    randInt: typeof randInt;
    randColor(opacity?: number): string;
};
declare function randInt(num: number): number;
declare const OneRadian: number;
declare const PI2: number;
declare const PI_2: number;
declare function getPointData(): IPointData;
declare function getBoundsData(): IBoundsData;
declare function getMatrixData(): IMatrixData;

declare function getWorld(): IMatrixWithLayoutData;
declare const MatrixHelper: {
    defaultMatrix: IMatrixData;
    defaultWorld: IMatrixWithLayoutData;
    tempMatrix: IMatrixData;
    set(t: IMatrixData, a?: number, b?: number, c?: number, d?: number, e?: number, f?: number): void;
    get: typeof getMatrixData;
    getWorld: typeof getWorld;
    copy(t: IMatrixData, matrix: IMatrixData): void;
    translate(t: IMatrixData, x: number, y: number): void;
    translateInner(t: IMatrixData, x: number, y: number, hasOrigin?: boolean): void;
    scale(t: IMatrixData, scaleX: number, scaleY?: number): void;
    pixelScale(t: IMatrixData, pixelRatio: number, to?: IMatrixData): void;
    scaleOfOuter(t: IMatrixData, origin: IPointData, scaleX: number, scaleY?: number): void;
    scaleOfInner(t: IMatrixData, origin: IPointData, scaleX: number, scaleY?: number): void;
    rotate(t: IMatrixData, rotation: number): void;
    rotateOfOuter(t: IMatrixData, origin: IPointData, rotation: number): void;
    rotateOfInner(t: IMatrixData, origin: IPointData, rotation: number): void;
    skew(t: IMatrixData, skewX: number, skewY?: number): void;
    skewOfOuter(t: IMatrixData, origin: IPointData, skewX: number, skewY?: number): void;
    skewOfInner(t: IMatrixData, origin: IPointData, skewX: number, skewY?: number): void;
    multiply(t: IMatrixData, child: IMatrixData): void;
    multiplyParent(t: IMatrixWithOptionScaleData, parent: IMatrixWithOptionScaleData, to?: IMatrixWithOptionScaleData, abcdChanged?: boolean | number, childScaleData?: IScaleData): void;
    divide(t: IMatrixData, child: IMatrixData): void;
    divideParent(t: IMatrixData, parent: IMatrixData): void;
    tempInvert(t: IMatrixData): IMatrixData;
    invert(t: IMatrixData): void;
    toOuterPoint(t: IMatrixData, inner: IPointData, to?: IPointData, distance?: boolean): void;
    toInnerPoint(t: IMatrixData, outer: IPointData, to?: IPointData, distance?: boolean): void;
    setLayout(t: IMatrixData, layout: ILayoutData, origin?: IPointData, around?: IPointData, bcChanged?: boolean | number): void;
    getLayout(t: IMatrixData, origin?: IPointData, around?: IPointData, firstSkewY?: boolean): ILayoutData;
    withScale(t: IMatrixData, scaleX?: number, scaleY?: number): IMatrixWithScaleData;
    reset(t: IMatrixData): void;
};

declare const FourNumberHelper: {
    zero: number[];
    tempFour: number[];
    set(to: number[], top: number, right?: number, bottom?: number, left?: number): number[];
    setTemp(top: number, right?: number, bottom?: number, left?: number): number[];
    toTempAB(a: IFourNumber, b: IFourNumber, change?: boolean): void;
    get(num: IFourNumber, maxValue?: number): number[];
    max(t: IFourNumber, other: IFourNumber, change?: boolean): IFourNumber;
    add(t: IFourNumber, other: IFourNumber, change?: boolean): IFourNumber;
    swapAndScale(t: IFourNumber, scaleX: number, scaleY: number, change?: boolean): IFourNumber;
};

declare const UnitConvertHelper: {
    number(value: number | IUnitData, percentRefer?: number): number;
};

declare const StringNumberMap: INumberMap;

declare enum Direction4 {
    top = 0,
    right = 1,
    bottom = 2,
    left = 3
}
declare enum Direction9 {
    topLeft = 0,
    top = 1,
    topRight = 2,
    right = 3,
    bottomRight = 4,
    bottom = 5,
    bottomLeft = 6,
    left = 7,
    center = 8,
    'top-left' = 0,
    'top-right' = 2,
    'bottom-right' = 4,
    'bottom-left' = 6
}

export { AlignHelper, AroundHelper, AutoBounds, Bounds, BoundsHelper, Direction4, Direction9, FourNumberHelper, IncrementId, MathHelper, Matrix, MatrixHelper, OneRadian, PI2, PI_2, Point, PointHelper, StringNumberMap, TwoPointBoundsHelper, UnitConvertHelper, getBoundsData, getMatrixData, getPointData, tempBounds, tempMatrix, tempPoint };
