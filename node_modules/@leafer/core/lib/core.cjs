"use strict";

exports.Answer = void 0;

(function(Answer) {
    Answer[Answer["No"] = 0] = "No";
    Answer[Answer["Yes"] = 1] = "Yes";
    Answer[Answer["NoAndSkip"] = 2] = "NoAndSkip";
    Answer[Answer["YesAndSkip"] = 3] = "YesAndSkip";
})(exports.Answer || (exports.Answer = {}));

const emptyData = {};

function isUndefined(value) {
    return value === undefined;
}

function isNull(value) {
    return value == null;
}

function isString(value) {
    return typeof value === "string";
}

const {isFinite: isFinite} = Number;

function isNumber(value) {
    return typeof value === "number";
}

const numberReg = /^-?\d+(?:\.\d+)?$/;

function tryToNumber(value) {
    return typeof value === "string" && numberReg.test(value) ? +value : value;
}

const {isArray: isArray} = Array;

function isObject(value) {
    return value && typeof value === "object";
}

function isData(value) {
    return isObject(value) && !isArray(value);
}

function isEmptyData(value) {
    return JSON.stringify(value) === "{}";
}

const DataHelper = {
    default(t, defaultData) {
        assign(defaultData, t);
        assign(t, defaultData);
        return t;
    },
    assign(t, merge, exclude) {
        let value;
        Object.keys(merge).forEach(key => {
            var _a, _b;
            value = merge[key];
            if ((value === null || value === void 0 ? void 0 : value.constructor) === Object && ((_a = t[key]) === null || _a === void 0 ? void 0 : _a.constructor) === Object) return assign(t[key], merge[key], exclude && exclude[key]);
            if (exclude && key in exclude) {
                if (((_b = exclude[key]) === null || _b === void 0 ? void 0 : _b.constructor) === Object) assign(t[key] = {}, merge[key], exclude[key]);
                return;
            }
            t[key] = merge[key];
        });
    },
    copyAttrs(t, from, include) {
        include.forEach(key => {
            if (!isUndefined(from[key])) t[key] = from[key];
        });
        return t;
    },
    clone(data) {
        return JSON.parse(JSON.stringify(data));
    },
    toMap(list) {
        const map = {};
        for (let i = 0, len = list.length; i < len; i++) map[list[i]] = true;
        return map;
    },
    stintSet(data, attrName, value) {
        value || (value = undefined);
        data[attrName] !== value && (data[attrName] = value);
    }
};

const {assign: assign} = DataHelper;

class LeafData {
    get __useNaturalRatio() {
        return true;
    }
    get __isLinePath() {
        const {path: path} = this;
        return path && path.length === 6 && path[0] === 1;
    }
    get __usePathBox() {
        return this.__pathInputed;
    }
    get __blendMode() {
        if (this.eraser && this.eraser !== "path") return "destination-out";
        const {blendMode: blendMode} = this;
        return blendMode === "pass-through" ? null : blendMode;
    }
    constructor(leaf) {
        this.__leaf = leaf;
    }
    __get(name) {
        if (this.__input) {
            const value = this.__input[name];
            if (!isUndefined(value)) return value;
        }
        return this[name];
    }
    __getData() {
        const data = {
            tag: this.__leaf.tag
        }, {__input: __input} = this;
        let inputValue;
        for (let key in this) {
            if (key[0] !== "_") {
                inputValue = __input ? __input[key] : undefined;
                data[key] = isUndefined(inputValue) ? this[key] : inputValue;
            }
        }
        return data;
    }
    __setInput(name, value) {
        this.__input || (this.__input = {});
        this.__input[name] = value;
    }
    __getInput(name) {
        if (this.__input) {
            const value = this.__input[name];
            if (!isUndefined(value)) return value;
        }
        if (name === "path" && !this.__pathInputed) return;
        return this["_" + name];
    }
    __removeInput(name) {
        if (this.__input && !isUndefined(this.__input[name])) this.__input[name] = undefined;
    }
    __getInputData(names, options) {
        const data = {};
        if (names) {
            if (isArray(names)) {
                for (let name of names) data[name] = this.__getInput(name);
            } else {
                for (let name in names) data[name] = this.__getInput(name);
            }
        } else {
            let value, inputValue, {__input: __input} = this;
            data.tag = this.__leaf.tag;
            for (let key in this) {
                if (key[0] !== "_") {
                    value = this["_" + key];
                    if (!isUndefined(value)) {
                        if (key === "path" && !this.__pathInputed) continue;
                        inputValue = __input ? __input[key] : undefined;
                        data[key] = isUndefined(inputValue) ? value : inputValue;
                    }
                }
            }
        }
        if (options) {
            if (options.matrix) {
                const {a: a, b: b, c: c, d: d, e: e, f: f} = this.__leaf.__localMatrix;
                data.matrix = {
                    a: a,
                    b: b,
                    c: c,
                    d: d,
                    e: e,
                    f: f
                };
            }
        }
        return data;
    }
    __setMiddle(name, value) {
        this.__middle || (this.__middle = {});
        this.__middle[name] = value;
    }
    __getMiddle(name) {
        return this.__middle && this.__middle[name];
    }
    __checkSingle() {
        const t = this;
        if (t.blendMode === "pass-through") {
            const leaf = this.__leaf;
            if (t.opacity < 1 && (leaf.isBranch || t.__hasMultiPaint) || leaf.__hasEraser || t.eraser || t.filter) {
                t.__single = true;
            } else if (t.__single) {
                t.__single = false;
            }
        } else {
            t.__single = true;
        }
    }
    __removeNaturalSize() {
        this.__naturalWidth = this.__naturalHeight = undefined;
    }
    destroy() {
        this.__input = this.__middle = null;
    }
}

const IncrementId = {
    RUNTIME: "runtime",
    LEAF: "leaf",
    TASK: "task",
    CNAVAS: "canvas",
    IMAGE: "image",
    types: {},
    create(typeName) {
        const {types: types} = I$1;
        if (types[typeName]) {
            return types[typeName]++;
        } else {
            types[typeName] = 1;
            return 0;
        }
    }
};

const I$1 = IncrementId;

let tempA, tempB, tempTo;

const {max: max$2} = Math, tempFour = [ 0, 0, 0, 0 ];

const FourNumberHelper = {
    zero: [ ...tempFour ],
    tempFour: tempFour,
    set(to, top, right, bottom, left) {
        if (right === undefined) right = bottom = left = top;
        to[0] = top;
        to[1] = right;
        to[2] = bottom;
        to[3] = left;
        return to;
    },
    setTemp(top, right, bottom, left) {
        return set$1(tempFour, top, right, bottom, left);
    },
    toTempAB(a, b, change) {
        tempTo = change ? isNumber(a) ? b : a : [];
        if (isNumber(a)) tempA = setTemp(a), tempB = b; else if (isNumber(b)) tempA = a, 
        tempB = setTemp(b); else tempA = a, tempB = b;
        if (tempA.length !== 4) tempA = get$1(tempA);
        if (tempB.length !== 4) tempB = get$1(tempB);
    },
    get(num, maxValue) {
        let data;
        if (!isNumber(num)) {
            switch (num.length) {
              case 4:
                data = isUndefined(maxValue) ? num : [ ...num ];
                break;

              case 2:
                data = [ num[0], num[1], num[0], num[1] ];
                break;

              case 3:
                data = [ num[0], num[1], num[2], num[1] ];
                break;

              case 1:
                num = num[0];
                break;

              default:
                num = 0;
            }
        }
        if (!data) data = [ num, num, num, num ];
        if (!isUndefined(maxValue)) for (let i = 0; i < 4; i++) if (data[i] > maxValue) data[i] = maxValue;
        return data;
    },
    max(t, other, change) {
        if (isNumber(t) && isNumber(other)) return max$2(t, other);
        toTempAB(t, other, change);
        return set$1(tempTo, max$2(tempA[0], tempB[0]), max$2(tempA[1], tempB[1]), max$2(tempA[2], tempB[2]), max$2(tempA[3], tempB[3]));
    },
    add(t, other, change) {
        if (isNumber(t) && isNumber(other)) return t + other;
        toTempAB(t, other, change);
        return set$1(tempTo, tempA[0] + tempB[0], tempA[1] + tempB[1], tempA[2] + tempB[2], tempA[3] + tempB[3]);
    },
    swapAndScale(t, scaleX, scaleY, change) {
        if (isNumber(t)) return scaleX === scaleY ? t * scaleX : [ t * scaleY, t * scaleX ];
        const to = change ? t : [];
        const [top, right, bottom, left] = t.length === 4 ? t : get$1(t);
        return set$1(to, bottom * scaleY, left * scaleX, top * scaleY, right * scaleX);
    }
};

const {set: set$1, get: get$1, setTemp: setTemp, toTempAB: toTempAB} = FourNumberHelper;

const {round: round$3, pow: pow$1, max: max$1, floor: floor$2, PI: PI$1} = Math;

const MathHelper = {
    within(value, min, max) {
        if (isObject(min)) max = min.max, min = min.min;
        if (!isUndefined(min) && value < min) value = min;
        if (!isUndefined(max) && value > max) value = max;
        return value;
    },
    fourNumber: FourNumberHelper.get,
    formatRotation(rotation, unsign) {
        rotation %= 360;
        if (unsign) {
            if (rotation < 0) rotation += 360;
        } else {
            if (rotation > 180) rotation -= 360;
            if (rotation < -180) rotation += 360;
        }
        return MathHelper.float(rotation);
    },
    getGapRotation(addRotation, gap, oldRotation = 0) {
        let rotation = addRotation + oldRotation;
        if (gap > 1) {
            const r = Math.abs(rotation % gap);
            if (r < 1 || r > gap - 1) rotation = Math.round(rotation / gap) * gap;
        }
        return rotation - oldRotation;
    },
    float(num, maxLength) {
        const a = !isUndefined(maxLength) ? pow$1(10, maxLength) : 1e12;
        num = round$3(num * a) / a;
        return num === -0 ? 0 : num;
    },
    sign(num) {
        return num < 0 ? -1 : 1;
    },
    getScaleData(scale, size, originSize, scaleData) {
        if (!scaleData) scaleData = {};
        if (size) {
            const scaleX = (isNumber(size) ? size : size.width || 0) / originSize.width, scaleY = (isNumber(size) ? size : size.height || 0) / originSize.height;
            scaleData.scaleX = scaleX || scaleY || 1;
            scaleData.scaleY = scaleY || scaleX || 1;
        } else if (scale) MathHelper.assignScale(scaleData, scale);
        return scaleData;
    },
    assignScale(scaleData, scale) {
        if (isNumber(scale)) {
            scaleData.scaleX = scaleData.scaleY = scale;
        } else {
            scaleData.scaleX = scale.x;
            scaleData.scaleY = scale.y;
        }
    },
    getFloorScale(num, min = 1) {
        return max$1(floor$2(num), min) / num;
    },
    randInt: randInt,
    randColor(opacity) {
        return `rgba(${randInt(255)},${randInt(255)},${randInt(255)},${opacity || 1})`;
    }
};

function randInt(num) {
    return Math.round(Math.random() * num);
}

const OneRadian = PI$1 / 180;

const PI2 = PI$1 * 2;

const PI_2 = PI$1 / 2;

function getPointData() {
    return {
        x: 0,
        y: 0
    };
}

function getBoundsData() {
    return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
}

function getMatrixData() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
}

const {sin: sin$3, cos: cos$3, acos: acos, sqrt: sqrt$3} = Math;

const {float: float$2} = MathHelper;

const tempPoint$3 = {};

function getWorld() {
    return Object.assign(Object.assign(Object.assign({}, getMatrixData()), getBoundsData()), {
        scaleX: 1,
        scaleY: 1,
        rotation: 0,
        skewX: 0,
        skewY: 0
    });
}

const MatrixHelper = {
    defaultMatrix: getMatrixData(),
    defaultWorld: getWorld(),
    tempMatrix: {},
    set(t, a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {
        t.a = a;
        t.b = b;
        t.c = c;
        t.d = d;
        t.e = e;
        t.f = f;
    },
    get: getMatrixData,
    getWorld: getWorld,
    copy(t, matrix) {
        t.a = matrix.a;
        t.b = matrix.b;
        t.c = matrix.c;
        t.d = matrix.d;
        t.e = matrix.e;
        t.f = matrix.f;
    },
    translate(t, x, y) {
        t.e += x;
        t.f += y;
    },
    translateInner(t, x, y, hasOrigin) {
        t.e += t.a * x + t.c * y;
        t.f += t.b * x + t.d * y;
        if (hasOrigin) t.e -= x, t.f -= y;
    },
    scale(t, scaleX, scaleY = scaleX) {
        t.a *= scaleX;
        t.b *= scaleX;
        t.c *= scaleY;
        t.d *= scaleY;
    },
    pixelScale(t, pixelRatio, to) {
        to || (to = t);
        to.a = t.a * pixelRatio;
        to.b = t.b * pixelRatio;
        to.c = t.c * pixelRatio;
        to.d = t.d * pixelRatio;
        to.e = t.e * pixelRatio;
        to.f = t.f * pixelRatio;
    },
    scaleOfOuter(t, origin, scaleX, scaleY) {
        M$6.toInnerPoint(t, origin, tempPoint$3);
        M$6.scaleOfInner(t, tempPoint$3, scaleX, scaleY);
    },
    scaleOfInner(t, origin, scaleX, scaleY = scaleX) {
        M$6.translateInner(t, origin.x, origin.y);
        M$6.scale(t, scaleX, scaleY);
        M$6.translateInner(t, -origin.x, -origin.y);
    },
    rotate(t, rotation) {
        const {a: a, b: b, c: c, d: d} = t;
        rotation *= OneRadian;
        const cosR = cos$3(rotation);
        const sinR = sin$3(rotation);
        t.a = a * cosR - b * sinR;
        t.b = a * sinR + b * cosR;
        t.c = c * cosR - d * sinR;
        t.d = c * sinR + d * cosR;
    },
    rotateOfOuter(t, origin, rotation) {
        M$6.toInnerPoint(t, origin, tempPoint$3);
        M$6.rotateOfInner(t, tempPoint$3, rotation);
    },
    rotateOfInner(t, origin, rotation) {
        M$6.translateInner(t, origin.x, origin.y);
        M$6.rotate(t, rotation);
        M$6.translateInner(t, -origin.x, -origin.y);
    },
    skew(t, skewX, skewY) {
        const {a: a, b: b, c: c, d: d} = t;
        if (skewY) {
            skewY *= OneRadian;
            t.a = a + c * skewY;
            t.b = b + d * skewY;
        }
        if (skewX) {
            skewX *= OneRadian;
            t.c = c + a * skewX;
            t.d = d + b * skewX;
        }
    },
    skewOfOuter(t, origin, skewX, skewY) {
        M$6.toInnerPoint(t, origin, tempPoint$3);
        M$6.skewOfInner(t, tempPoint$3, skewX, skewY);
    },
    skewOfInner(t, origin, skewX, skewY = 0) {
        M$6.translateInner(t, origin.x, origin.y);
        M$6.skew(t, skewX, skewY);
        M$6.translateInner(t, -origin.x, -origin.y);
    },
    multiply(t, child) {
        const {a: a, b: b, c: c, d: d, e: e, f: f} = t;
        t.a = child.a * a + child.b * c;
        t.b = child.a * b + child.b * d;
        t.c = child.c * a + child.d * c;
        t.d = child.c * b + child.d * d;
        t.e = child.e * a + child.f * c + e;
        t.f = child.e * b + child.f * d + f;
    },
    multiplyParent(t, parent, to, abcdChanged, childScaleData) {
        const {e: e, f: f} = t;
        to || (to = t);
        if (isUndefined(abcdChanged)) abcdChanged = t.a !== 1 || t.b || t.c || t.d !== 1;
        if (abcdChanged) {
            const {a: a, b: b, c: c, d: d} = t;
            to.a = a * parent.a + b * parent.c;
            to.b = a * parent.b + b * parent.d;
            to.c = c * parent.a + d * parent.c;
            to.d = c * parent.b + d * parent.d;
            if (childScaleData) {
                to.scaleX = parent.scaleX * childScaleData.scaleX;
                to.scaleY = parent.scaleY * childScaleData.scaleY;
            }
        } else {
            to.a = parent.a;
            to.b = parent.b;
            to.c = parent.c;
            to.d = parent.d;
            if (childScaleData) {
                to.scaleX = parent.scaleX;
                to.scaleY = parent.scaleY;
            }
        }
        to.e = e * parent.a + f * parent.c + parent.e;
        to.f = e * parent.b + f * parent.d + parent.f;
    },
    divide(t, child) {
        M$6.multiply(t, M$6.tempInvert(child));
    },
    divideParent(t, parent) {
        M$6.multiplyParent(t, M$6.tempInvert(parent));
    },
    tempInvert(t) {
        const {tempMatrix: tempMatrix} = M$6;
        M$6.copy(tempMatrix, t);
        M$6.invert(tempMatrix);
        return tempMatrix;
    },
    invert(t) {
        const {a: a, b: b, c: c, d: d, e: e, f: f} = t;
        if (!b && !c) {
            if (a === 1 && d === 1) {
                t.e = -e;
                t.f = -f;
            } else {
                const s = 1 / (a * d);
                t.a = d * s;
                t.d = a * s;
                t.e = -e * d * s;
                t.f = -f * a * s;
            }
        } else {
            const s = 1 / (a * d - b * c);
            t.a = d * s;
            t.b = -b * s;
            t.c = -c * s;
            t.d = a * s;
            t.e = -(e * d - f * c) * s;
            t.f = -(f * a - e * b) * s;
        }
    },
    toOuterPoint(t, inner, to, distance) {
        const {x: x, y: y} = inner;
        to || (to = inner);
        to.x = x * t.a + y * t.c;
        to.y = x * t.b + y * t.d;
        if (!distance) {
            to.x += t.e;
            to.y += t.f;
        }
    },
    toInnerPoint(t, outer, to, distance) {
        const {a: a, b: b, c: c, d: d} = t;
        const s = 1 / (a * d - b * c);
        const {x: x, y: y} = outer;
        to || (to = outer);
        to.x = (x * d - y * c) * s;
        to.y = (y * a - x * b) * s;
        if (!distance) {
            const {e: e, f: f} = t;
            to.x -= (e * d - f * c) * s;
            to.y -= (f * a - e * b) * s;
        }
    },
    setLayout(t, layout, origin, around, bcChanged) {
        const {x: x, y: y, scaleX: scaleX, scaleY: scaleY} = layout;
        if (isUndefined(bcChanged)) bcChanged = layout.rotation || layout.skewX || layout.skewY;
        if (bcChanged) {
            const {rotation: rotation, skewX: skewX, skewY: skewY} = layout;
            const r = rotation * OneRadian;
            const cosR = cos$3(r);
            const sinR = sin$3(r);
            if (skewX || skewY) {
                const sx = skewX * OneRadian;
                const sy = skewY * OneRadian;
                t.a = (cosR + sy * -sinR) * scaleX;
                t.b = (sinR + sy * cosR) * scaleX;
                t.c = (-sinR + sx * cosR) * scaleY;
                t.d = (cosR + sx * sinR) * scaleY;
            } else {
                t.a = cosR * scaleX;
                t.b = sinR * scaleX;
                t.c = -sinR * scaleY;
                t.d = cosR * scaleY;
            }
        } else {
            t.a = scaleX;
            t.b = 0;
            t.c = 0;
            t.d = scaleY;
        }
        t.e = x;
        t.f = y;
        if (origin = origin || around) M$6.translateInner(t, -origin.x, -origin.y, !around);
    },
    getLayout(t, origin, around, firstSkewY) {
        const {a: a, b: b, c: c, d: d, e: e, f: f} = t;
        let x = e, y = f, scaleX, scaleY, rotation, skewX, skewY;
        if (b || c) {
            const s = a * d - b * c;
            if (c && !firstSkewY) {
                scaleX = sqrt$3(a * a + b * b);
                scaleY = s / scaleX;
                const cosR = a / scaleX;
                rotation = b > 0 ? acos(cosR) : -acos(cosR);
            } else {
                scaleY = sqrt$3(c * c + d * d);
                scaleX = s / scaleY;
                const cosR = c / scaleY;
                rotation = PI_2 - (d > 0 ? acos(-cosR) : -acos(cosR));
            }
            const cosR = float$2(cos$3(rotation));
            const sinR = sin$3(rotation);
            scaleX = float$2(scaleX), scaleY = float$2(scaleY);
            skewX = cosR ? float$2((c / scaleY + sinR) / cosR / OneRadian, 9) : 0;
            skewY = cosR ? float$2((b / scaleX - sinR) / cosR / OneRadian, 9) : 0;
            rotation = float$2(rotation / OneRadian);
        } else {
            scaleX = a;
            scaleY = d;
            rotation = skewX = skewY = 0;
        }
        if (origin = around || origin) {
            x += origin.x * a + origin.y * c;
            y += origin.x * b + origin.y * d;
            if (!around) x -= origin.x, y -= origin.y;
        }
        return {
            x: x,
            y: y,
            scaleX: scaleX,
            scaleY: scaleY,
            rotation: rotation,
            skewX: skewX,
            skewY: skewY
        };
    },
    withScale(t, scaleX, scaleY = scaleX) {
        const world = t;
        if (!scaleX || !scaleY) {
            const {a: a, b: b, c: c, d: d} = t;
            if (b || c) {
                scaleX = sqrt$3(a * a + b * b);
                scaleY = (a * d - b * c) / scaleX;
            } else {
                scaleX = a;
                scaleY = d;
            }
        }
        world.scaleX = scaleX;
        world.scaleY = scaleY;
        return world;
    },
    reset(t) {
        M$6.set(t);
    }
};

const M$6 = MatrixHelper;

const {float: float$1} = MathHelper;

const {toInnerPoint: toInnerPoint$2, toOuterPoint: toOuterPoint$3} = MatrixHelper;

const {sin: sin$2, cos: cos$2, abs: abs$2, sqrt: sqrt$2, atan2: atan2$2, min: min$1, round: round$2} = Math;

const PointHelper = {
    defaultPoint: getPointData(),
    tempPoint: {},
    tempRadiusPoint: {},
    set(t, x = 0, y = 0) {
        t.x = x;
        t.y = y;
    },
    setRadius(t, x, y) {
        t.radiusX = x;
        t.radiusY = isUndefined(y) ? x : y;
    },
    copy(t, point) {
        t.x = point.x;
        t.y = point.y;
    },
    copyFrom(t, x, y) {
        t.x = x;
        t.y = y;
    },
    round(t, halfPixel) {
        t.x = halfPixel ? round$2(t.x - .5) + .5 : round$2(t.x);
        t.y = halfPixel ? round$2(t.y - .5) + .5 : round$2(t.y);
    },
    move(t, x, y) {
        if (isObject(x)) t.x += x.x, t.y += x.y; else t.x += x, t.y += y;
    },
    scale(t, scaleX, scaleY = scaleX) {
        if (t.x) t.x *= scaleX;
        if (t.y) t.y *= scaleY;
    },
    scaleOf(t, origin, scaleX, scaleY = scaleX) {
        t.x += (t.x - origin.x) * (scaleX - 1);
        t.y += (t.y - origin.y) * (scaleY - 1);
    },
    rotate(t, rotation, origin) {
        if (!origin) origin = P$5.defaultPoint;
        rotation *= OneRadian;
        const cosR = cos$2(rotation);
        const sinR = sin$2(rotation);
        const rx = t.x - origin.x;
        const ry = t.y - origin.y;
        t.x = origin.x + rx * cosR - ry * sinR;
        t.y = origin.y + rx * sinR + ry * cosR;
    },
    tempToInnerOf(t, matrix) {
        const {tempPoint: temp} = P$5;
        copy$7(temp, t);
        toInnerPoint$2(matrix, temp, temp);
        return temp;
    },
    tempToOuterOf(t, matrix) {
        const {tempPoint: temp} = P$5;
        copy$7(temp, t);
        toOuterPoint$3(matrix, temp, temp);
        return temp;
    },
    tempToInnerRadiusPointOf(t, matrix) {
        const {tempRadiusPoint: temp} = P$5;
        copy$7(temp, t);
        P$5.toInnerRadiusPointOf(t, matrix, temp);
        return temp;
    },
    copyRadiusPoint(t, point, x, y) {
        copy$7(t, point);
        setRadius(t, x, y);
        return t;
    },
    toInnerRadiusPointOf(t, matrix, to) {
        to || (to = t);
        toInnerPoint$2(matrix, t, to);
        to.radiusX = Math.abs(t.radiusX / matrix.scaleX);
        to.radiusY = Math.abs(t.radiusY / matrix.scaleY);
    },
    toInnerOf(t, matrix, to) {
        toInnerPoint$2(matrix, t, to);
    },
    toOuterOf(t, matrix, to) {
        toOuterPoint$3(matrix, t, to);
    },
    getCenter(t, to) {
        return {
            x: t.x + (to.x - t.x) / 2,
            y: t.y + (to.y - t.y) / 2
        };
    },
    getCenterX(x1, x2) {
        return x1 + (x2 - x1) / 2;
    },
    getCenterY(y1, y2) {
        return y1 + (y2 - y1) / 2;
    },
    getDistance(t, point) {
        return getDistanceFrom(t.x, t.y, point.x, point.y);
    },
    getDistanceFrom(x1, y1, x2, y2) {
        const x = abs$2(x2 - x1);
        const y = abs$2(y2 - y1);
        return sqrt$2(x * x + y * y);
    },
    getMinDistanceFrom(x1, y1, x2, y2, x3, y3) {
        return min$1(getDistanceFrom(x1, y1, x2, y2), getDistanceFrom(x2, y2, x3, y3));
    },
    getAngle(t, to) {
        return getAtan2(t, to) / OneRadian;
    },
    getRotation(t, origin, to, toOrigin) {
        if (!toOrigin) toOrigin = origin;
        return P$5.getRadianFrom(t.x, t.y, origin.x, origin.y, to.x, to.y, toOrigin.x, toOrigin.y) / OneRadian;
    },
    getRadianFrom(fromX, fromY, originX, originY, toX, toY, toOriginX, toOriginY) {
        if (isUndefined(toOriginX)) toOriginX = originX, toOriginY = originY;
        const a = fromX - originX;
        const b = fromY - originY;
        const c = toX - toOriginX;
        const d = toY - toOriginY;
        return Math.atan2(a * d - b * c, a * c + b * d);
    },
    getAtan2(t, to) {
        return atan2$2(to.y - t.y, to.x - t.x);
    },
    getDistancePoint(t, to, distance, changeTo, fromTo) {
        const r = getAtan2(t, to);
        fromTo && (t = to);
        changeTo || (to = {});
        to.x = t.x + cos$2(r) * distance;
        to.y = t.y + sin$2(r) * distance;
        return to;
    },
    toNumberPoints(originPoints) {
        let points = originPoints;
        if (isObject(originPoints[0])) points = [], originPoints.forEach(p => points.push(p.x, p.y));
        return points;
    },
    isSame(t, point) {
        return float$1(t.x) === float$1(point.x) && float$1(t.y) === float$1(point.y);
    },
    reset(t) {
        P$5.reset(t);
    }
};

const P$5 = PointHelper;

const {getDistanceFrom: getDistanceFrom, copy: copy$7, setRadius: setRadius, getAtan2: getAtan2} = P$5;

class Point {
    constructor(x, y) {
        this.set(x, y);
    }
    set(x, y) {
        isObject(x) ? PointHelper.copy(this, x) : PointHelper.set(this, x, y);
        return this;
    }
    get() {
        const {x: x, y: y} = this;
        return {
            x: x,
            y: y
        };
    }
    clone() {
        return new Point(this);
    }
    move(x, y) {
        PointHelper.move(this, x, y);
        return this;
    }
    scale(scaleX, scaleY) {
        PointHelper.scale(this, scaleX, scaleY);
        return this;
    }
    scaleOf(origin, scaleX, scaleY) {
        PointHelper.scaleOf(this, origin, scaleX, scaleY);
        return this;
    }
    rotate(rotation, origin) {
        PointHelper.rotate(this, rotation, origin);
        return this;
    }
    rotateOf(origin, rotation) {
        PointHelper.rotate(this, rotation, origin);
        return this;
    }
    getRotation(origin, to, toOrigin) {
        return PointHelper.getRotation(this, origin, to, toOrigin);
    }
    toInnerOf(matrix, to) {
        PointHelper.toInnerOf(this, matrix, to);
        return this;
    }
    toOuterOf(matrix, to) {
        PointHelper.toOuterOf(this, matrix, to);
        return this;
    }
    getCenter(to) {
        return new Point(PointHelper.getCenter(this, to));
    }
    getDistance(to) {
        return PointHelper.getDistance(this, to);
    }
    getDistancePoint(to, distance, changeTo, fromTo) {
        return new Point(PointHelper.getDistancePoint(this, to, distance, changeTo, fromTo));
    }
    getAngle(to) {
        return PointHelper.getAngle(this, to);
    }
    getAtan2(to) {
        return PointHelper.getAtan2(this, to);
    }
    isSame(point) {
        return PointHelper.isSame(this, point);
    }
    reset() {
        PointHelper.reset(this);
        return this;
    }
}

const tempPoint$2 = new Point;

class Matrix {
    constructor(a, b, c, d, e, f) {
        this.set(a, b, c, d, e, f);
    }
    set(a, b, c, d, e, f) {
        isObject(a) ? MatrixHelper.copy(this, a) : MatrixHelper.set(this, a, b, c, d, e, f);
        return this;
    }
    setWith(dataWithScale) {
        MatrixHelper.copy(this, dataWithScale);
        this.scaleX = dataWithScale.scaleX;
        this.scaleY = dataWithScale.scaleY;
        return this;
    }
    get() {
        const {a: a, b: b, c: c, d: d, e: e, f: f} = this;
        return {
            a: a,
            b: b,
            c: c,
            d: d,
            e: e,
            f: f
        };
    }
    clone() {
        return new Matrix(this);
    }
    translate(x, y) {
        MatrixHelper.translate(this, x, y);
        return this;
    }
    translateInner(x, y) {
        MatrixHelper.translateInner(this, x, y);
        return this;
    }
    scale(x, y) {
        MatrixHelper.scale(this, x, y);
        return this;
    }
    scaleWith(x, y) {
        MatrixHelper.scale(this, x, y);
        this.scaleX *= x;
        this.scaleY *= y || x;
        return this;
    }
    pixelScale(pixelRatio) {
        MatrixHelper.pixelScale(this, pixelRatio);
        return this;
    }
    scaleOfOuter(origin, x, y) {
        MatrixHelper.scaleOfOuter(this, origin, x, y);
        return this;
    }
    scaleOfInner(origin, x, y) {
        MatrixHelper.scaleOfInner(this, origin, x, y);
        return this;
    }
    rotate(angle) {
        MatrixHelper.rotate(this, angle);
        return this;
    }
    rotateOfOuter(origin, angle) {
        MatrixHelper.rotateOfOuter(this, origin, angle);
        return this;
    }
    rotateOfInner(origin, angle) {
        MatrixHelper.rotateOfInner(this, origin, angle);
        return this;
    }
    skew(x, y) {
        MatrixHelper.skew(this, x, y);
        return this;
    }
    skewOfOuter(origin, x, y) {
        MatrixHelper.skewOfOuter(this, origin, x, y);
        return this;
    }
    skewOfInner(origin, x, y) {
        MatrixHelper.skewOfInner(this, origin, x, y);
        return this;
    }
    multiply(child) {
        MatrixHelper.multiply(this, child);
        return this;
    }
    multiplyParent(parent) {
        MatrixHelper.multiplyParent(this, parent);
        return this;
    }
    divide(child) {
        MatrixHelper.divide(this, child);
        return this;
    }
    divideParent(parent) {
        MatrixHelper.divideParent(this, parent);
        return this;
    }
    invert() {
        MatrixHelper.invert(this);
        return this;
    }
    invertWith() {
        MatrixHelper.invert(this);
        this.scaleX = 1 / this.scaleX;
        this.scaleY = 1 / this.scaleY;
        return this;
    }
    toOuterPoint(inner, to, distance) {
        MatrixHelper.toOuterPoint(this, inner, to, distance);
    }
    toInnerPoint(outer, to, distance) {
        MatrixHelper.toInnerPoint(this, outer, to, distance);
    }
    setLayout(data, origin, around) {
        MatrixHelper.setLayout(this, data, origin, around);
        return this;
    }
    getLayout(origin, around, firstSkewY) {
        return MatrixHelper.getLayout(this, origin, around, firstSkewY);
    }
    withScale(scaleX, scaleY) {
        return MatrixHelper.withScale(this, scaleX, scaleY);
    }
    reset() {
        MatrixHelper.reset(this);
    }
}

const tempMatrix = new Matrix;

const TwoPointBoundsHelper = {
    tempPointBounds: {},
    setPoint(t, minX, minY) {
        t.minX = t.maxX = minX;
        t.minY = t.maxY = minY;
    },
    addPoint(t, x, y) {
        t.minX = x < t.minX ? x : t.minX;
        t.minY = y < t.minY ? y : t.minY;
        t.maxX = x > t.maxX ? x : t.maxX;
        t.maxY = y > t.maxY ? y : t.maxY;
    },
    addBounds(t, x, y, width, height) {
        addPoint$3(t, x, y);
        addPoint$3(t, x + width, y + height);
    },
    copy(t, pb) {
        t.minX = pb.minX;
        t.minY = pb.minY;
        t.maxX = pb.maxX;
        t.maxY = pb.maxY;
    },
    addPointBounds(t, pb) {
        t.minX = pb.minX < t.minX ? pb.minX : t.minX;
        t.minY = pb.minY < t.minY ? pb.minY : t.minY;
        t.maxX = pb.maxX > t.maxX ? pb.maxX : t.maxX;
        t.maxY = pb.maxY > t.maxY ? pb.maxY : t.maxY;
    },
    toBounds(t, setBounds) {
        setBounds.x = t.minX;
        setBounds.y = t.minY;
        setBounds.width = t.maxX - t.minX;
        setBounds.height = t.maxY - t.minY;
    }
};

const {addPoint: addPoint$3} = TwoPointBoundsHelper;

exports.Direction4 = void 0;

(function(Direction4) {
    Direction4[Direction4["top"] = 0] = "top";
    Direction4[Direction4["right"] = 1] = "right";
    Direction4[Direction4["bottom"] = 2] = "bottom";
    Direction4[Direction4["left"] = 3] = "left";
})(exports.Direction4 || (exports.Direction4 = {}));

exports.Direction9 = void 0;

(function(Direction9) {
    Direction9[Direction9["topLeft"] = 0] = "topLeft";
    Direction9[Direction9["top"] = 1] = "top";
    Direction9[Direction9["topRight"] = 2] = "topRight";
    Direction9[Direction9["right"] = 3] = "right";
    Direction9[Direction9["bottomRight"] = 4] = "bottomRight";
    Direction9[Direction9["bottom"] = 5] = "bottom";
    Direction9[Direction9["bottomLeft"] = 6] = "bottomLeft";
    Direction9[Direction9["left"] = 7] = "left";
    Direction9[Direction9["center"] = 8] = "center";
    Direction9[Direction9["top-left"] = 0] = "top-left";
    Direction9[Direction9["top-right"] = 2] = "top-right";
    Direction9[Direction9["bottom-right"] = 4] = "bottom-right";
    Direction9[Direction9["bottom-left"] = 6] = "bottom-left";
})(exports.Direction9 || (exports.Direction9 = {}));

const directionData = [ {
    x: 0,
    y: 0
}, {
    x: .5,
    y: 0
}, {
    x: 1,
    y: 0
}, {
    x: 1,
    y: .5
}, {
    x: 1,
    y: 1
}, {
    x: .5,
    y: 1
}, {
    x: 0,
    y: 1
}, {
    x: 0,
    y: .5
}, {
    x: .5,
    y: .5
} ];

directionData.forEach(item => item.type = "percent");

const AroundHelper = {
    directionData: directionData,
    tempPoint: {},
    get: get,
    toPoint(around, box, to, onlyBoxSize, content, onlyContentSize) {
        const point = get(around);
        to.x = point.x;
        to.y = point.y;
        if (point.type === "percent") {
            to.x *= box.width;
            to.y *= box.height;
            if (content) {
                if (!onlyContentSize) to.x -= content.x, to.y -= content.y;
                if (point.x) to.x -= point.x === 1 ? content.width : point.x === .5 ? point.x * content.width : 0;
                if (point.y) to.y -= point.y === 1 ? content.height : point.y === .5 ? point.y * content.height : 0;
            }
        }
        if (!onlyBoxSize) to.x += box.x, to.y += box.y;
    },
    getPoint(around, box, to) {
        if (!to) to = {};
        AroundHelper.toPoint(around, box, to, true);
        return to;
    }
};

function get(around) {
    return isString(around) ? directionData[exports.Direction9[around]] : around;
}

const {toPoint: toPoint$2} = AroundHelper;

const AlignHelper = {
    toPoint(align, content, box, to, onlyBoxSize, onlyContentSize) {
        toPoint$2(align, box, to, onlyBoxSize, content, onlyContentSize);
    }
};

const {tempPointBounds: tempPointBounds$1, setPoint: setPoint$2, addPoint: addPoint$2, toBounds: toBounds$2} = TwoPointBoundsHelper;

const {toOuterPoint: toOuterPoint$2} = MatrixHelper;

const {float: float, fourNumber: fourNumber} = MathHelper;

const {floor: floor$1, ceil: ceil$1} = Math;

let right, bottom, boundsRight, boundsBottom;

const point = {};

const toPoint$1 = {};

const tempBounds$1 = {};

const BoundsHelper = {
    tempBounds: tempBounds$1,
    set(t, x = 0, y = 0, width = 0, height = 0) {
        t.x = x;
        t.y = y;
        t.width = width;
        t.height = height;
    },
    copy(t, bounds) {
        t.x = bounds.x;
        t.y = bounds.y;
        t.width = bounds.width;
        t.height = bounds.height;
    },
    copyAndSpread(t, bounds, spread, isShrink, side) {
        const {x: x, y: y, width: width, height: height} = bounds;
        if (isArray(spread)) {
            const four = fourNumber(spread);
            isShrink ? B.set(t, x + four[3], y + four[0], width - four[1] - four[3], height - four[2] - four[0]) : B.set(t, x - four[3], y - four[0], width + four[1] + four[3], height + four[2] + four[0]);
        } else {
            if (isShrink) spread = -spread;
            B.set(t, x - spread, y - spread, width + spread * 2, height + spread * 2);
        }
        if (side) {
            if (side === "width") t.y = y, t.height = height; else t.x = x, t.width = width;
        }
    },
    minX(t) {
        return t.width > 0 ? t.x : t.x + t.width;
    },
    minY(t) {
        return t.height > 0 ? t.y : t.y + t.height;
    },
    maxX(t) {
        return t.width > 0 ? t.x + t.width : t.x;
    },
    maxY(t) {
        return t.height > 0 ? t.y + t.height : t.y;
    },
    move(t, x, y) {
        t.x += x;
        t.y += y;
    },
    scroll(t, data) {
        t.x += data.scrollX;
        t.y += data.scrollY;
    },
    getByMove(t, x, y) {
        t = Object.assign({}, t);
        B.move(t, x, y);
        return t;
    },
    toOffsetOutBounds(t, to, offsetBounds) {
        if (!to) to = t; else copy$6(to, t);
        if (!offsetBounds) offsetBounds = t;
        to.offsetX = B.maxX(offsetBounds);
        to.offsetY = B.maxY(offsetBounds);
        B.move(to, -to.offsetX, -to.offsetY);
    },
    scale(t, scaleX, scaleY = scaleX, onlySize) {
        onlySize || PointHelper.scale(t, scaleX, scaleY);
        t.width *= scaleX;
        t.height *= scaleY;
    },
    scaleOf(t, origin, scaleX, scaleY = scaleX) {
        PointHelper.scaleOf(t, origin, scaleX, scaleY);
        t.width *= scaleX;
        t.height *= scaleY;
    },
    tempToOuterOf(t, matrix) {
        B.copy(tempBounds$1, t);
        B.toOuterOf(tempBounds$1, matrix);
        return tempBounds$1;
    },
    getOuterOf(t, matrix) {
        t = Object.assign({}, t);
        B.toOuterOf(t, matrix);
        return t;
    },
    toOuterOf(t, matrix, to) {
        to || (to = t);
        if (matrix.b === 0 && matrix.c === 0) {
            const {a: a, d: d, e: e, f: f} = matrix;
            if (a > 0) {
                to.width = t.width * a;
                to.x = e + t.x * a;
            } else {
                to.width = t.width * -a;
                to.x = e + t.x * a - to.width;
            }
            if (d > 0) {
                to.height = t.height * d;
                to.y = f + t.y * d;
            } else {
                to.height = t.height * -d;
                to.y = f + t.y * d - to.height;
            }
        } else {
            point.x = t.x;
            point.y = t.y;
            toOuterPoint$2(matrix, point, toPoint$1);
            setPoint$2(tempPointBounds$1, toPoint$1.x, toPoint$1.y);
            point.x = t.x + t.width;
            toOuterPoint$2(matrix, point, toPoint$1);
            addPoint$2(tempPointBounds$1, toPoint$1.x, toPoint$1.y);
            point.y = t.y + t.height;
            toOuterPoint$2(matrix, point, toPoint$1);
            addPoint$2(tempPointBounds$1, toPoint$1.x, toPoint$1.y);
            point.x = t.x;
            toOuterPoint$2(matrix, point, toPoint$1);
            addPoint$2(tempPointBounds$1, toPoint$1.x, toPoint$1.y);
            toBounds$2(tempPointBounds$1, to);
        }
    },
    toInnerOf(t, matrix, to) {
        to || (to = t);
        B.move(to, -matrix.e, -matrix.f);
        B.scale(to, 1 / matrix.a, 1 / matrix.d);
    },
    getFitMatrix(t, put, baseScale = 1) {
        const scale = Math.min(baseScale, B.getFitScale(t, put));
        return new Matrix(scale, 0, 0, scale, -put.x * scale, -put.y * scale);
    },
    getFitScale(t, put, isCoverMode) {
        const sw = t.width / put.width, sh = t.height / put.height;
        return isCoverMode ? Math.max(sw, sh) : Math.min(sw, sh);
    },
    put(t, put, align = "center", putScale = 1, changeSize = true, to) {
        to || (to = put);
        if (isString(putScale)) putScale = B.getFitScale(t, put, putScale === "cover");
        tempBounds$1.width = changeSize ? put.width *= putScale : put.width * putScale;
        tempBounds$1.height = changeSize ? put.height *= putScale : put.height * putScale;
        AlignHelper.toPoint(align, tempBounds$1, t, to, true, true);
    },
    getSpread(t, spread, side) {
        const n = {};
        B.copyAndSpread(n, t, spread, false, side);
        return n;
    },
    spread(t, spread, side) {
        B.copyAndSpread(t, t, spread, false, side);
    },
    shrink(t, shrink, side) {
        B.copyAndSpread(t, t, shrink, true, side);
    },
    ceil(t) {
        const {x: x, y: y} = t;
        t.x = floor$1(t.x);
        t.y = floor$1(t.y);
        t.width = x > t.x ? ceil$1(t.width + x - t.x) : ceil$1(t.width);
        t.height = y > t.y ? ceil$1(t.height + y - t.y) : ceil$1(t.height);
    },
    unsign(t) {
        if (t.width < 0) {
            t.x += t.width;
            t.width = -t.width;
        }
        if (t.height < 0) {
            t.y += t.height;
            t.height = -t.height;
        }
    },
    float(t, maxLength) {
        t.x = float(t.x, maxLength);
        t.y = float(t.y, maxLength);
        t.width = float(t.width, maxLength);
        t.height = float(t.height, maxLength);
    },
    add(t, bounds, isPoint) {
        right = t.x + t.width;
        bottom = t.y + t.height;
        boundsRight = bounds.x;
        boundsBottom = bounds.y;
        if (!isPoint) {
            boundsRight += bounds.width;
            boundsBottom += bounds.height;
        }
        right = right > boundsRight ? right : boundsRight;
        bottom = bottom > boundsBottom ? bottom : boundsBottom;
        t.x = t.x < bounds.x ? t.x : bounds.x;
        t.y = t.y < bounds.y ? t.y : bounds.y;
        t.width = right - t.x;
        t.height = bottom - t.y;
    },
    addList(t, list) {
        B.setListWithFn(t, list, undefined, true);
    },
    setList(t, list, addMode = false) {
        B.setListWithFn(t, list, undefined, addMode);
    },
    addListWithFn(t, list, boundsDataFn) {
        B.setListWithFn(t, list, boundsDataFn, true);
    },
    setListWithFn(t, list, boundsDataFn, addMode = false) {
        let bounds, first = true;
        for (let i = 0, len = list.length; i < len; i++) {
            bounds = boundsDataFn ? boundsDataFn(list[i], i) : list[i];
            if (bounds && (bounds.width || bounds.height)) {
                if (first) {
                    first = false;
                    if (!addMode) copy$6(t, bounds);
                } else {
                    add(t, bounds);
                }
            }
        }
        if (first) B.reset(t);
    },
    setPoints(t, points) {
        points.forEach((point, index) => index === 0 ? setPoint$2(tempPointBounds$1, point.x, point.y) : addPoint$2(tempPointBounds$1, point.x, point.y));
        toBounds$2(tempPointBounds$1, t);
    },
    setPoint(t, point) {
        B.set(t, point.x, point.y);
    },
    addPoint(t, point) {
        add(t, point, true);
    },
    getPoints(t) {
        const {x: x, y: y, width: width, height: height} = t;
        return [ {
            x: x,
            y: y
        }, {
            x: x + width,
            y: y
        }, {
            x: x + width,
            y: y + height
        }, {
            x: x,
            y: y + height
        } ];
    },
    hitRadiusPoint(t, point, pointMatrix) {
        if (pointMatrix) point = PointHelper.tempToInnerRadiusPointOf(point, pointMatrix);
        return point.x >= t.x - point.radiusX && point.x <= t.x + t.width + point.radiusX && (point.y >= t.y - point.radiusY && point.y <= t.y + t.height + point.radiusY);
    },
    hitPoint(t, point, pointMatrix) {
        if (pointMatrix) point = PointHelper.tempToInnerOf(point, pointMatrix);
        return point.x >= t.x && point.x <= t.x + t.width && (point.y >= t.y && point.y <= t.y + t.height);
    },
    hit(t, other, otherMatrix) {
        if (otherMatrix) other = B.tempToOuterOf(other, otherMatrix);
        return !(t.y + t.height < other.y || other.y + other.height < t.y || t.x + t.width < other.x || other.x + other.width < t.x);
    },
    includes(t, other, otherMatrix) {
        if (otherMatrix) other = B.tempToOuterOf(other, otherMatrix);
        return t.x <= other.x && t.y <= other.y && t.x + t.width >= other.x + other.width && t.y + t.height >= other.y + other.height;
    },
    getIntersectData(t, other, otherMatrix) {
        if (otherMatrix) other = B.tempToOuterOf(other, otherMatrix);
        if (!B.hit(t, other)) return getBoundsData();
        let {x: x, y: y, width: width, height: height} = other;
        right = x + width;
        bottom = y + height;
        boundsRight = t.x + t.width;
        boundsBottom = t.y + t.height;
        x = x > t.x ? x : t.x;
        y = y > t.y ? y : t.y;
        right = right < boundsRight ? right : boundsRight;
        bottom = bottom < boundsBottom ? bottom : boundsBottom;
        width = right - x;
        height = bottom - y;
        return {
            x: x,
            y: y,
            width: width,
            height: height
        };
    },
    intersect(t, other, otherMatrix) {
        B.copy(t, B.getIntersectData(t, other, otherMatrix));
    },
    isSame(t, bounds) {
        return t.x === bounds.x && t.y === bounds.y && t.width === bounds.width && t.height === bounds.height;
    },
    isEmpty(t) {
        return t.x === 0 && t.y === 0 && t.width === 0 && t.height === 0;
    },
    hasSize(t) {
        return t.width && t.height;
    },
    reset(t) {
        B.set(t);
    }
};

const B = BoundsHelper;

const {add: add, copy: copy$6} = B;

class Bounds {
    get minX() {
        return BoundsHelper.minX(this);
    }
    get minY() {
        return BoundsHelper.minY(this);
    }
    get maxX() {
        return BoundsHelper.maxX(this);
    }
    get maxY() {
        return BoundsHelper.maxY(this);
    }
    constructor(x, y, width, height) {
        this.set(x, y, width, height);
    }
    set(x, y, width, height) {
        isObject(x) ? BoundsHelper.copy(this, x) : BoundsHelper.set(this, x, y, width, height);
        return this;
    }
    get() {
        const {x: x, y: y, width: width, height: height} = this;
        return {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
    clone() {
        return new Bounds(this);
    }
    move(x, y) {
        BoundsHelper.move(this, x, y);
        return this;
    }
    scale(scaleX, scaleY, onlySize) {
        BoundsHelper.scale(this, scaleX, scaleY, onlySize);
        return this;
    }
    scaleOf(origin, scaleX, scaleY) {
        BoundsHelper.scaleOf(this, origin, scaleX, scaleY);
        return this;
    }
    toOuterOf(matrix, to) {
        BoundsHelper.toOuterOf(this, matrix, to);
        return this;
    }
    toInnerOf(matrix, to) {
        BoundsHelper.toInnerOf(this, matrix, to);
        return this;
    }
    getFitMatrix(put, baseScale) {
        return BoundsHelper.getFitMatrix(this, put, baseScale);
    }
    put(put, align, putScale) {
        BoundsHelper.put(this, put, align, putScale);
    }
    spread(fourNumber, side) {
        BoundsHelper.spread(this, fourNumber, side);
        return this;
    }
    shrink(fourNumber, side) {
        BoundsHelper.shrink(this, fourNumber, side);
        return this;
    }
    ceil() {
        BoundsHelper.ceil(this);
        return this;
    }
    unsign() {
        BoundsHelper.unsign(this);
        return this;
    }
    float(maxLength) {
        BoundsHelper.float(this, maxLength);
        return this;
    }
    add(bounds) {
        BoundsHelper.add(this, bounds);
        return this;
    }
    addList(boundsList) {
        BoundsHelper.setList(this, boundsList, true);
        return this;
    }
    setList(boundsList) {
        BoundsHelper.setList(this, boundsList);
        return this;
    }
    addListWithFn(list, boundsDataFn) {
        BoundsHelper.setListWithFn(this, list, boundsDataFn, true);
        return this;
    }
    setListWithFn(list, boundsDataFn) {
        BoundsHelper.setListWithFn(this, list, boundsDataFn);
        return this;
    }
    setPoint(point) {
        BoundsHelper.setPoint(this, point);
        return this;
    }
    setPoints(points) {
        BoundsHelper.setPoints(this, points);
        return this;
    }
    addPoint(point) {
        BoundsHelper.addPoint(this, point);
        return this;
    }
    getPoints() {
        return BoundsHelper.getPoints(this);
    }
    hitPoint(point, pointMatrix) {
        return BoundsHelper.hitPoint(this, point, pointMatrix);
    }
    hitRadiusPoint(point, pointMatrix) {
        return BoundsHelper.hitRadiusPoint(this, point, pointMatrix);
    }
    hit(bounds, boundsMatrix) {
        return BoundsHelper.hit(this, bounds, boundsMatrix);
    }
    includes(bounds, boundsMatrix) {
        return BoundsHelper.includes(this, bounds, boundsMatrix);
    }
    intersect(bounds, boundsMatrix) {
        BoundsHelper.intersect(this, bounds, boundsMatrix);
        return this;
    }
    getIntersect(bounds, boundsMatrix) {
        return new Bounds(BoundsHelper.getIntersectData(this, bounds, boundsMatrix));
    }
    isSame(bounds) {
        return BoundsHelper.isSame(this, bounds);
    }
    isEmpty() {
        return BoundsHelper.isEmpty(this);
    }
    reset() {
        BoundsHelper.reset(this);
    }
}

const tempBounds = new Bounds;

class AutoBounds {
    constructor(top, right, bottom, left, width, height) {
        isObject(top) ? this.copy(top) : this.set(top, right, bottom, left, width, height);
    }
    set(top = 0, right = 0, bottom = 0, left = 0, width = 0, height = 0) {
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
        this.width = width;
        this.height = height;
    }
    copy(autoSize) {
        const {top: top, right: right, bottom: bottom, left: left, width: width, height: height} = autoSize;
        this.set(top, right, bottom, left, width, height);
    }
    getBoundsFrom(parent) {
        const {top: top, right: right, bottom: bottom, left: left, width: width, height: height} = this;
        return new Bounds(left, top, width ? width : parent.width - left - right, height ? height : parent.height - top - bottom);
    }
}

const UnitConvertHelper = {
    number(value, percentRefer) {
        return isObject(value) ? value.type === "percent" ? value.value * percentRefer : value.value : value;
    }
};

const StringNumberMap = {
    0: 1,
    1: 1,
    2: 1,
    3: 1,
    4: 1,
    5: 1,
    6: 1,
    7: 1,
    8: 1,
    9: 1,
    ".": 1,
    e: 1,
    E: 1
};

const {floor: floor, max: max} = Math;

const Platform = {
    toURL(text, fileType) {
        let url = encodeURIComponent(text);
        if (fileType === "text") url = "data:text/plain;charset=utf-8," + url; else if (fileType === "svg") url = "data:image/svg+xml," + url;
        return url;
    },
    image: {
        hitCanvasSize: 100,
        maxCacheSize: 2560 * 1600,
        maxPatternSize: 4096 * 2160,
        crossOrigin: "anonymous",
        isLarge(size, scaleX, scaleY, largeSize) {
            return size.width * size.height * (scaleX ? scaleX * scaleY : 1) > (largeSize || image.maxCacheSize);
        },
        isSuperLarge(size, scaleX, scaleY) {
            return image.isLarge(size, scaleX, scaleY, image.maxPatternSize);
        },
        getRealURL(url) {
            const {prefix: prefix, suffix: suffix} = image;
            if (suffix && !url.startsWith("data:") && !url.startsWith("blob:")) url += (url.includes("?") ? "&" : "?") + suffix;
            if (prefix && url[0] === "/") url = prefix + url;
            return url;
        },
        resize(view, width, height, xGap, yGap, clip, smooth, opacity, _filters, interlace) {
            const realWidth = max(floor(width + (xGap || 0)), 1), realHeight = max(floor(height + (yGap || 0)), 1);
            let interlaceX, interlaceY, interlaceOffset;
            if (interlace && (interlaceOffset = UnitConvertHelper.number(interlace.offset, (interlaceX = interlace.type === "x") ? width : height))) interlaceX || (interlaceY = true);
            const canvas = Platform.origin.createCanvas(interlaceY ? realWidth * 2 : realWidth, interlaceX ? realHeight * 2 : realHeight);
            const ctx = canvas.getContext("2d");
            if (opacity) ctx.globalAlpha = opacity;
            ctx.imageSmoothingEnabled = smooth === false ? false : true;
            if (image.canUse(view)) {
                if (clip) {
                    const scaleX = width / clip.width, scaleY = height / clip.height;
                    ctx.setTransform(scaleX, 0, 0, scaleY, -clip.x * scaleX, -clip.y * scaleY);
                    ctx.drawImage(view, 0, 0, view.width, view.height);
                } else ctx.drawImage(view, 0, 0, width, height);
                if (interlaceOffset) {
                    ctx.drawImage(canvas, 0, 0, realWidth, realHeight, interlaceX ? interlaceOffset - realWidth : realWidth, interlaceX ? realHeight : interlaceOffset - realHeight, realWidth, realHeight);
                    ctx.drawImage(canvas, 0, 0, realWidth, realHeight, interlaceX ? interlaceOffset : realWidth, interlaceX ? realHeight : interlaceOffset, realWidth, realHeight);
                }
            }
            return canvas;
        },
        canUse(view) {
            return view && view.width && !view.__closed;
        },
        setPatternTransform(pattern, transform, paint) {
            try {
                if (transform && pattern.setTransform) {
                    pattern.setTransform(transform);
                    transform = undefined;
                }
            } catch (_a) {}
            if (paint) DataHelper.stintSet(paint, "transform", transform);
        }
    }
};

const {image: image} = Platform;

const {randColor: randColor} = MathHelper;

class Debug {
    constructor(name) {
        this.repeatMap = {};
        this.name = name;
    }
    static get(name) {
        return new Debug(name);
    }
    static set filter(name) {
        this.filterList = getNameList(name);
    }
    static set exclude(name) {
        this.excludeList = getNameList(name);
    }
    static drawRepaint(canvas, bounds) {
        const color = randColor();
        canvas.fillWorld(bounds, color.replace("1)", ".1)"));
        canvas.strokeWorld(bounds, color);
    }
    static drawBounds(leaf, canvas, _options) {
        const showHit = Debug.showBounds === "hit", w = leaf.__nowWorld, color = randColor();
        if (showHit) canvas.setWorld(w), leaf.__drawHitPath(canvas), canvas.fillStyle = color.replace("1)", ".2)"), 
        canvas.fill();
        canvas.resetTransform();
        canvas.setStroke(color, 2);
        showHit ? canvas.stroke() : canvas.strokeWorld(w, color);
    }
    log(...messages) {
        if (D$4.enable) {
            if (D$4.filterList.length && D$4.filterList.every(name => name !== this.name)) return;
            if (D$4.excludeList.length && D$4.excludeList.some(name => name === this.name)) return;
            console.log("%c" + this.name, "color:#21ae62", ...messages);
        }
    }
    tip(...messages) {
        if (D$4.enable) this.warn(...messages);
    }
    warn(...messages) {
        if (D$4.showWarn) console.warn(this.name, ...messages);
    }
    repeat(name, ...messages) {
        if (!this.repeatMap[name]) {
            this.warn("repeat:" + name, ...messages);
            this.repeatMap[name] = true;
        }
    }
    error(...messages) {
        try {
            throw new Error;
        } catch (e) {
            console.error(this.name, ...messages, e);
        }
    }
}

Debug.filterList = [];

Debug.excludeList = [];

Debug.showWarn = true;

function getNameList(name) {
    if (!name) name = []; else if (isString(name)) name = [ name ];
    return name;
}

const D$4 = Debug;

const debug$a = Debug.get("RunTime");

const Run = {
    currentId: 0,
    currentName: "",
    idMap: {},
    nameMap: {},
    nameToIdMap: {},
    start(name, microsecond) {
        const id = IncrementId.create(IncrementId.RUNTIME);
        R$1.currentId = R$1.idMap[id] = microsecond ? performance.now() : Date.now();
        R$1.currentName = R$1.nameMap[id] = name;
        R$1.nameToIdMap[name] = id;
        return id;
    },
    end(id, microsecond) {
        const time = R$1.idMap[id], name = R$1.nameMap[id];
        const duration = microsecond ? (performance.now() - time) / 1e3 : Date.now() - time;
        R$1.idMap[id] = R$1.nameMap[id] = R$1.nameToIdMap[name] = undefined;
        debug$a.log(name, duration, "ms");
    },
    endOfName(name, microsecond) {
        const id = R$1.nameToIdMap[name];
        if (!isUndefined(id)) R$1.end(id, microsecond);
    }
};

const R$1 = Run;

const check = [];

const Plugin = {
    list: {},
    add(name, ...needPlugins) {
        this.list[name] = true;
        check.push(...needPlugins);
    },
    has(name, tip) {
        const rs = this.list[name];
        if (!rs && tip) this.need(name);
        return rs;
    },
    need(name) {
        console.error("please install and import plugin: " + (name.includes("-x") ? "" : "@leafer-in/") + name);
    }
};

setTimeout(() => check.forEach(name => Plugin.has(name, true)));

const Creator = {
    editor(_options) {
        return Plugin.need("editor");
    }
};

const debug$9 = Debug.get("UICreator");

const UICreator = {
    list: {},
    register(UI) {
        const {__tag: tag} = UI.prototype;
        if (list$1[tag]) debug$9.repeat(tag);
        list$1[tag] = UI;
    },
    get(tag, data, x, y, width, height) {
        if (!list$1[tag]) debug$9.error("not register " + tag);
        const ui = new list$1[tag](data);
        if (!isUndefined(x)) {
            ui.x = x;
            if (y) ui.y = y;
            if (width) ui.width = width;
            if (height) ui.height = height;
        }
        return ui;
    }
};

const {list: list$1} = UICreator;

const debug$8 = Debug.get("EventCreator");

const EventCreator = {
    nameList: {},
    register(Event) {
        let name;
        Object.keys(Event).forEach(key => {
            name = Event[key];
            if (isString(name)) nameList[name] && debug$8.repeat(name), nameList[name] = Event;
        });
    },
    changeName(oldName, newName) {
        const Event = nameList[oldName];
        if (Event) {
            const constName = Object.keys(Event).find(key => Event[key] === oldName);
            if (constName) {
                Event[constName] = newName;
                nameList[newName] = Event;
            }
        }
    },
    has(type) {
        return !!this.nameList[type];
    },
    get(type, ...params) {
        return new nameList[type](...params);
    }
};

const {nameList: nameList} = EventCreator;

class CanvasManager {
    constructor() {
        this.list = [];
    }
    add(canvas) {
        canvas.manager = this;
        this.list.push(canvas);
    }
    get(size) {
        let old;
        const {list: list} = this;
        for (let i = 0, len = list.length; i < len; i++) {
            old = list[i];
            if (old.recycled && old.isSameSize(size)) {
                old.recycled = false;
                old.manager || (old.manager = this);
                return old;
            }
        }
        const canvas = Creator.canvas(size);
        this.add(canvas);
        return canvas;
    }
    recycle(old) {
        old.recycled = true;
    }
    clearRecycled() {
        let canvas;
        const filter = [];
        for (let i = 0, len = this.list.length; i < len; i++) {
            canvas = this.list[i];
            canvas.recycled ? canvas.destroy() : filter.push(canvas);
        }
        this.list = filter;
    }
    clear() {
        this.list.forEach(item => {
            item.destroy();
        });
        this.list.length = 0;
    }
    destroy() {
        this.clear();
    }
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function contextAttr(realName) {
    return (target, key) => {
        if (!realName) realName = key;
        const property = {
            get() {
                return this.context[realName];
            },
            set(value) {
                this.context[realName] = value;
            }
        };
        if (key === "strokeCap") property.set = function(value) {
            this.context[realName] = value === "none" ? "butt" : value;
        };
        Object.defineProperty(target, key, property);
    };
}

const contextMethodNameList = [];

function contextMethod() {
    return (_target, key) => {
        contextMethodNameList.push(key);
    };
}

const emptyArray = [];

class Canvas {
    set blendMode(value) {
        if (value === "normal") value = "source-over";
        this.context.globalCompositeOperation = value;
    }
    get blendMode() {
        return this.context.globalCompositeOperation;
    }
    set dashPattern(value) {
        this.context.setLineDash(value || emptyArray);
    }
    get dashPattern() {
        return this.context.getLineDash();
    }
    __bindContext() {
        let method;
        contextMethodNameList.forEach(name => {
            method = this.context[name];
            if (method) this[name] = method.bind(this.context);
        });
        this.textBaseline = "alphabetic";
    }
    setTransform(_a, _b, _c, _d, _e, _f) {}
    resetTransform() {}
    getTransform() {
        return void 0;
    }
    save() {}
    restore() {}
    transform(a, b, c, d, e, f) {
        if (isObject(a)) {
            this.context.transform(a.a, a.b, a.c, a.d, a.e, a.f);
        } else {
            this.context.transform(a, b, c, d, e, f);
        }
    }
    translate(_x, _y) {}
    scale(_x, _y) {}
    rotate(_angle) {}
    fill(_path2d, _rule) {}
    stroke(_path2d) {}
    clip(_path2d, _rule) {}
    fillRect(_x, _y, _width, _height) {}
    strokeRect(_x, _y, _width, _height) {}
    clearRect(_x, _y, _width, _height) {}
    drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
        switch (arguments.length) {
          case 9:
            if (sx < 0) {
                const d = -sx / sw * dw;
                sw += sx;
                sx = 0;
                dx += d;
                dw -= d;
            }
            if (sy < 0) {
                const d = -sy / sh * dh;
                sh += sy;
                sy = 0;
                dy += d;
                dh -= d;
            }
            this.context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
            break;

          case 5:
            this.context.drawImage(image, sx, sy, sw, sh);
            break;

          case 3:
            this.context.drawImage(image, sx, sy);
        }
    }
    beginPath() {}
    moveTo(_x, _y) {}
    lineTo(_x, _y) {}
    bezierCurveTo(_cp1x, _cp1y, _cp2x, _cp2y, _x, _y) {}
    quadraticCurveTo(_cpx, _cpy, _x, _y) {}
    closePath() {}
    arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {}
    arcTo(_x1, _y1, _x2, _y2, _radius) {}
    ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {}
    rect(_x, _y, _width, _height) {}
    roundRect(_x, _y, _width, _height, _radius) {}
    createConicGradient(_startAngle, _x, _y) {
        return void 0;
    }
    createLinearGradient(_x0, _y0, _x1, _y1) {
        return void 0;
    }
    createPattern(_image, _repetition) {
        return void 0;
    }
    createRadialGradient(_x0, _y0, _r0, _x1, _y1, _r1) {
        return void 0;
    }
    fillText(_text, _x, _y, _maxWidth) {}
    measureText(_text) {
        return void 0;
    }
    strokeText(_text, _x, _y, _maxWidth) {}
    destroy() {
        this.context = null;
    }
}

__decorate([ contextAttr("imageSmoothingEnabled") ], Canvas.prototype, "smooth", void 0);

__decorate([ contextAttr("imageSmoothingQuality") ], Canvas.prototype, "smoothLevel", void 0);

__decorate([ contextAttr("globalAlpha") ], Canvas.prototype, "opacity", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "fillStyle", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "strokeStyle", void 0);

__decorate([ contextAttr("lineWidth") ], Canvas.prototype, "strokeWidth", void 0);

__decorate([ contextAttr("lineCap") ], Canvas.prototype, "strokeCap", void 0);

__decorate([ contextAttr("lineJoin") ], Canvas.prototype, "strokeJoin", void 0);

__decorate([ contextAttr("lineDashOffset") ], Canvas.prototype, "dashOffset", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "miterLimit", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "shadowBlur", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "shadowColor", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "shadowOffsetX", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "shadowOffsetY", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "filter", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "font", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "fontKerning", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "fontStretch", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "fontVariantCaps", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "textAlign", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "textBaseline", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "textRendering", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "wordSpacing", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "letterSpacing", void 0);

__decorate([ contextAttr() ], Canvas.prototype, "direction", void 0);

__decorate([ contextMethod() ], Canvas.prototype, "setTransform", null);

__decorate([ contextMethod() ], Canvas.prototype, "resetTransform", null);

__decorate([ contextMethod() ], Canvas.prototype, "getTransform", null);

__decorate([ contextMethod() ], Canvas.prototype, "save", null);

__decorate([ contextMethod() ], Canvas.prototype, "restore", null);

__decorate([ contextMethod() ], Canvas.prototype, "translate", null);

__decorate([ contextMethod() ], Canvas.prototype, "scale", null);

__decorate([ contextMethod() ], Canvas.prototype, "rotate", null);

__decorate([ contextMethod() ], Canvas.prototype, "fill", null);

__decorate([ contextMethod() ], Canvas.prototype, "stroke", null);

__decorate([ contextMethod() ], Canvas.prototype, "clip", null);

__decorate([ contextMethod() ], Canvas.prototype, "fillRect", null);

__decorate([ contextMethod() ], Canvas.prototype, "strokeRect", null);

__decorate([ contextMethod() ], Canvas.prototype, "clearRect", null);

__decorate([ contextMethod() ], Canvas.prototype, "beginPath", null);

__decorate([ contextMethod() ], Canvas.prototype, "moveTo", null);

__decorate([ contextMethod() ], Canvas.prototype, "lineTo", null);

__decorate([ contextMethod() ], Canvas.prototype, "bezierCurveTo", null);

__decorate([ contextMethod() ], Canvas.prototype, "quadraticCurveTo", null);

__decorate([ contextMethod() ], Canvas.prototype, "closePath", null);

__decorate([ contextMethod() ], Canvas.prototype, "arc", null);

__decorate([ contextMethod() ], Canvas.prototype, "arcTo", null);

__decorate([ contextMethod() ], Canvas.prototype, "ellipse", null);

__decorate([ contextMethod() ], Canvas.prototype, "rect", null);

__decorate([ contextMethod() ], Canvas.prototype, "roundRect", null);

__decorate([ contextMethod() ], Canvas.prototype, "createConicGradient", null);

__decorate([ contextMethod() ], Canvas.prototype, "createLinearGradient", null);

__decorate([ contextMethod() ], Canvas.prototype, "createPattern", null);

__decorate([ contextMethod() ], Canvas.prototype, "createRadialGradient", null);

__decorate([ contextMethod() ], Canvas.prototype, "fillText", null);

__decorate([ contextMethod() ], Canvas.prototype, "measureText", null);

__decorate([ contextMethod() ], Canvas.prototype, "strokeText", null);

const {copy: copy$5, multiplyParent: multiplyParent$3, pixelScale: pixelScale} = MatrixHelper, {round: round$1} = Math, tempPixelBounds = new Bounds, tempPixelBounds2 = new Bounds;

const minSize = {
    width: 1,
    height: 1,
    pixelRatio: 1
};

const canvasSizeAttrs = [ "width", "height", "pixelRatio" ];

class LeaferCanvasBase extends Canvas {
    get width() {
        return this.size.width;
    }
    get height() {
        return this.size.height;
    }
    get pixelRatio() {
        return this.size.pixelRatio;
    }
    get pixelWidth() {
        return this.width * this.pixelRatio || 0;
    }
    get pixelHeight() {
        return this.height * this.pixelRatio || 0;
    }
    get pixelSnap() {
        return this.config.pixelSnap;
    }
    set pixelSnap(value) {
        this.config.pixelSnap = value;
    }
    get allowBackgroundColor() {
        return this.view && this.parentView;
    }
    constructor(config, manager) {
        super();
        this.size = {};
        this.worldTransform = {};
        if (!config) config = minSize;
        this.manager = manager;
        this.innerId = IncrementId.create(IncrementId.CNAVAS);
        const {width: width, height: height, pixelRatio: pixelRatio} = config;
        this.autoLayout = !width || !height;
        this.size.pixelRatio = pixelRatio || Platform.devicePixelRatio;
        this.config = config;
        this.init();
    }
    init() {}
    __createContext() {
        const {view: view} = this;
        const {contextSettings: contextSettings} = this.config;
        this.context = contextSettings ? view.getContext("2d", contextSettings) : view.getContext("2d");
        this.__bindContext();
    }
    export(_filename, _options) {
        return undefined;
    }
    toBlob(_type, _quality) {
        return undefined;
    }
    toDataURL(_type, _quality) {
        return undefined;
    }
    saveAs(_filename, _quality) {
        return undefined;
    }
    resize(size, safeResize = true) {
        if (this.isSameSize(size)) return;
        let takeCanvas;
        if (this.context && !this.unreal && safeResize && this.width) {
            takeCanvas = this.getSameCanvas();
            takeCanvas.copyWorld(this);
        }
        const s = this.size;
        DataHelper.copyAttrs(s, size, canvasSizeAttrs);
        canvasSizeAttrs.forEach(key => s[key] || (s[key] = 1));
        this.bounds = new Bounds(0, 0, this.width, this.height);
        this.updateViewSize();
        this.updateClientBounds();
        if (this.context) {
            this.smooth = this.config.smooth;
            if (!this.unreal && takeCanvas) {
                this.clearWorld(takeCanvas.bounds);
                this.copyWorld(takeCanvas);
                takeCanvas.recycle();
            }
        }
    }
    updateViewSize() {}
    updateClientBounds() {}
    getClientBounds(update) {
        if (update) this.updateClientBounds();
        return this.clientBounds || this.bounds;
    }
    startAutoLayout(_autoBounds, _listener) {}
    stopAutoLayout() {}
    setCursor(_cursor) {}
    setWorld(matrix, parentMatrix) {
        const {pixelRatio: pixelRatio, pixelSnap: pixelSnap} = this, w = this.worldTransform;
        if (parentMatrix) multiplyParent$3(matrix, parentMatrix, w);
        pixelScale(matrix, pixelRatio, w);
        if (pixelSnap && !matrix.ignorePixelSnap) {
            if (matrix.half && matrix.half * pixelRatio % 2) w.e = round$1(w.e - .5) + .5, w.f = round$1(w.f - .5) + .5; else w.e = round$1(w.e), 
            w.f = round$1(w.f);
        }
        this.setTransform(w.a, w.b, w.c, w.d, w.e, w.f);
    }
    useWorldTransform(worldTransform) {
        if (worldTransform) this.worldTransform = worldTransform;
        const w = this.worldTransform;
        if (w) this.setTransform(w.a, w.b, w.c, w.d, w.e, w.f);
    }
    setStroke(color, strokeWidth, options, childOptions) {
        if (strokeWidth) this.strokeWidth = strokeWidth;
        if (color) this.strokeStyle = color;
        if (options) this.setStrokeOptions(options, childOptions);
    }
    setStrokeOptions(options, childOptions) {
        let {strokeCap: strokeCap, strokeJoin: strokeJoin, dashPattern: dashPattern, dashOffset: dashOffset, miterLimit: miterLimit} = options;
        if (childOptions) {
            if (childOptions.strokeCap) strokeCap = childOptions.strokeCap;
            if (childOptions.strokeJoin) strokeJoin = childOptions.strokeJoin;
            if (!isUndefined(childOptions.dashPattern)) dashPattern = childOptions.dashPattern;
            if (!isUndefined(childOptions.dashOffset)) dashOffset = childOptions.dashOffset;
            if (childOptions.miterLimit) miterLimit = childOptions.miterLimit;
        }
        this.strokeCap = strokeCap;
        this.strokeJoin = strokeJoin;
        this.dashPattern = dashPattern;
        this.dashOffset = dashOffset;
        this.miterLimit = miterLimit;
    }
    saveBlendMode(blendMode) {
        this.savedBlendMode = this.blendMode;
        this.blendMode = blendMode;
    }
    restoreBlendMode() {
        this.blendMode = this.savedBlendMode;
    }
    hitFill(_point, _fillRule) {
        return true;
    }
    hitStroke(_point, _strokeWidth) {
        return true;
    }
    hitPixel(_radiusPoint, _offset, _scale = 1) {
        return true;
    }
    setWorldShadow(x, y, blur, color) {
        const {pixelRatio: pixelRatio} = this;
        this.shadowOffsetX = x * pixelRatio;
        this.shadowOffsetY = y * pixelRatio;
        this.shadowBlur = blur * pixelRatio;
        this.shadowColor = color || "black";
    }
    setWorldBlur(blur) {
        const {pixelRatio: pixelRatio} = this;
        this.filter = `blur(${blur * pixelRatio}px)`;
    }
    copyWorld(canvas, from, to, blendMode, ceilPixel) {
        if (blendMode) this.blendMode = blendMode;
        if (from) {
            this.setTempPixelBounds(from, ceilPixel);
            if (!to) to = tempPixelBounds; else this.setTempPixelBounds2(to, ceilPixel), to = tempPixelBounds2;
            this.drawImage(canvas.view, tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height, to.x, to.y, to.width, to.height);
        } else {
            this.drawImage(canvas.view, 0, 0);
        }
        if (blendMode) this.blendMode = "source-over";
    }
    copyWorldToInner(canvas, fromWorld, toInnerBounds, blendMode, ceilPixel) {
        if (fromWorld.b || fromWorld.c) {
            this.save();
            this.resetTransform();
            this.copyWorld(canvas, fromWorld, BoundsHelper.tempToOuterOf(toInnerBounds, fromWorld), blendMode, ceilPixel);
            this.restore();
        } else {
            if (blendMode) this.blendMode = blendMode;
            this.setTempPixelBounds(fromWorld, ceilPixel);
            this.drawImage(canvas.view, tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height, toInnerBounds.x, toInnerBounds.y, toInnerBounds.width, toInnerBounds.height);
            if (blendMode) this.blendMode = "source-over";
        }
    }
    copyWorldByReset(canvas, from, to, blendMode, onlyResetTransform, ceilPixel) {
        this.resetTransform();
        this.copyWorld(canvas, from, to, blendMode, ceilPixel);
        if (!onlyResetTransform) this.useWorldTransform();
    }
    useGrayscaleAlpha(bounds) {
        this.setTempPixelBounds(bounds, true, true);
        let alpha, pixel;
        const {context: context} = this, imageData = context.getImageData(tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height), {data: data} = imageData;
        for (let i = 0, len = data.length; i < len; i += 4) {
            pixel = data[i] * .299 + data[i + 1] * .587 + data[i + 2] * .114;
            if (alpha = data[i + 3]) data[i + 3] = alpha === 255 ? pixel : alpha * (pixel / 255);
        }
        context.putImageData(imageData, tempPixelBounds.x, tempPixelBounds.y);
    }
    useMask(maskCanvas, fromBounds, toBounds) {
        this.copyWorld(maskCanvas, fromBounds, toBounds, "destination-in");
    }
    useEraser(eraserCanvas, fromBounds, toBounds) {
        this.copyWorld(eraserCanvas, fromBounds, toBounds, "destination-out");
    }
    fillWorld(bounds, color, blendMode, ceilPixel) {
        if (blendMode) this.blendMode = blendMode;
        this.fillStyle = color;
        this.setTempPixelBounds(bounds, ceilPixel);
        this.fillRect(tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height);
        if (blendMode) this.blendMode = "source-over";
    }
    strokeWorld(bounds, color, blendMode, ceilPixel) {
        if (blendMode) this.blendMode = blendMode;
        this.strokeStyle = color;
        this.setTempPixelBounds(bounds, ceilPixel);
        this.strokeRect(tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height);
        if (blendMode) this.blendMode = "source-over";
    }
    clipWorld(bounds, ceilPixel = true) {
        this.beginPath();
        this.setTempPixelBounds(bounds, ceilPixel);
        this.rect(tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height);
        this.clip();
    }
    clipUI(ruleData) {
        ruleData.windingRule ? this.clip(ruleData.windingRule) : this.clip();
    }
    clearWorld(bounds, ceilPixel = true) {
        this.setTempPixelBounds(bounds, ceilPixel);
        this.clearRect(tempPixelBounds.x, tempPixelBounds.y, tempPixelBounds.width, tempPixelBounds.height);
    }
    clear() {
        const {pixelRatio: pixelRatio} = this;
        this.clearRect(0, 0, this.width * pixelRatio + 2, this.height * pixelRatio + 2);
    }
    setTempPixelBounds(bounds, ceil, intersect) {
        this.copyToPixelBounds(tempPixelBounds, bounds, ceil, intersect);
    }
    setTempPixelBounds2(bounds, ceil, intersect) {
        this.copyToPixelBounds(tempPixelBounds2, bounds, ceil, intersect);
    }
    copyToPixelBounds(pixelBounds, bounds, ceil, intersect) {
        pixelBounds.set(bounds);
        if (intersect) pixelBounds.intersect(this.bounds);
        pixelBounds.scale(this.pixelRatio);
        if (ceil) pixelBounds.ceil();
    }
    isSameSize(size) {
        return this.width === size.width && this.height === size.height && (!size.pixelRatio || this.pixelRatio === size.pixelRatio);
    }
    getSameCanvas(useSameWorldTransform, useSameSmooth) {
        const {size: size, pixelSnap: pixelSnap} = this, canvas = this.manager ? this.manager.get(size) : Creator.canvas(Object.assign({}, size));
        canvas.save();
        if (useSameWorldTransform) copy$5(canvas.worldTransform, this.worldTransform), canvas.useWorldTransform();
        if (useSameSmooth) canvas.smooth = this.smooth;
        canvas.pixelSnap !== pixelSnap && (canvas.pixelSnap = pixelSnap);
        return canvas;
    }
    recycle(clearBounds) {
        if (!this.recycled) {
            this.restore();
            clearBounds ? this.clearWorld(clearBounds) : this.clear();
            this.manager ? this.manager.recycle(this) : this.destroy();
        }
    }
    updateRender(_bounds) {}
    unrealCanvas() {}
    destroy() {
        this.manager = this.view = this.parentView = null;
    }
}

const PathHelper = {
    creator: {},
    parse(_pathString, _curveMode) {
        return undefined;
    },
    convertToCanvasData(_old, _curveMode) {
        return undefined;
    }
};

const CanvasCommandOnlyMap = {
    N: 21,
    D: 22,
    X: 23,
    G: 24,
    F: 25,
    O: 26,
    P: 27,
    U: 28
};

const PathCommandMap = Object.assign({
    M: 1,
    m: 10,
    L: 2,
    l: 20,
    H: 3,
    h: 30,
    V: 4,
    v: 40,
    C: 5,
    c: 50,
    S: 6,
    s: 60,
    Q: 7,
    q: 70,
    T: 8,
    t: 80,
    A: 9,
    a: 90,
    Z: 11,
    z: 11,
    R: 12
}, CanvasCommandOnlyMap);

const PathCommandLengthMap = {
    M: 3,
    m: 3,
    L: 3,
    l: 3,
    H: 2,
    h: 2,
    V: 2,
    v: 2,
    C: 7,
    c: 7,
    S: 5,
    s: 5,
    Q: 5,
    q: 5,
    T: 3,
    t: 3,
    A: 8,
    a: 8,
    Z: 1,
    z: 1,
    N: 5,
    D: 9,
    X: 6,
    G: 9,
    F: 5,
    O: 7,
    P: 4,
    U: 6
};

const NeedConvertToCanvasCommandMap = {
    m: 10,
    l: 20,
    H: 3,
    h: 30,
    V: 4,
    v: 40,
    c: 50,
    S: 6,
    s: 60,
    q: 70,
    T: 8,
    t: 80,
    A: 9,
    a: 90
};

const NeedConvertToCurveCommandMap = Object.assign(Object.assign({}, NeedConvertToCanvasCommandMap), CanvasCommandOnlyMap);

const P$4 = PathCommandMap;

const PathNumberCommandMap = {};

for (let key in P$4) {
    PathNumberCommandMap[P$4[key]] = key;
}

const PathNumberCommandLengthMap = {};

for (let key in P$4) {
    PathNumberCommandLengthMap[P$4[key]] = PathCommandLengthMap[key];
}

const RectHelper = {
    drawRoundRect(drawer, x, y, width, height, cornerRadius) {
        const data = MathHelper.fourNumber(cornerRadius, Math.min(width / 2, height / 2));
        const right = x + width;
        const bottom = y + height;
        data[0] ? drawer.moveTo(x + data[0], y) : drawer.moveTo(x, y);
        data[1] ? drawer.arcTo(right, y, right, bottom, data[1]) : drawer.lineTo(right, y);
        data[2] ? drawer.arcTo(right, bottom, x, bottom, data[2]) : drawer.lineTo(right, bottom);
        data[3] ? drawer.arcTo(x, bottom, x, y, data[3]) : drawer.lineTo(x, bottom);
        data[0] ? drawer.arcTo(x, y, right, y, data[0]) : drawer.lineTo(x, y);
    }
};

const {sin: sin$1, cos: cos$1, hypot: hypot, atan2: atan2$1, ceil: ceil, abs: abs$1, PI: PI, sqrt: sqrt$1, pow: pow} = Math;

const {setPoint: setPoint$1, addPoint: addPoint$1} = TwoPointBoundsHelper;

const {set: set, toNumberPoints: toNumberPoints} = PointHelper;

const {M: M$5, L: L$6, C: C$4, Q: Q$4, Z: Z$5} = PathCommandMap;

const tempPoint$1 = {};

const BezierHelper = {
    points(data, originPoints, curve, close) {
        let points = toNumberPoints(originPoints);
        data.push(M$5, points[0], points[1]);
        if (curve && points.length > 5) {
            let aX, aY, bX, bY, cX, cY, c1X, c1Y, c2X, c2Y;
            let baX, baY, ba, cb, d, len = points.length;
            const t = curve === true ? .5 : curve;
            if (close) {
                points = [ points[len - 2], points[len - 1], ...points, points[0], points[1], points[2], points[3] ];
                len = points.length;
            }
            for (let i = 2; i < len - 2; i += 2) {
                aX = points[i - 2];
                aY = points[i - 1];
                bX = points[i];
                bY = points[i + 1];
                cX = points[i + 2];
                cY = points[i + 3];
                baX = bX - aX;
                baY = bY - aY;
                ba = sqrt$1(pow(baX, 2) + pow(baY, 2));
                cb = sqrt$1(pow(cX - bX, 2) + pow(cY - bY, 2));
                if (!ba && !cb) continue;
                d = ba + cb;
                ba = t * ba / d;
                cb = t * cb / d;
                cX -= aX;
                cY -= aY;
                c1X = bX - ba * cX;
                c1Y = bY - ba * cY;
                if (i === 2) {
                    if (!close) data.push(Q$4, c1X, c1Y, bX, bY);
                } else {
                    if (baX || baY) data.push(C$4, c2X, c2Y, c1X, c1Y, bX, bY);
                }
                c2X = bX + cb * cX;
                c2Y = bY + cb * cY;
            }
            if (!close) data.push(Q$4, c2X, c2Y, points[len - 2], points[len - 1]);
        } else {
            for (let i = 2, len = points.length; i < len; i += 2) {
                data.push(L$6, points[i], points[i + 1]);
            }
        }
        if (close) data.push(Z$5);
    },
    rect(data, x, y, width, height) {
        PathHelper.creator.path = data;
        PathHelper.creator.moveTo(x, y).lineTo(x + width, y).lineTo(x + width, y + height).lineTo(x, y + height).lineTo(x, y);
    },
    roundRect(data, x, y, width, height, radius) {
        PathHelper.creator.path = [];
        RectHelper.drawRoundRect(PathHelper.creator, x, y, width, height, radius);
        data.push(...PathHelper.convertToCanvasData(PathHelper.creator.path, true));
    },
    arcTo(data, fromX, fromY, x1, y1, toX, toY, radius, setPointBounds, setEndPoint, setStartPoint) {
        const BAx = x1 - fromX;
        const BAy = y1 - fromY;
        const CBx = toX - x1;
        const CBy = toY - y1;
        let startRadian = atan2$1(BAy, BAx);
        let endRadian = atan2$1(CBy, CBx);
        const lenBA = hypot(BAx, BAy);
        const lenCB = hypot(CBx, CBy);
        let totalRadian = endRadian - startRadian;
        if (totalRadian < 0) totalRadian += PI2;
        if (lenBA < 1e-12 || lenCB < 1e-12 || totalRadian < 1e-12 || abs$1(totalRadian - PI) < 1e-12) {
            if (data) data.push(L$6, x1, y1);
            if (setPointBounds) {
                setPoint$1(setPointBounds, fromX, fromY);
                addPoint$1(setPointBounds, x1, y1);
            }
            if (setStartPoint) set(setStartPoint, fromX, fromY);
            if (setEndPoint) set(setEndPoint, x1, y1);
            return;
        }
        const anticlockwise = BAx * CBy - CBx * BAy < 0;
        const sign = anticlockwise ? -1 : 1;
        const c = radius / cos$1(totalRadian / 2);
        const centerX = x1 + c * cos$1(startRadian + totalRadian / 2 + PI_2 * sign);
        const centerY = y1 + c * sin$1(startRadian + totalRadian / 2 + PI_2 * sign);
        startRadian -= PI_2 * sign;
        endRadian -= PI_2 * sign;
        return ellipse$5(data, centerX, centerY, radius, radius, 0, startRadian / OneRadian, endRadian / OneRadian, anticlockwise, setPointBounds, setEndPoint, setStartPoint);
    },
    arc(data, x, y, radius, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint) {
        return ellipse$5(data, x, y, radius, radius, 0, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint);
    },
    ellipse(data, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise, setPointBounds, setEndPoint, setStartPoint) {
        const rotationRadian = rotation * OneRadian;
        const rotationSin = sin$1(rotationRadian);
        const rotationCos = cos$1(rotationRadian);
        let startRadian = startAngle * OneRadian;
        let endRadian = endAngle * OneRadian;
        if (startRadian > PI) startRadian -= PI2;
        if (endRadian < 0) endRadian += PI2;
        let totalRadian = endRadian - startRadian;
        if (totalRadian < 0) totalRadian += PI2; else if (totalRadian > PI2) totalRadian -= PI2;
        if (anticlockwise) totalRadian -= PI2;
        const parts = ceil(abs$1(totalRadian / PI_2));
        const partRadian = totalRadian / parts;
        const partRadian4Sin = sin$1(partRadian / 4);
        const control = 8 / 3 * partRadian4Sin * partRadian4Sin / sin$1(partRadian / 2);
        endRadian = startRadian + partRadian;
        let startCos = cos$1(startRadian);
        let startSin = sin$1(startRadian);
        let endCos, endSin;
        let x, y, x1, y1, x2, y2;
        let startX = x = rotationCos * radiusX * startCos - rotationSin * radiusY * startSin;
        let startY = y = rotationSin * radiusX * startCos + rotationCos * radiusY * startSin;
        let fromX = cx + x, fromY = cy + y;
        if (data) data.push(data.length ? L$6 : M$5, fromX, fromY);
        if (setPointBounds) setPoint$1(setPointBounds, fromX, fromY);
        if (setStartPoint) set(setStartPoint, fromX, fromY);
        for (let i = 0; i < parts; i++) {
            endCos = cos$1(endRadian);
            endSin = sin$1(endRadian);
            x = rotationCos * radiusX * endCos - rotationSin * radiusY * endSin;
            y = rotationSin * radiusX * endCos + rotationCos * radiusY * endSin;
            x1 = cx + startX - control * (rotationCos * radiusX * startSin + rotationSin * radiusY * startCos);
            y1 = cy + startY - control * (rotationSin * radiusX * startSin - rotationCos * radiusY * startCos);
            x2 = cx + x + control * (rotationCos * radiusX * endSin + rotationSin * radiusY * endCos);
            y2 = cy + y + control * (rotationSin * radiusX * endSin - rotationCos * radiusY * endCos);
            if (data) data.push(C$4, x1, y1, x2, y2, cx + x, cy + y);
            if (setPointBounds) toTwoPointBounds$1(cx + startX, cy + startY, x1, y1, x2, y2, cx + x, cy + y, setPointBounds, true);
            startX = x;
            startY = y;
            startCos = endCos;
            startSin = endSin;
            startRadian = endRadian;
            endRadian += partRadian;
        }
        if (setEndPoint) set(setEndPoint, cx + x, cy + y);
    },
    quadraticCurveTo(data, fromX, fromY, x1, y1, toX, toY) {
        data.push(C$4, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY);
    },
    toTwoPointBoundsByQuadraticCurve(fromX, fromY, x1, y1, toX, toY, pointBounds, addMode) {
        toTwoPointBounds$1(fromX, fromY, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY, pointBounds, addMode);
    },
    toTwoPointBounds(fromX, fromY, x1, y1, x2, y2, toX, toY, pointBounds, addMode) {
        const tList = [];
        let a, b, c, t, t1, t2, v, sqrtV;
        let f = fromX, z1 = x1, z2 = x2, o = toX;
        for (let i = 0; i < 2; ++i) {
            if (i == 1) {
                f = fromY, z1 = y1, z2 = y2, o = toY;
            }
            a = -3 * f + 9 * z1 - 9 * z2 + 3 * o;
            b = 6 * f - 12 * z1 + 6 * z2;
            c = 3 * z1 - 3 * f;
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) continue;
                t = -c / b;
                if (0 < t && t < 1) tList.push(t);
                continue;
            }
            v = b * b - 4 * c * a;
            sqrtV = Math.sqrt(v);
            if (v < 0) continue;
            t1 = (-b + sqrtV) / (2 * a);
            if (0 < t1 && t1 < 1) tList.push(t1);
            t2 = (-b - sqrtV) / (2 * a);
            if (0 < t2 && t2 < 1) tList.push(t2);
        }
        addMode ? addPoint$1(pointBounds, fromX, fromY) : setPoint$1(pointBounds, fromX, fromY);
        addPoint$1(pointBounds, toX, toY);
        for (let i = 0, len = tList.length; i < len; i++) {
            getPointAndSet(tList[i], fromX, fromY, x1, y1, x2, y2, toX, toY, tempPoint$1);
            addPoint$1(pointBounds, tempPoint$1.x, tempPoint$1.y);
        }
    },
    getPointAndSet(t, fromX, fromY, x1, y1, x2, y2, toX, toY, setPoint) {
        const o = 1 - t, a = o * o * o, b = 3 * o * o * t, c = 3 * o * t * t, d = t * t * t;
        setPoint.x = a * fromX + b * x1 + c * x2 + d * toX;
        setPoint.y = a * fromY + b * y1 + c * y2 + d * toY;
    },
    getPoint(t, fromX, fromY, x1, y1, x2, y2, toX, toY) {
        const point = {};
        getPointAndSet(t, fromX, fromY, x1, y1, x2, y2, toX, toY, point);
        return point;
    },
    getDerivative(t, fromV, v1, v2, toV) {
        const o = 1 - t;
        return 3 * o * o * (v1 - fromV) + 6 * o * t * (v2 - v1) + 3 * t * t * (toV - v2);
    }
};

const {getPointAndSet: getPointAndSet, toTwoPointBounds: toTwoPointBounds$1, ellipse: ellipse$5} = BezierHelper;

const {sin: sin, cos: cos, sqrt: sqrt, atan2: atan2} = Math;

const {ellipse: ellipse$4} = BezierHelper;

const EllipseHelper = {
    ellipticalArc(data, fromX, fromY, radiusX, radiusY, rotation, largeFlag, sweepFlag, toX, toY, curveMode) {
        const halfX = (toX - fromX) / 2;
        const halfY = (toY - fromY) / 2;
        const rotationRadian = rotation * OneRadian;
        const rotationSin = sin(rotationRadian);
        const rotationCos = cos(rotationRadian);
        const px = -rotationCos * halfX - rotationSin * halfY;
        const py = -rotationCos * halfY + rotationSin * halfX;
        const rxSquare = radiusX * radiusX;
        const rySquare = radiusY * radiusY;
        const pySquare = py * py;
        const pxSquare = px * px;
        const a = rxSquare * rySquare - rxSquare * pySquare - rySquare * pxSquare;
        let s = 0;
        if (a < 0) {
            const t = sqrt(1 - a / (rxSquare * rySquare));
            radiusX *= t;
            radiusY *= t;
        } else {
            s = (largeFlag === sweepFlag ? -1 : 1) * sqrt(a / (rxSquare * pySquare + rySquare * pxSquare));
        }
        const cx = s * radiusX * py / radiusY;
        const cy = -s * radiusY * px / radiusX;
        const startRadian = atan2((py - cy) / radiusY, (px - cx) / radiusX);
        const endRadian = atan2((-py - cy) / radiusY, (-px - cx) / radiusX);
        let totalRadian = endRadian - startRadian;
        if (sweepFlag === 0 && totalRadian > 0) {
            totalRadian -= PI2;
        } else if (sweepFlag === 1 && totalRadian < 0) {
            totalRadian += PI2;
        }
        const centerX = fromX + halfX + rotationCos * cx - rotationSin * cy;
        const centerY = fromY + halfY + rotationSin * cx + rotationCos * cy;
        const anticlockwise = totalRadian < 0 ? 1 : 0;
        if (curveMode || Platform.ellipseToCurve) {
            ellipse$4(data, centerX, centerY, radiusX, radiusY, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
        } else {
            if (radiusX === radiusY && !rotation) {
                data.push(PathCommandMap.O, centerX, centerY, radiusX, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
            } else {
                data.push(PathCommandMap.G, centerX, centerY, radiusX, radiusY, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
            }
        }
    }
};

const PathCommandNodeHelper = {
    toCommand(_nodes) {
        return [];
    },
    toNode(_data) {
        return [];
    }
};

const {M: M$4, m: m, L: L$5, l: l, H: H, h: h, V: V, v: v, C: C$3, c: c, S: S, s: s, Q: Q$3, q: q, T: T, t: t, A: A, a: a, Z: Z$4, z: z, N: N$3, D: D$3, X: X$3, G: G$3, F: F$4, O: O$3, P: P$3, U: U$3} = PathCommandMap;

const {rect: rect$1, roundRect: roundRect$2, arcTo: arcTo$3, arc: arc$3, ellipse: ellipse$3, quadraticCurveTo: quadraticCurveTo$1} = BezierHelper;

const {ellipticalArc: ellipticalArc} = EllipseHelper;

const debug$7 = Debug.get("PathConvert");

const setEndPoint$1 = {};

const PathConvert = {
    current: {
        dot: 0
    },
    stringify(data, floatLength) {
        let i = 0, len = data.length, count, str = "", command, lastCommand;
        while (i < len) {
            command = data[i];
            count = PathNumberCommandLengthMap[command];
            if (command === lastCommand) {
                str += " ";
            } else {
                str += PathNumberCommandMap[command];
            }
            for (let j = 1; j < count; j++) {
                str += MathHelper.float(data[i + j], floatLength);
                j === count - 1 || (str += " ");
            }
            lastCommand = command;
            i += count;
        }
        return str;
    },
    parse(pathString, curveMode) {
        let needConvert, char, lastChar, num = "";
        const data = [];
        const convertCommand = curveMode ? NeedConvertToCurveCommandMap : NeedConvertToCanvasCommandMap;
        for (let i = 0, len = pathString.length; i < len; i++) {
            char = pathString[i];
            if (StringNumberMap[char]) {
                if (char === ".") {
                    if (current.dot) {
                        pushData(data, num);
                        num = "";
                    }
                    current.dot++;
                }
                if (num === "0" && char !== ".") {
                    pushData(data, num);
                    num = "";
                }
                num += char;
            } else if (PathCommandMap[char]) {
                if (num) {
                    pushData(data, num);
                    num = "";
                }
                current.name = PathCommandMap[char];
                current.length = PathCommandLengthMap[char];
                current.index = 0;
                pushData(data, current.name);
                if (!needConvert && convertCommand[char]) needConvert = true;
            } else {
                if (char === "-" || char === "+") {
                    if (lastChar === "e" || lastChar === "E") {
                        num += char;
                    } else {
                        if (num) pushData(data, num);
                        num = char;
                    }
                } else {
                    if (num) {
                        pushData(data, num);
                        num = "";
                    }
                }
            }
            lastChar = char;
        }
        if (num) pushData(data, num);
        return needConvert ? PathConvert.toCanvasData(data, curveMode) : data;
    },
    toCanvasData(old, curveMode) {
        let x = 0, y = 0, x1 = 0, y1 = 0, i = 0, len = old.length, controlX, controlY, command, lastCommand, smooth;
        const data = [];
        while (i < len) {
            command = old[i];
            switch (command) {
              case m:
                old[i + 1] += x;
                old[i + 2] += y;

              case M$4:
                x = old[i + 1];
                y = old[i + 2];
                data.push(M$4, x, y);
                i += 3;
                break;

              case h:
                old[i + 1] += x;

              case H:
                x = old[i + 1];
                data.push(L$5, x, y);
                i += 2;
                break;

              case v:
                old[i + 1] += y;

              case V:
                y = old[i + 1];
                data.push(L$5, x, y);
                i += 2;
                break;

              case l:
                old[i + 1] += x;
                old[i + 2] += y;

              case L$5:
                x = old[i + 1];
                y = old[i + 2];
                data.push(L$5, x, y);
                i += 3;
                break;

              case s:
                old[i + 1] += x;
                old[i + 2] += y;
                old[i + 3] += x;
                old[i + 4] += y;
                command = S;

              case S:
                smooth = lastCommand === C$3 || lastCommand === S;
                x1 = smooth ? x * 2 - controlX : old[i + 1];
                y1 = smooth ? y * 2 - controlY : old[i + 2];
                controlX = old[i + 1];
                controlY = old[i + 2];
                x = old[i + 3];
                y = old[i + 4];
                data.push(C$3, x1, y1, controlX, controlY, x, y);
                i += 5;
                break;

              case c:
                old[i + 1] += x;
                old[i + 2] += y;
                old[i + 3] += x;
                old[i + 4] += y;
                old[i + 5] += x;
                old[i + 6] += y;
                command = C$3;

              case C$3:
                controlX = old[i + 3];
                controlY = old[i + 4];
                x = old[i + 5];
                y = old[i + 6];
                data.push(C$3, old[i + 1], old[i + 2], controlX, controlY, x, y);
                i += 7;
                break;

              case t:
                old[i + 1] += x;
                old[i + 2] += y;
                command = T;

              case T:
                smooth = lastCommand === Q$3 || lastCommand === T;
                controlX = smooth ? x * 2 - controlX : old[i + 1];
                controlY = smooth ? y * 2 - controlY : old[i + 2];
                curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 1], old[i + 2]) : data.push(Q$3, controlX, controlY, old[i + 1], old[i + 2]);
                x = old[i + 1];
                y = old[i + 2];
                i += 3;
                break;

              case q:
                old[i + 1] += x;
                old[i + 2] += y;
                old[i + 3] += x;
                old[i + 4] += y;
                command = Q$3;

              case Q$3:
                controlX = old[i + 1];
                controlY = old[i + 2];
                curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 3], old[i + 4]) : data.push(Q$3, controlX, controlY, old[i + 3], old[i + 4]);
                x = old[i + 3];
                y = old[i + 4];
                i += 5;
                break;

              case a:
                old[i + 6] += x;
                old[i + 7] += y;

              case A:
                ellipticalArc(data, x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], curveMode);
                x = old[i + 6];
                y = old[i + 7];
                i += 8;
                break;

              case z:
              case Z$4:
                data.push(Z$4);
                i++;
                break;

              case N$3:
                x = old[i + 1];
                y = old[i + 2];
                curveMode ? rect$1(data, x, y, old[i + 3], old[i + 4]) : copyData(data, old, i, 5);
                i += 5;
                break;

              case D$3:
                x = old[i + 1];
                y = old[i + 2];
                curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], [ old[i + 5], old[i + 6], old[i + 7], old[i + 8] ]) : copyData(data, old, i, 9);
                i += 9;
                break;

              case X$3:
                x = old[i + 1];
                y = old[i + 2];
                curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], old[i + 5]) : copyData(data, old, i, 6);
                i += 6;
                break;

              case G$3:
                ellipse$3(curveMode ? data : copyData(data, old, i, 9), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], old[i + 8], null, setEndPoint$1);
                x = setEndPoint$1.x;
                y = setEndPoint$1.y;
                i += 9;
                break;

              case F$4:
                curveMode ? ellipse$3(data, old[i + 1], old[i + 2], old[i + 3], old[i + 4], 0, 0, 360, false) : copyData(data, old, i, 5);
                x = old[i + 1] + old[i + 3];
                y = old[i + 2];
                i += 5;
                break;

              case O$3:
                arc$3(curveMode ? data : copyData(data, old, i, 7), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], null, setEndPoint$1);
                x = setEndPoint$1.x;
                y = setEndPoint$1.y;
                i += 7;
                break;

              case P$3:
                curveMode ? arc$3(data, old[i + 1], old[i + 2], old[i + 3], 0, 360, false) : copyData(data, old, i, 4);
                x = old[i + 1] + old[i + 3];
                y = old[i + 2];
                i += 4;
                break;

              case U$3:
                arcTo$3(curveMode ? data : copyData(data, old, i, 6), x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], null, setEndPoint$1);
                x = setEndPoint$1.x;
                y = setEndPoint$1.y;
                i += 6;
                break;

              default:
                debug$7.error(`command: ${command} [index:${i}]`, old);
                return data;
            }
            lastCommand = command;
        }
        return data;
    },
    objectToCanvasData(list) {
        if (list[0].name.length > 1) {
            return PathCommandNodeHelper.toCommand(list);
        } else {
            const data = [];
            list.forEach(item => {
                switch (item.name) {
                  case "M":
                    data.push(M$4, item.x, item.y);
                    break;

                  case "L":
                    data.push(L$5, item.x, item.y);
                    break;

                  case "C":
                    data.push(C$3, item.x1, item.y1, item.x2, item.y2, item.x, item.y);
                    break;

                  case "Q":
                    data.push(Q$3, item.x1, item.y1, item.x, item.y);
                    break;

                  case "Z":
                    data.push(Z$4);
                }
            });
            return data;
        }
    },
    copyData(data, old, index, count) {
        for (let i = index, end = index + count; i < end; i++) {
            data.push(old[i]);
        }
    },
    pushData(data, strNum) {
        if (current.index === current.length) {
            current.index = 1;
            data.push(current.name);
        }
        data.push(Number(strNum));
        current.index++;
        current.dot = 0;
    }
};

const {current: current, pushData: pushData, copyData: copyData} = PathConvert;

const {M: M$3, L: L$4, C: C$2, Q: Q$2, Z: Z$3, N: N$2, D: D$2, X: X$2, G: G$2, F: F$3, O: O$2, P: P$2, U: U$2} = PathCommandMap;

const {getMinDistanceFrom: getMinDistanceFrom, getRadianFrom: getRadianFrom} = PointHelper;

const {tan: tan, min: min, abs: abs} = Math;

const startPoint = {};

const PathCommandDataHelper = {
    beginPath(data) {
        data.length = 0;
    },
    moveTo(data, x, y) {
        data.push(M$3, x, y);
    },
    lineTo(data, x, y) {
        data.push(L$4, x, y);
    },
    bezierCurveTo(data, x1, y1, x2, y2, x, y) {
        data.push(C$2, x1, y1, x2, y2, x, y);
    },
    quadraticCurveTo(data, x1, y1, x, y) {
        data.push(Q$2, x1, y1, x, y);
    },
    closePath(data) {
        data.push(Z$3);
    },
    rect(data, x, y, width, height) {
        data.push(N$2, x, y, width, height);
    },
    roundRect(data, x, y, width, height, cornerRadius) {
        if (isNumber(cornerRadius)) {
            data.push(X$2, x, y, width, height, cornerRadius);
        } else {
            const fourCorners = MathHelper.fourNumber(cornerRadius);
            if (fourCorners) {
                data.push(D$2, x, y, width, height, ...fourCorners);
            } else {
                data.push(N$2, x, y, width, height);
            }
        }
    },
    ellipse(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        if (radiusX === radiusY) return arc$2(data, x, y, radiusX, startAngle, endAngle, anticlockwise);
        if (isNull(rotation)) {
            data.push(F$3, x, y, radiusX, radiusY);
        } else {
            if (isNull(startAngle)) startAngle = 0;
            if (isNull(endAngle)) endAngle = 360;
            data.push(G$2, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ? 1 : 0);
        }
    },
    arc(data, x, y, radius, startAngle, endAngle, anticlockwise) {
        if (isNull(startAngle)) {
            data.push(P$2, x, y, radius);
        } else {
            if (isNull(startAngle)) startAngle = 0;
            if (isNull(endAngle)) endAngle = 360;
            data.push(O$2, x, y, radius, startAngle, endAngle, anticlockwise ? 1 : 0);
        }
    },
    arcTo(data, x1, y1, x2, y2, radius, lastX, lastY) {
        if (!isUndefined(lastX)) {
            const d = getMinDistanceFrom(lastX, lastY, x1, y1, x2, y2);
            radius = min(radius, min(d / 2, d / 2 * abs(tan(getRadianFrom(lastX, lastY, x1, y1, x2, y2) / 2))));
        }
        data.push(U$2, x1, y1, x2, y2, radius);
    },
    drawEllipse(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        BezierHelper.ellipse(null, x, y, radiusX, radiusY, isNull(rotation) ? 0 : rotation, isNull(startAngle) ? 0 : startAngle, isNull(endAngle) ? 360 : endAngle, anticlockwise, null, null, startPoint);
        data.push(M$3, startPoint.x, startPoint.y);
        ellipse$2(data, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    },
    drawArc(data, x, y, radius, startAngle, endAngle, anticlockwise) {
        BezierHelper.arc(null, x, y, radius, isNull(startAngle) ? 0 : startAngle, isNull(endAngle) ? 360 : endAngle, anticlockwise, null, null, startPoint);
        data.push(M$3, startPoint.x, startPoint.y);
        arc$2(data, x, y, radius, startAngle, endAngle, anticlockwise);
    },
    drawPoints(data, points, curve, close) {
        BezierHelper.points(data, points, curve, close);
    }
};

const {ellipse: ellipse$2, arc: arc$2} = PathCommandDataHelper;

const {moveTo: moveTo, lineTo: lineTo, quadraticCurveTo: quadraticCurveTo, bezierCurveTo: bezierCurveTo, closePath: closePath, beginPath: beginPath, rect: rect, roundRect: roundRect$1, ellipse: ellipse$1, arc: arc$1, arcTo: arcTo$2, drawEllipse: drawEllipse, drawArc: drawArc, drawPoints: drawPoints} = PathCommandDataHelper;

class PathCreator {
    set path(value) {
        this.__path = value;
    }
    get path() {
        return this.__path;
    }
    constructor(path) {
        this.set(path);
    }
    set(path) {
        this.__path = path ? isString(path) ? PathHelper.parse(path) : path : [];
        return this;
    }
    beginPath() {
        beginPath(this.__path);
        this.paint();
        return this;
    }
    moveTo(x, y) {
        moveTo(this.__path, x, y);
        this.paint();
        return this;
    }
    lineTo(x, y) {
        lineTo(this.__path, x, y);
        this.paint();
        return this;
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
        bezierCurveTo(this.__path, x1, y1, x2, y2, x, y);
        this.paint();
        return this;
    }
    quadraticCurveTo(x1, y1, x, y) {
        quadraticCurveTo(this.__path, x1, y1, x, y);
        this.paint();
        return this;
    }
    closePath() {
        closePath(this.__path);
        this.paint();
        return this;
    }
    rect(x, y, width, height) {
        rect(this.__path, x, y, width, height);
        this.paint();
        return this;
    }
    roundRect(x, y, width, height, cornerRadius) {
        roundRect$1(this.__path, x, y, width, height, cornerRadius);
        this.paint();
        return this;
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        ellipse$1(this.__path, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
        this.paint();
        return this;
    }
    arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        arc$1(this.__path, x, y, radius, startAngle, endAngle, anticlockwise);
        this.paint();
        return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
        arcTo$2(this.__path, x1, y1, x2, y2, radius);
        this.paint();
        return this;
    }
    drawEllipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        drawEllipse(this.__path, x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
        this.paint();
        return this;
    }
    drawArc(x, y, radius, startAngle, endAngle, anticlockwise) {
        drawArc(this.__path, x, y, radius, startAngle, endAngle, anticlockwise);
        this.paint();
        return this;
    }
    drawPoints(points, curve, close) {
        drawPoints(this.__path, points, curve, close);
        this.paint();
        return this;
    }
    clearPath() {
        return this.beginPath();
    }
    paint() {}
}

const {M: M$2, L: L$3, C: C$1, Q: Q$1, Z: Z$2, N: N$1, D: D$1, X: X$1, G: G$1, F: F$2, O: O$1, P: P$1, U: U$1} = PathCommandMap;

const debug$6 = Debug.get("PathDrawer");

const PathDrawer = {
    drawPathByData(drawer, data) {
        if (!data) return;
        let command;
        let i = 0, len = data.length;
        while (i < len) {
            command = data[i];
            switch (command) {
              case M$2:
                drawer.moveTo(data[i + 1], data[i + 2]);
                i += 3;
                break;

              case L$3:
                drawer.lineTo(data[i + 1], data[i + 2]);
                i += 3;
                break;

              case C$1:
                drawer.bezierCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
                i += 7;
                break;

              case Q$1:
                drawer.quadraticCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
                i += 5;
                break;

              case Z$2:
                drawer.closePath();
                i += 1;
                break;

              case N$1:
                drawer.rect(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
                i += 5;
                break;

              case D$1:
                drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], [ data[i + 5], data[i + 6], data[i + 7], data[i + 8] ]);
                i += 9;
                break;

              case X$1:
                drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
                i += 6;
                break;

              case G$1:
                drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5] * OneRadian, data[i + 6] * OneRadian, data[i + 7] * OneRadian, data[i + 8]);
                i += 9;
                break;

              case F$2:
                drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], 0, 0, PI2, false);
                i += 5;
                break;

              case O$1:
                drawer.arc(data[i + 1], data[i + 2], data[i + 3], data[i + 4] * OneRadian, data[i + 5] * OneRadian, data[i + 6]);
                i += 7;
                break;

              case P$1:
                drawer.arc(data[i + 1], data[i + 2], data[i + 3], 0, PI2, false);
                i += 4;
                break;

              case U$1:
                drawer.arcTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
                i += 6;
                break;

              default:
                debug$6.error(`command: ${command} [index:${i}]`, data);
                return;
            }
        }
    }
};

const {M: M$1, L: L$2, C: C, Q: Q, Z: Z$1, N: N, D: D, X: X, G: G, F: F$1, O: O, P: P, U: U} = PathCommandMap;

const {toTwoPointBounds: toTwoPointBounds, toTwoPointBoundsByQuadraticCurve: toTwoPointBoundsByQuadraticCurve, arcTo: arcTo$1, arc: arc, ellipse: ellipse} = BezierHelper;

const {addPointBounds: addPointBounds, copy: copy$4, addPoint: addPoint, setPoint: setPoint, addBounds: addBounds, toBounds: toBounds$1} = TwoPointBoundsHelper;

const debug$5 = Debug.get("PathBounds");

let radius, radiusX, radiusY;

const tempPointBounds = {};

const setPointBounds = {};

const setEndPoint = {};

const PathBounds = {
    toBounds(data, setBounds) {
        PathBounds.toTwoPointBounds(data, setPointBounds);
        toBounds$1(setPointBounds, setBounds);
    },
    toTwoPointBounds(data, setPointBounds) {
        if (!data || !data.length) return setPoint(setPointBounds, 0, 0);
        let i = 0, x = 0, y = 0, x1, y1, toX, toY, command;
        const len = data.length;
        while (i < len) {
            command = data[i];
            if (i === 0) {
                if (command === Z$1 || command === C || command === Q) {
                    setPoint(setPointBounds, x, y);
                } else {
                    setPoint(setPointBounds, data[i + 1], data[i + 2]);
                }
            }
            switch (command) {
              case M$1:
              case L$2:
                x = data[i + 1];
                y = data[i + 2];
                addPoint(setPointBounds, x, y);
                i += 3;
                break;

              case C:
                toX = data[i + 5];
                toY = data[i + 6];
                toTwoPointBounds(x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], toX, toY, tempPointBounds);
                addPointBounds(setPointBounds, tempPointBounds);
                x = toX;
                y = toY;
                i += 7;
                break;

              case Q:
                x1 = data[i + 1];
                y1 = data[i + 2];
                toX = data[i + 3];
                toY = data[i + 4];
                toTwoPointBoundsByQuadraticCurve(x, y, x1, y1, toX, toY, tempPointBounds);
                addPointBounds(setPointBounds, tempPointBounds);
                x = toX;
                y = toY;
                i += 5;
                break;

              case Z$1:
                i += 1;
                break;

              case N:
                x = data[i + 1];
                y = data[i + 2];
                addBounds(setPointBounds, x, y, data[i + 3], data[i + 4]);
                i += 5;
                break;

              case D:
              case X:
                x = data[i + 1];
                y = data[i + 2];
                addBounds(setPointBounds, x, y, data[i + 3], data[i + 4]);
                i += command === D ? 9 : 6;
                break;

              case G:
                ellipse(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], tempPointBounds, setEndPoint);
                i === 0 ? copy$4(setPointBounds, tempPointBounds) : addPointBounds(setPointBounds, tempPointBounds);
                x = setEndPoint.x;
                y = setEndPoint.y;
                i += 9;
                break;

              case F$1:
                x = data[i + 1];
                y = data[i + 2];
                radiusX = data[i + 3];
                radiusY = data[i + 4];
                addBounds(setPointBounds, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2);
                x += radiusX;
                i += 5;
                break;

              case O:
                arc(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], tempPointBounds, setEndPoint);
                i === 0 ? copy$4(setPointBounds, tempPointBounds) : addPointBounds(setPointBounds, tempPointBounds);
                x = setEndPoint.x;
                y = setEndPoint.y;
                i += 7;
                break;

              case P:
                x = data[i + 1];
                y = data[i + 2];
                radius = data[i + 3];
                addBounds(setPointBounds, x - radius, y - radius, radius * 2, radius * 2);
                x += radius;
                i += 4;
                break;

              case U:
                arcTo$1(null, x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], tempPointBounds, setEndPoint);
                i === 0 ? copy$4(setPointBounds, tempPointBounds) : addPointBounds(setPointBounds, tempPointBounds);
                x = setEndPoint.x;
                y = setEndPoint.y;
                i += 6;
                break;

              default:
                debug$5.error(`command: ${command} [index:${i}]`, data);
                return;
            }
        }
    }
};

const {M: M, L: L$1, Z: Z} = PathCommandMap;

const {getCenterX: getCenterX, getCenterY: getCenterY} = PointHelper;

const {arcTo: arcTo} = PathCommandDataHelper;

const PathCorner = {
    smooth(data, cornerRadius, _cornerSmoothing) {
        let command, lastCommand, commandLen;
        let i = 0, x = 0, y = 0, startX = 0, startY = 0, secondX = 0, secondY = 0, lastX = 0, lastY = 0;
        if (isArray(cornerRadius)) cornerRadius = cornerRadius[0] || 0;
        const len = data.length;
        const smooth = [];
        while (i < len) {
            command = data[i];
            switch (command) {
              case M:
                startX = lastX = data[i + 1];
                startY = lastY = data[i + 2];
                i += 3;
                if (data[i] === L$1) {
                    secondX = data[i + 1];
                    secondY = data[i + 2];
                    smooth.push(M, getCenterX(startX, secondX), getCenterY(startY, secondY));
                } else {
                    smooth.push(M, startX, startY);
                }
                break;

              case L$1:
                x = data[i + 1];
                y = data[i + 2];
                i += 3;
                switch (data[i]) {
                  case L$1:
                    arcTo(smooth, x, y, data[i + 1], data[i + 2], cornerRadius, lastX, lastY);
                    break;

                  case Z:
                    arcTo(smooth, x, y, startX, startY, cornerRadius, lastX, lastY);
                    break;

                  default:
                    smooth.push(L$1, x, y);
                }
                lastX = x;
                lastY = y;
                break;

              case Z:
                if (lastCommand !== Z) {
                    arcTo(smooth, startX, startY, secondX, secondY, cornerRadius, lastX, lastY);
                    smooth.push(Z);
                }
                i += 1;
                break;

              default:
                commandLen = PathNumberCommandLengthMap[command];
                for (let j = 0; j < commandLen; j++) smooth.push(data[i + j]);
                i += commandLen;
            }
            lastCommand = command;
        }
        if (command !== Z) {
            smooth[1] = startX;
            smooth[2] = startY;
        }
        return smooth;
    }
};

function path(path) {
    return new PathCreator(path);
}

const pen = path();

PathHelper.creator = path();

PathHelper.parse = PathConvert.parse;

PathHelper.convertToCanvasData = PathConvert.toCanvasData;

const {drawRoundRect: drawRoundRect} = RectHelper;

function roundRect(drawer) {
    if (drawer && !drawer.roundRect) {
        drawer.roundRect = function(x, y, width, height, cornerRadius) {
            drawRoundRect(this, x, y, width, height, cornerRadius);
        };
    }
}

function canvasPatch(drawer) {
    roundRect(drawer);
}

const FileHelper = {
    alphaPixelTypes: [ "png", "webp", "svg" ],
    upperCaseTypeMap: {},
    mineType(type) {
        if (!type || type.startsWith("image")) return type;
        if (type === "jpg") type = "jpeg";
        return "image/" + type;
    },
    fileType(filename) {
        const l = filename.split(".");
        return l[l.length - 1];
    },
    isOpaqueImage(filename) {
        const type = F.fileType(filename);
        return [ "jpg", "jpeg" ].some(item => item === type);
    },
    getExportOptions(options) {
        switch (typeof options) {
          case "object":
            return options;

          case "number":
            return {
                quality: options
            };

          case "boolean":
            return {
                blob: options
            };

          default:
            return {};
        }
    }
};

const F = FileHelper;

F.alphaPixelTypes.forEach(type => F.upperCaseTypeMap[type] = type.toUpperCase());

const debug$4 = Debug.get("TaskProcessor");

class TaskItem {
    constructor(task) {
        this.parallel = true;
        this.time = 1;
        this.id = IncrementId.create(IncrementId.TASK);
        this.task = task;
    }
    run() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                if (this.isComplete || this.runing) return;
                this.runing = true;
                if (this.canUse && !this.canUse()) return this.cancel();
                if (this.task) yield this.task();
            } catch (error) {
                debug$4.error(error);
            }
        });
    }
    complete() {
        this.isComplete = true;
        this.parent = this.task = this.canUse = null;
    }
    cancel() {
        this.isCancel = true;
        this.complete();
    }
}

class TaskProcessor {
    get total() {
        return this.list.length + this.delayNumber;
    }
    get finishedIndex() {
        return this.isComplete ? 0 : this.index + this.parallelSuccessNumber;
    }
    get remain() {
        return this.isComplete ? this.total : this.total - this.finishedIndex;
    }
    get percent() {
        const {total: total} = this;
        let totalTime = 0, runTime = 0;
        for (let i = 0; i < total; i++) {
            if (i <= this.finishedIndex) {
                runTime += this.list[i].time;
                if (i === this.finishedIndex) totalTime = runTime;
            } else {
                totalTime += this.list[i].time;
            }
        }
        return this.isComplete ? 1 : runTime / totalTime;
    }
    constructor(config) {
        this.config = {
            parallel: 6
        };
        this.list = [];
        this.running = false;
        this.isComplete = true;
        this.index = 0;
        this.delayNumber = 0;
        if (config) DataHelper.assign(this.config, config);
        this.empty();
    }
    add(taskCallback, options, canUse) {
        let start, parallel, time, delay;
        const task = new TaskItem(taskCallback);
        task.parent = this;
        if (isNumber(options)) {
            delay = options;
        } else if (options) {
            parallel = options.parallel;
            start = options.start;
            time = options.time;
            delay = options.delay;
            if (!canUse) canUse = options.canUse;
        }
        if (time) task.time = time;
        if (parallel === false) task.parallel = false;
        if (canUse) task.canUse = canUse;
        if (isUndefined(delay)) {
            this.push(task, start);
        } else {
            this.delayNumber++;
            setTimeout(() => {
                if (this.delayNumber) {
                    this.delayNumber--;
                    this.push(task, start);
                }
            }, delay);
        }
        this.isComplete = false;
        return task;
    }
    push(task, start) {
        this.list.push(task);
        if (start !== false && !this.timer) {
            this.timer = setTimeout(() => this.start());
        }
    }
    empty() {
        this.index = 0;
        this.parallelSuccessNumber = 0;
        this.list = [];
        this.parallelList = [];
        this.delayNumber = 0;
    }
    start() {
        if (!this.running) {
            this.running = true;
            this.isComplete = false;
            this.run();
        }
    }
    pause() {
        clearTimeout(this.timer);
        this.timer = null;
        this.running = false;
    }
    resume() {
        this.start();
    }
    skip() {
        this.index++;
        this.resume();
    }
    stop() {
        this.isComplete = true;
        this.list.forEach(task => {
            if (!task.isComplete) task.run();
        });
        this.pause();
        this.empty();
    }
    run() {
        if (!this.running) return;
        this.setParallelList();
        if (this.parallelList.length > 1) {
            this.runParallelTasks();
        } else {
            this.remain ? this.runTask() : this.onComplete();
        }
    }
    runTask() {
        const task = this.list[this.index];
        if (!task) {
            this.timer = setTimeout(() => this.nextTask());
            return;
        }
        task.run().then(() => {
            this.onTask(task);
            this.index++;
            task.isCancel ? this.runTask() : this.nextTask();
        }).catch(error => {
            this.onError(error);
        });
    }
    runParallelTasks() {
        this.parallelList.forEach(task => this.runParallelTask(task));
    }
    runParallelTask(task) {
        task.run().then(() => {
            this.onTask(task);
            this.fillParallelTask();
        }).catch(error => {
            this.onParallelError(error);
        });
    }
    nextTask() {
        if (this.total === this.finishedIndex) {
            this.onComplete();
        } else {
            this.timer = setTimeout(() => this.run());
        }
    }
    setParallelList() {
        let task;
        const {config: config, list: list, index: index} = this;
        this.parallelList = [];
        this.parallelSuccessNumber = 0;
        let end = index + config.parallel;
        if (end > list.length) end = list.length;
        if (config.parallel > 1) {
            for (let i = index; i < end; i++) {
                task = list[i];
                if (task.parallel) this.parallelList.push(task); else break;
            }
        }
    }
    fillParallelTask() {
        let task;
        const parallelList = this.parallelList;
        this.parallelSuccessNumber++;
        parallelList.pop();
        const parallelWaitNumber = parallelList.length;
        const nextIndex = this.finishedIndex + parallelWaitNumber;
        if (parallelList.length) {
            if (!this.running) return;
            if (nextIndex < this.total) {
                task = this.list[nextIndex];
                if (task && task.parallel) {
                    parallelList.push(task);
                    this.runParallelTask(task);
                }
            }
        } else {
            this.index += this.parallelSuccessNumber;
            this.parallelSuccessNumber = 0;
            this.nextTask();
        }
    }
    onComplete() {
        this.stop();
        if (this.config.onComplete) this.config.onComplete();
    }
    onTask(task) {
        task.complete();
        if (this.config.onTask) this.config.onTask();
    }
    onParallelError(error) {
        this.parallelList.forEach(task => {
            task.parallel = false;
        });
        this.parallelList.length = 0;
        this.parallelSuccessNumber = 0;
        this.onError(error);
    }
    onError(error) {
        this.pause();
        if (this.config.onError) this.config.onError(error);
    }
    destroy() {
        this.stop();
    }
}

const debug$3 = Debug.get("Resource");

const Resource = {
    tasker: new TaskProcessor,
    map: {},
    get isComplete() {
        return R.tasker.isComplete;
    },
    set(key, value) {
        if (R.map[key]) debug$3.repeat(key);
        R.map[key] = value;
    },
    get(key) {
        return R.map[key];
    },
    remove(key) {
        const r = R.map[key];
        if (r) {
            if (r.destroy) r.destroy();
            delete R.map[key];
        }
    },
    loadImage(key, format) {
        return new Promise((resolve, reject) => {
            const image = this.setImage(key, key, format);
            image.load(() => resolve(image), e => reject(e));
        });
    },
    setImage(key, value, format) {
        let config;
        if (isString(value)) config = {
            url: value
        }; else if (!value.url) config = {
            url: key,
            view: value
        };
        if (config) format && (config.format = format), value = Creator.image(config);
        R.set(key, value);
        return value;
    },
    destroy() {
        R.map = {};
    }
};

const R = Resource;

const ImageManager = {
    maxRecycled: 10,
    recycledList: [],
    patternTasker: new TaskProcessor({
        parallel: 1
    }),
    get(config) {
        let image = Resource.get(config.url);
        if (!image) Resource.set(config.url, image = Creator.image(config));
        image.use++;
        return image;
    },
    recycle(image) {
        image.use--;
        setTimeout(() => {
            if (!image.use) {
                if (Platform.image.isLarge(image)) {
                    if (image.url) Resource.remove(image.url);
                } else {
                    image.clearLevels();
                    I.recycledList.push(image);
                }
            }
        });
    },
    recyclePaint(paint) {
        I.recycle(paint.image);
    },
    clearRecycled(force) {
        const list = I.recycledList;
        if (list.length > I.maxRecycled || force) {
            list.forEach(image => (!image.use || force) && image.url && Resource.remove(image.url));
            list.length = 0;
        }
    },
    clearLevels() {},
    hasAlphaPixel(config) {
        return FileHelper.alphaPixelTypes.some(item => I.isFormat(item, config));
    },
    isFormat(format, config) {
        if (config.format) return config.format === format;
        const {url: url} = config;
        if (url.startsWith("data:")) {
            if (url.startsWith("data:" + FileHelper.mineType(format))) return true;
        } else {
            if (url.includes("." + format) || url.includes("." + FileHelper.upperCaseTypeMap[format])) return true; else if (format === "png" && !url.includes(".")) return true;
        }
        return false;
    },
    destroy() {
        this.clearRecycled(true);
    }
};

const I = ImageManager;

const {IMAGE: IMAGE, create: create$1} = IncrementId;

class LeaferImage {
    get url() {
        return this.config.url;
    }
    get crossOrigin() {
        const {crossOrigin: crossOrigin} = this.config;
        return isUndefined(crossOrigin) ? Platform.image.crossOrigin : crossOrigin;
    }
    get completed() {
        return this.ready || !!this.error;
    }
    constructor(config) {
        this.use = 0;
        this.waitComplete = [];
        this.innerId = create$1(IMAGE);
        this.config = config || (config = {
            url: ""
        });
        if (config.view) {
            const {view: view} = config;
            this.setView(view.config ? view.view : view);
        }
        ImageManager.isFormat("svg", config) && (this.isSVG = true);
        ImageManager.hasAlphaPixel(config) && (this.hasAlphaPixel = true);
    }
    load(onSuccess, onError, thumbSize) {
        if (!this.loading) {
            this.loading = true;
            Resource.tasker.add(() => __awaiter(this, void 0, void 0, function*() {
                return yield Platform.origin.loadImage(this.getLoadUrl(thumbSize), this.crossOrigin, this).then(img => {
                    if (thumbSize) this.setThumbView(img);
                    this.setView(img);
                }).catch(e => {
                    this.error = e;
                    this.onComplete(false);
                });
            }));
        }
        this.waitComplete.push(onSuccess, onError);
        return this.waitComplete.length - 2;
    }
    unload(index, stopEvent) {
        const l = this.waitComplete;
        if (stopEvent) {
            const error = l[index + 1];
            if (error) error({
                type: "stop"
            });
        }
        l[index] = l[index + 1] = undefined;
    }
    setView(img) {
        this.ready = true;
        if (!this.width) {
            this.width = img.width;
            this.height = img.height;
            this.view = img;
        }
        this.onComplete(true);
    }
    onComplete(isSuccess) {
        let odd;
        this.waitComplete.forEach((item, index) => {
            odd = index % 2;
            if (item) {
                if (isSuccess) {
                    if (!odd) item(this);
                } else {
                    if (odd) item(this.error);
                }
            }
        });
        this.waitComplete.length = 0;
        this.loading = false;
    }
    getFull(_filters) {
        return this.view;
    }
    getCanvas(width, height, opacity, filters, xGap, yGap, smooth, interlace) {
        width || (width = this.width);
        height || (height = this.height);
        if (this.cache) {
            let {params: params, data: data} = this.cache;
            for (let i in params) {
                if (params[i] !== arguments[i]) {
                    data = null;
                    break;
                }
            }
            if (data) return data;
        }
        const canvas = Platform.image.resize(this.view, width, height, xGap, yGap, undefined, smooth, opacity, filters, interlace);
        this.cache = this.use > 1 ? {
            data: canvas,
            params: arguments
        } : null;
        return canvas;
    }
    getPattern(canvas, repeat, transform, paint) {
        const pattern = Platform.canvas.createPattern(canvas, repeat);
        Platform.image.setPatternTransform(pattern, transform, paint);
        return pattern;
    }
    getLoadUrl(_thumbSize) {
        return this.url;
    }
    setThumbView(_view) {}
    getThumbSize(_lod) {
        return undefined;
    }
    getMinLevel() {
        return undefined;
    }
    getLevelData(_level, _width, _height) {
        return undefined;
    }
    clearLevels(_checkUse) {}
    destroy() {
        this.clearLevels();
        const {view: view} = this;
        if (view && view.close) view.close();
        this.config = {
            url: ""
        };
        this.cache = this.view = null;
        this.waitComplete.length = 0;
    }
}

function defineKey(target, key, descriptor, noConfigurable) {
    if (!noConfigurable) descriptor.configurable = descriptor.enumerable = true;
    Object.defineProperty(target, key, descriptor);
}

function getDescriptor(object, name) {
    return Object.getOwnPropertyDescriptor(object, name);
}

function createDescriptor(key, defaultValue) {
    const privateKey = "_" + key;
    return {
        get() {
            const v = this[privateKey];
            return v == null ? defaultValue : v;
        },
        set(value) {
            this[privateKey] = value;
        }
    };
}

function getNames(object) {
    return Object.getOwnPropertyNames(object);
}

function decorateLeafAttr(defaultValue, descriptorFn) {
    return (target, key) => defineLeafAttr(target, key, defaultValue, descriptorFn && descriptorFn(key));
}

function attr(partDescriptor) {
    return partDescriptor;
}

function defineLeafAttr(target, key, defaultValue, partDescriptor) {
    const defaultDescriptor = {
        get() {
            return this.__getAttr(key);
        },
        set(value) {
            this.__setAttr(key, value);
        }
    };
    defineKey(target, key, Object.assign(defaultDescriptor, partDescriptor || {}));
    defineDataProcessor(target, key, defaultValue);
}

function dataType(defaultValue) {
    return decorateLeafAttr(defaultValue);
}

function positionType(defaultValue, checkFiniteNumber) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.matrixChanged || this.__layout.matrixChange());
        }
    }));
}

function scrollType(defaultValue, checkFiniteNumber) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value, checkFiniteNumber)) {
                this.__layout.matrixChanged || this.__layout.matrixChange();
                this.__scrollWorld || (this.__scrollWorld = {});
            }
        }
    }));
}

function autoLayoutType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                this.__hasAutoLayout = !!(this.origin || this.around || this.flow);
                if (!this.__local) this.__layout.createLocal();
                doBoundsType(this);
            }
        }
    }));
}

function scaleType(defaultValue, checkFiniteNumber) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.scaleChanged || this.__layout.scaleChange());
        }
    }));
}

function rotationType(defaultValue, checkFiniteNumber) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.rotationChanged || this.__layout.rotationChange());
        }
    }));
}

function boundsType(defaultValue, checkFiniteNumber) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value, checkFiniteNumber) && doBoundsType(this);
        }
    }));
}

function naturalBoundsType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value) && (doBoundsType(this), this.__.__removeNaturalSize());
        }
    }));
}

function doBoundsType(leaf) {
    leaf.__layout.boxChanged || leaf.__layout.boxChange();
    if (leaf.__hasAutoLayout) leaf.__layout.matrixChanged || leaf.__layout.matrixChange();
}

function pathInputType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            const data = this.__;
            if (data.__pathInputed !== 2) data.__pathInputed = value ? 1 : 0;
            if (!value) data.__pathForRender = undefined;
            this.__setAttr(key, value);
            doBoundsType(this);
        }
    }));
}

const pathType = boundsType;

function affectStrokeBoundsType(defaultValue, useStroke) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                doStrokeType(this);
                if (useStroke) this.__.__useStroke = true;
            }
        }
    }));
}

function doStrokeType(leaf) {
    leaf.__layout.strokeChanged || leaf.__layout.strokeChange();
    if (leaf.__.__useArrow) doBoundsType(leaf);
}

const strokeType = affectStrokeBoundsType;

function affectRenderBoundsType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value);
            this.__layout.renderChanged || this.__layout.renderChange();
        }
    }));
}

function surfaceType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value) && (this.__layout.surfaceChanged || this.__layout.surfaceChange());
        }
    }));
}

function dimType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                const data = this.__;
                DataHelper.stintSet(data, "__useDim", data.dim || data.bright || data.dimskip);
                this.__layout.surfaceChange();
            }
        }
    }));
}

function opacityType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value) && (this.__layout.opacityChanged || this.__layout.opacityChange());
            if (this.mask) checkMask$1(this);
        }
    }));
}

function visibleType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            const oldValue = this.visible;
            if (oldValue === true && value === 0) {
                if (this.animationOut) return this.__runAnimation("out", () => doVisible(this, key, value, oldValue));
            } else if (oldValue === 0 && value === true) {
                if (this.animation) this.__runAnimation("in");
            }
            doVisible(this, key, value, oldValue);
            if (this.mask) checkMask$1(this);
        }
    }));
}

function checkMask$1(leaf) {
    const {parent: parent} = leaf;
    if (parent) {
        const {__hasMask: __hasMask} = parent;
        parent.__updateMask();
        if (__hasMask !== parent.__hasMask) parent.forceUpdate();
    }
}

function doVisible(leaf, key, value, oldValue) {
    if (leaf.__setAttr(key, value)) {
        leaf.__layout.opacityChanged || leaf.__layout.opacityChange();
        if (oldValue === 0 || value === 0) doBoundsType(leaf);
    }
}

function sortType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                this.__layout.surfaceChange();
                this.waitParent(() => {
                    this.parent.__layout.childrenSortChange();
                });
            }
        }
    }));
}

function maskType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                this.__layout.boxChanged || this.__layout.boxChange();
                this.waitParent(() => {
                    this.parent.__updateMask(value);
                });
            }
        }
    }));
}

function eraserType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value) && this.waitParent(() => {
                this.parent.__updateEraser(value);
            });
        }
    }));
}

function hitType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            if (this.__setAttr(key, value)) {
                this.__layout.hitCanvasChanged = true;
                if (Debug.showBounds === "hit") this.__layout.surfaceChange();
                if (this.leafer) this.leafer.updateCursor();
            }
        }
    }));
}

function cursorType(defaultValue) {
    return decorateLeafAttr(defaultValue, key => attr({
        set(value) {
            this.__setAttr(key, value);
            if (this.leafer) this.leafer.updateCursor();
        }
    }));
}

function dataProcessor(processor) {
    return (target, _key) => {
        defineKey(target, "__DataProcessor", {
            get() {
                return processor;
            }
        });
    };
}

function layoutProcessor(processor) {
    return (target, _key) => {
        defineKey(target, "__LayoutProcessor", {
            get() {
                return processor;
            }
        });
    };
}

function getSetMethodName(key) {
    return "set" + key.charAt(0).toUpperCase() + key.slice(1);
}

function defineDataProcessor(target, key, defaultValue) {
    const data = target.__DataProcessor.prototype;
    const computedKey = "_" + key;
    const setMethodName = getSetMethodName(key);
    const property = createDescriptor(key, defaultValue);
    if (isUndefined(defaultValue)) {
        property.get = function() {
            return this[computedKey];
        };
    } else if (typeof defaultValue === "function") {
        property.get = function() {
            const v = this[computedKey];
            return v == null ? defaultValue(this.__leaf) : v;
        };
    } else if (isObject(defaultValue)) {
        const isEmpty = isEmptyData(defaultValue);
        property.get = function() {
            const v = this[computedKey];
            return v == null ? this[computedKey] = isEmpty ? {} : DataHelper.clone(defaultValue) : v;
        };
    }
    const isBox = target.isBranchLeaf;
    if (key === "width") {
        property.get = function() {
            const v = this[computedKey];
            if (v == null) {
                const t = this, naturalWidth = t.__naturalWidth, leaf = t.__leaf;
                if (!defaultValue || leaf.pathInputed) return leaf.boxBounds.width;
                if (naturalWidth) return t._height && t.__useNaturalRatio ? t._height * naturalWidth / t.__naturalHeight : naturalWidth;
                return isBox && leaf.children.length ? leaf.boxBounds.width : defaultValue;
            } else return v;
        };
    } else if (key === "height") {
        property.get = function() {
            const v = this[computedKey];
            if (v == null) {
                const t = this, naturalHeight = t.__naturalHeight, leaf = t.__leaf;
                if (!defaultValue || leaf.pathInputed) return leaf.boxBounds.height;
                if (naturalHeight) return t._width && t.__useNaturalRatio ? t._width * naturalHeight / t.__naturalWidth : naturalHeight;
                return isBox && leaf.children.length ? leaf.boxBounds.height : defaultValue;
            } else return v;
        };
    }
    let descriptor, find = data;
    while (!descriptor && find) {
        descriptor = getDescriptor(find, key);
        find = find.__proto__;
    }
    if (descriptor && descriptor.set) property.set = descriptor.set;
    if (data[setMethodName]) {
        property.set = data[setMethodName];
        delete data[setMethodName];
    }
    defineKey(data, key, property);
}

const debug$2 = new Debug("rewrite");

const list = [];

const excludeNames = [ "destroy", "constructor" ];

function rewrite(method) {
    return (target, key) => {
        list.push({
            name: target.constructor.name + "." + key,
            run: () => {
                target[key] = method;
            }
        });
    };
}

function rewriteAble() {
    return _target => {
        doRewrite();
    };
}

function doRewrite(error) {
    if (list.length) {
        list.forEach(item => {
            if (error) debug$2.error(item.name, "Class@rewriteAble()");
            item.run();
        });
        list.length = 0;
    }
}

setTimeout(() => doRewrite(true));

function useModule(module, exclude) {
    return target => {
        const names = module.prototype ? getNames(module.prototype) : Object.keys(module);
        names.forEach(name => {
            if (!excludeNames.includes(name) && (!exclude || !exclude.includes(name))) {
                if (module.prototype) {
                    const d = getDescriptor(module.prototype, name);
                    if (d.writable) target.prototype[name] = module.prototype[name];
                } else {
                    target.prototype[name] = module[name];
                }
            }
        });
    };
}

function registerUI() {
    return target => {
        UICreator.register(target);
    };
}

function registerUIEvent() {
    return target => {
        EventCreator.register(target);
    };
}

const {copy: copy$3, toInnerPoint: toInnerPoint$1, toOuterPoint: toOuterPoint$1, scaleOfOuter: scaleOfOuter, rotateOfOuter: rotateOfOuter, skewOfOuter: skewOfOuter, multiplyParent: multiplyParent$2, divideParent: divideParent, getLayout: getLayout} = MatrixHelper;

const matrix = {}, {round: round} = Math;

const LeafHelper = {
    updateAllMatrix(leaf, checkAutoLayout, waitAutoLayout) {
        if (checkAutoLayout && leaf.__hasAutoLayout && leaf.__layout.matrixChanged) waitAutoLayout = true;
        updateMatrix$1(leaf, checkAutoLayout, waitAutoLayout);
        if (leaf.isBranch) {
            const {children: children} = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllMatrix$1(children[i], checkAutoLayout, waitAutoLayout);
            }
        }
    },
    updateMatrix(leaf, checkAutoLayout, waitAutoLayout) {
        const layout = leaf.__layout;
        if (checkAutoLayout) {
            if (waitAutoLayout) {
                layout.waitAutoLayout = true;
                if (leaf.__hasAutoLayout) layout.matrixChanged = false;
            }
        } else if (layout.waitAutoLayout) {
            layout.waitAutoLayout = false;
        }
        if (layout.matrixChanged) leaf.__updateLocalMatrix();
        if (!layout.waitAutoLayout) leaf.__updateWorldMatrix();
    },
    updateBounds(leaf) {
        const layout = leaf.__layout;
        if (layout.boundsChanged) leaf.__updateLocalBounds();
        if (!layout.waitAutoLayout) leaf.__updateWorldBounds();
    },
    updateAllWorldOpacity(leaf) {
        leaf.__updateWorldOpacity();
        if (leaf.isBranch) {
            const {children: children} = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllWorldOpacity(children[i]);
            }
        }
    },
    updateChange(leaf) {
        const layout = leaf.__layout;
        if (layout.stateStyleChanged) leaf.updateState();
        if (layout.opacityChanged) updateAllWorldOpacity(leaf);
        leaf.__updateChange();
    },
    updateAllChange(leaf) {
        updateChange(leaf);
        if (leaf.isBranch) {
            const {children: children} = leaf;
            for (let i = 0, len = children.length; i < len; i++) {
                updateAllChange(children[i]);
            }
        }
    },
    worldHittable(t) {
        while (t) {
            if (!t.__.hittable) return false;
            t = t.parent;
        }
        return true;
    },
    draggable(t) {
        return (t.draggable || t.editable) && t.hitSelf && !t.locked;
    },
    copyCanvasByWorld(leaf, currentCanvas, fromCanvas, fromWorld, blendMode, onlyResetTransform) {
        if (!fromWorld) fromWorld = leaf.__nowWorld;
        if (leaf.__worldFlipped || Platform.fullImageShadow) currentCanvas.copyWorldByReset(fromCanvas, fromWorld, leaf.__nowWorld, blendMode, onlyResetTransform); else currentCanvas.copyWorldToInner(fromCanvas, fromWorld, leaf.__layout.renderBounds, blendMode);
    },
    moveWorld(t, x, y = 0, isInnerPoint, transition) {
        const local = isObject(x) ? Object.assign({}, x) : {
            x: x,
            y: y
        };
        isInnerPoint ? toOuterPoint$1(t.localTransform, local, local, true) : t.parent && toInnerPoint$1(t.parent.scrollWorldTransform, local, local, true);
        L.moveLocal(t, local.x, local.y, transition);
    },
    moveLocal(t, x, y = 0, transition) {
        if (isObject(x)) y = x.y, x = x.x;
        x += t.x;
        y += t.y;
        if (t.leafer && t.leafer.config.pointSnap) x = round(x), y = round(y);
        transition ? t.animate({
            x: x,
            y: y
        }, transition) : (t.x = x, t.y = y);
    },
    zoomOfWorld(t, origin, scaleX, scaleY, resize, transition) {
        L.zoomOfLocal(t, getTempLocal(t, origin), scaleX, scaleY, resize, transition);
    },
    zoomOfLocal(t, origin, scaleX, scaleY = scaleX, resize, transition) {
        const o = t.__localMatrix;
        if (!isNumber(scaleY)) {
            if (scaleY) transition = scaleY;
            scaleY = scaleX;
        }
        copy$3(matrix, o);
        scaleOfOuter(matrix, origin, scaleX, scaleY);
        if (L.hasHighPosition(t)) {
            L.setTransform(t, matrix, resize, transition);
        } else {
            const x = t.x + matrix.e - o.e, y = t.y + matrix.f - o.f;
            if (transition && !resize) t.animate({
                x: x,
                y: y,
                scaleX: t.scaleX * scaleX,
                scaleY: t.scaleY * scaleY
            }, transition); else t.x = x, t.y = y, t.scaleResize(scaleX, scaleY, resize !== true);
        }
    },
    rotateOfWorld(t, origin, angle, transition) {
        L.rotateOfLocal(t, getTempLocal(t, origin), angle, transition);
    },
    rotateOfLocal(t, origin, angle, transition) {
        const o = t.__localMatrix;
        copy$3(matrix, o);
        rotateOfOuter(matrix, origin, angle);
        if (L.hasHighPosition(t)) L.setTransform(t, matrix, false, transition); else t.set({
            x: t.x + matrix.e - o.e,
            y: t.y + matrix.f - o.f,
            rotation: MathHelper.formatRotation(t.rotation + angle)
        }, transition);
    },
    skewOfWorld(t, origin, skewX, skewY, resize, transition) {
        L.skewOfLocal(t, getTempLocal(t, origin), skewX, skewY, resize, transition);
    },
    skewOfLocal(t, origin, skewX, skewY = 0, resize, transition) {
        copy$3(matrix, t.__localMatrix);
        skewOfOuter(matrix, origin, skewX, skewY);
        L.setTransform(t, matrix, resize, transition);
    },
    transformWorld(t, transform, resize, transition) {
        copy$3(matrix, t.worldTransform);
        multiplyParent$2(matrix, transform);
        if (t.parent) divideParent(matrix, t.parent.scrollWorldTransform);
        L.setTransform(t, matrix, resize, transition);
    },
    transform(t, transform, resize, transition) {
        copy$3(matrix, t.localTransform);
        multiplyParent$2(matrix, transform);
        L.setTransform(t, matrix, resize, transition);
    },
    setTransform(t, transform, resize, transition) {
        const data = t.__, originPoint = data.origin && L.getInnerOrigin(t, data.origin);
        const layout = getLayout(transform, originPoint, data.around && L.getInnerOrigin(t, data.around));
        if (L.hasOffset(t)) {
            layout.x -= data.offsetX;
            layout.y -= data.offsetY;
        }
        if (resize) {
            const scaleX = layout.scaleX / t.scaleX, scaleY = layout.scaleY / t.scaleY;
            delete layout.scaleX, delete layout.scaleY;
            if (originPoint) {
                BoundsHelper.scale(t.boxBounds, Math.abs(scaleX), Math.abs(scaleY));
                const changedPoint = L.getInnerOrigin(t, data.origin);
                PointHelper.move(layout, originPoint.x - changedPoint.x, originPoint.y - changedPoint.y);
            }
            t.set(layout);
            t.scaleResize(scaleX, scaleY, false);
        } else t.set(layout, transition);
    },
    getFlipTransform(t, axis) {
        const m = getMatrixData();
        const sign = axis === "x" ? 1 : -1;
        scaleOfOuter(m, L.getLocalOrigin(t, "center"), -1 * sign, 1 * sign);
        return m;
    },
    getLocalOrigin(t, origin) {
        return PointHelper.tempToOuterOf(L.getInnerOrigin(t, origin), t.localTransform);
    },
    getInnerOrigin(t, origin) {
        const innerOrigin = {};
        AroundHelper.toPoint(origin, t.boxBounds, innerOrigin);
        return innerOrigin;
    },
    getRelativeWorld(t, relative, temp) {
        copy$3(matrix, t.worldTransform);
        divideParent(matrix, relative.scrollWorldTransform);
        return temp ? matrix : Object.assign({}, matrix);
    },
    drop(t, parent, index, resize) {
        t.setTransform(L.getRelativeWorld(t, parent, true), resize);
        parent.add(t, index);
    },
    hasHighPosition(t) {
        return t.origin || t.around || L.hasOffset(t);
    },
    hasOffset(t) {
        return t.offsetX || t.offsetY;
    },
    hasParent(p, parent) {
        if (!parent) return false;
        while (p) {
            if (parent === p) return true;
            p = p.parent;
        }
    },
    animateMove(t, move, speed = .3) {
        if (!move.x && !move.y) return;
        if (Math.abs(move.x) < 1 && Math.abs(move.y) < 1) {
            t.move(move);
        } else {
            const x = move.x * speed, y = move.y * speed;
            move.x -= x, move.y -= y;
            t.move(x, y);
            Platform.requestRender(() => L.animateMove(t, move, speed));
        }
    }
};

const L = LeafHelper;

const {updateAllMatrix: updateAllMatrix$1, updateMatrix: updateMatrix$1, updateAllWorldOpacity: updateAllWorldOpacity, updateAllChange: updateAllChange, updateChange: updateChange} = L;

function getTempLocal(t, worldPoint) {
    t.updateLayout();
    return t.parent ? PointHelper.tempToInnerOf(worldPoint, t.parent.scrollWorldTransform) : worldPoint;
}

const LeafBoundsHelper = {
    worldBounds(target) {
        return target.__world;
    },
    localBoxBounds(target) {
        return target.__.eraser || target.__.visible === 0 ? null : target.__local || target.__layout;
    },
    localStrokeBounds(target) {
        return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localStrokeBounds;
    },
    localRenderBounds(target) {
        return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localRenderBounds;
    },
    maskLocalBoxBounds(target, index) {
        return checkMask(target, index) && target.__localBoxBounds;
    },
    maskLocalStrokeBounds(target, index) {
        return checkMask(target, index) && target.__layout.localStrokeBounds;
    },
    maskLocalRenderBounds(target, index) {
        return checkMask(target, index) && target.__layout.localRenderBounds;
    },
    excludeRenderBounds(child, options) {
        if (options.bounds && !options.bounds.hit(child.__world, options.matrix)) return true;
        if (options.hideBounds && options.hideBounds.includes(child.__world, options.matrix)) return true;
        return false;
    }
};

let findMask;

function checkMask(target, index) {
    if (!index) findMask = 0;
    if (target.__.mask) findMask = 1;
    return findMask < 0 ? null : (findMask && (findMask = -1), true);
}

const {updateBounds: updateBounds$2} = LeafHelper;

const BranchHelper = {
    sort(a, b) {
        return a.__.zIndex === b.__.zIndex ? a.__tempNumber - b.__tempNumber : a.__.zIndex - b.__.zIndex;
    },
    pushAllChildBranch(branch, leafList) {
        branch.__tempNumber = 1;
        if (branch.__.__childBranchNumber) {
            const {children: children} = branch;
            for (let i = 0, len = children.length; i < len; i++) {
                branch = children[i];
                if (branch.isBranch) {
                    branch.__tempNumber = 1;
                    leafList.add(branch);
                    pushAllChildBranch(branch, leafList);
                }
            }
        }
    },
    pushAllParent(leaf, leafList) {
        const {keys: keys} = leafList;
        if (keys) {
            while (leaf.parent) {
                if (isUndefined(keys[leaf.parent.innerId])) {
                    leafList.add(leaf.parent);
                    leaf = leaf.parent;
                } else {
                    break;
                }
            }
        } else {
            while (leaf.parent) {
                leafList.add(leaf.parent);
                leaf = leaf.parent;
            }
        }
    },
    pushAllBranchStack(branch, pushList) {
        let start = pushList.length;
        const {children: children} = branch;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].isBranch) {
                pushList.push(children[i]);
            }
        }
        for (let i = start, len = pushList.length; i < len; i++) {
            pushAllBranchStack(pushList[i], pushList);
        }
    },
    updateBounds(branch, exclude) {
        const branchStack = [ branch ];
        pushAllBranchStack(branch, branchStack);
        updateBoundsByBranchStack(branchStack, exclude);
    },
    updateBoundsByBranchStack(branchStack, exclude) {
        let branch, children;
        for (let i = branchStack.length - 1; i > -1; i--) {
            branch = branchStack[i];
            children = branch.children;
            for (let j = 0, len = children.length; j < len; j++) {
                updateBounds$2(children[j]);
            }
            if (exclude && exclude === branch) continue;
            updateBounds$2(branch);
        }
    },
    move(branch, x, y) {
        let w;
        const {children: children} = branch;
        for (let i = 0, len = children.length; i < len; i++) {
            branch = children[i];
            w = branch.__world;
            w.e += x;
            w.f += y;
            w.x += x;
            w.y += y;
            if (branch.isBranch) move$1(branch, x, y);
        }
    },
    scale(branch, x, y, scaleX, scaleY, a, b) {
        let w;
        const {children: children} = branch;
        const changeScaleX = scaleX - 1;
        const changeScaleY = scaleY - 1;
        for (let i = 0, len = children.length; i < len; i++) {
            branch = children[i];
            w = branch.__world;
            w.a *= scaleX;
            w.d *= scaleY;
            if (w.b || w.c) {
                w.b *= scaleX;
                w.c *= scaleY;
            }
            if (w.e === w.x && w.f === w.y) {
                w.x = w.e += (w.e - a) * changeScaleX + x;
                w.y = w.f += (w.f - b) * changeScaleY + y;
            } else {
                w.e += (w.e - a) * changeScaleX + x;
                w.f += (w.f - b) * changeScaleY + y;
                w.x += (w.x - a) * changeScaleX + x;
                w.y += (w.y - b) * changeScaleY + y;
            }
            w.width *= scaleX;
            w.height *= scaleY;
            w.scaleX *= scaleX;
            w.scaleY *= scaleY;
            if (branch.isBranch) scale(branch, x, y, scaleX, scaleY, a, b);
        }
    }
};

const {pushAllChildBranch: pushAllChildBranch, pushAllBranchStack: pushAllBranchStack, updateBoundsByBranchStack: updateBoundsByBranchStack, move: move$1, scale: scale} = BranchHelper;

const WaitHelper = {
    run(wait) {
        if (wait && wait.length) {
            const len = wait.length;
            for (let i = 0; i < len; i++) {
                wait[i]();
            }
            wait.length === len ? wait.length = 0 : wait.splice(0, len);
        }
    }
};

const {getRelativeWorld: getRelativeWorld$1, updateBounds: updateBounds$1} = LeafHelper;

const {toOuterOf: toOuterOf$2, getPoints: getPoints, copy: copy$2} = BoundsHelper;

const localContent = "_localContentBounds";

const worldContent = "_worldContentBounds", worldBox = "_worldBoxBounds", worldStroke = "_worldStrokeBounds";

class LeafLayout {
    get contentBounds() {
        return this._contentBounds || this.boxBounds;
    }
    set contentBounds(bounds) {
        this._contentBounds = bounds;
    }
    get strokeBounds() {
        return this._strokeBounds || this.boxBounds;
    }
    get renderBounds() {
        return this._renderBounds || this.boxBounds;
    }
    set renderBounds(bounds) {
        this._renderBounds = bounds;
    }
    get localContentBounds() {
        toOuterOf$2(this.contentBounds, this.leaf.__localMatrix, this[localContent] || (this[localContent] = {}));
        return this[localContent];
    }
    get localStrokeBounds() {
        return this._localStrokeBounds || this;
    }
    get localRenderBounds() {
        return this._localRenderBounds || this;
    }
    get worldContentBounds() {
        toOuterOf$2(this.contentBounds, this.leaf.__world, this[worldContent] || (this[worldContent] = {}));
        return this[worldContent];
    }
    get worldBoxBounds() {
        toOuterOf$2(this.boxBounds, this.leaf.__world, this[worldBox] || (this[worldBox] = {}));
        return this[worldBox];
    }
    get worldStrokeBounds() {
        toOuterOf$2(this.strokeBounds, this.leaf.__world, this[worldStroke] || (this[worldStroke] = {}));
        return this[worldStroke];
    }
    get a() {
        return 1;
    }
    get b() {
        return 0;
    }
    get c() {
        return 0;
    }
    get d() {
        return 1;
    }
    get e() {
        return this.leaf.__.x;
    }
    get f() {
        return this.leaf.__.y;
    }
    get x() {
        return this.e + this.boxBounds.x;
    }
    get y() {
        return this.f + this.boxBounds.y;
    }
    get width() {
        return this.boxBounds.width;
    }
    get height() {
        return this.boxBounds.height;
    }
    constructor(leaf) {
        this.leaf = leaf;
        if (this.leaf.__local) this._localRenderBounds = this._localStrokeBounds = this.leaf.__local;
        if (leaf.__world) {
            this.boxBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.boxChange();
            this.matrixChange();
        }
    }
    createLocal() {
        const local = this.leaf.__local = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        if (!this._localStrokeBounds) this._localStrokeBounds = local;
        if (!this._localRenderBounds) this._localRenderBounds = local;
    }
    update() {
        const {leaf: leaf} = this, {leafer: leafer} = leaf;
        if (leaf.isApp) return updateBounds$1(leaf);
        if (leafer) {
            if (leafer.ready) leafer.watcher.changed && leafer.layouter.layout(); else leafer.start();
        } else {
            let root = leaf;
            while (root.parent && !root.parent.leafer) {
                root = root.parent;
            }
            const r = root;
            if (r.__fullLayouting) return;
            r.__fullLayouting = true;
            Platform.layout(r);
            delete r.__fullLayouting;
        }
    }
    getTransform(relative = "world") {
        this.update();
        const {leaf: leaf} = this;
        switch (relative) {
          case "world":
            return leaf.__world;

          case "local":
            return leaf.__localMatrix;

          case "inner":
            return MatrixHelper.defaultMatrix;

          case "page":
            relative = leaf.zoomLayer;

          default:
            return getRelativeWorld$1(leaf, relative);
        }
    }
    getBounds(type, relative = "world") {
        this.update();
        switch (relative) {
          case "world":
            return this.getWorldBounds(type);

          case "local":
            return this.getLocalBounds(type);

          case "inner":
            return this.getInnerBounds(type);

          case "page":
            relative = this.leaf.zoomLayer;

          default:
            return new Bounds(this.getInnerBounds(type)).toOuterOf(this.getTransform(relative));
        }
    }
    getInnerBounds(type = "box") {
        switch (type) {
          case "render":
            return this.renderBounds;

          case "content":
            if (this.contentBounds) return this.contentBounds;

          case "box":
            return this.boxBounds;

          case "stroke":
            return this.strokeBounds;
        }
    }
    getLocalBounds(type = "box") {
        switch (type) {
          case "render":
            return this.localRenderBounds;

          case "stroke":
            return this.localStrokeBounds;

          case "content":
            if (this.contentBounds) return this.localContentBounds;

          case "box":
            return this.leaf.__localBoxBounds;
        }
    }
    getWorldBounds(type = "box") {
        switch (type) {
          case "render":
            return this.leaf.__world;

          case "stroke":
            return this.worldStrokeBounds;

          case "content":
            if (this.contentBounds) return this.worldContentBounds;

          case "box":
            return this.worldBoxBounds;
        }
    }
    getLayoutBounds(type, relative = "world", unscale) {
        const {leaf: leaf} = this;
        let point, matrix, layoutBounds, bounds = this.getInnerBounds(type);
        switch (relative) {
          case "world":
            point = leaf.getWorldPoint(bounds);
            matrix = leaf.__world;
            break;

          case "local":
            const {scaleX: scaleX, scaleY: scaleY, rotation: rotation, skewX: skewX, skewY: skewY} = leaf.__;
            layoutBounds = {
                scaleX: scaleX,
                scaleY: scaleY,
                rotation: rotation,
                skewX: skewX,
                skewY: skewY
            };
            point = leaf.getLocalPointByInner(bounds);
            break;

          case "inner":
            point = bounds;
            matrix = MatrixHelper.defaultMatrix;
            break;

          case "page":
            relative = leaf.zoomLayer;

          default:
            point = leaf.getWorldPoint(bounds, relative);
            matrix = getRelativeWorld$1(leaf, relative, true);
        }
        if (!layoutBounds) layoutBounds = MatrixHelper.getLayout(matrix);
        copy$2(layoutBounds, bounds);
        PointHelper.copy(layoutBounds, point);
        if (unscale) {
            const {scaleX: scaleX, scaleY: scaleY} = layoutBounds;
            const uScaleX = Math.abs(scaleX);
            const uScaleY = Math.abs(scaleY);
            if (uScaleX !== 1 || uScaleY !== 1) {
                layoutBounds.scaleX /= uScaleX;
                layoutBounds.scaleY /= uScaleY;
                layoutBounds.width *= uScaleX;
                layoutBounds.height *= uScaleY;
            }
        }
        return layoutBounds;
    }
    getLayoutPoints(type, relative = "world") {
        const {leaf: leaf} = this;
        const points = getPoints(this.getInnerBounds(type));
        let relativeLeaf;
        switch (relative) {
          case "world":
            relativeLeaf = null;
            break;

          case "local":
            relativeLeaf = leaf.parent;
            break;

          case "inner":
            break;

          case "page":
            relative = leaf.zoomLayer;

          default:
            relativeLeaf = relative;
        }
        if (!isUndefined(relativeLeaf)) points.forEach(point => leaf.innerToWorld(point, null, false, relativeLeaf));
        return points;
    }
    shrinkContent() {
        const {x: x, y: y, width: width, height: height} = this.boxBounds;
        this._contentBounds = {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
    spreadStroke() {
        const {x: x, y: y, width: width, height: height} = this.strokeBounds;
        this._strokeBounds = {
            x: x,
            y: y,
            width: width,
            height: height
        };
        this._localStrokeBounds = {
            x: x,
            y: y,
            width: width,
            height: height
        };
        if (!this.renderSpread) this.spreadRenderCancel();
    }
    spreadRender() {
        const {x: x, y: y, width: width, height: height} = this.renderBounds;
        this._renderBounds = {
            x: x,
            y: y,
            width: width,
            height: height
        };
        this._localRenderBounds = {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
    shrinkContentCancel() {
        this._contentBounds = undefined;
    }
    spreadStrokeCancel() {
        const same = this.renderBounds === this.strokeBounds;
        this._strokeBounds = this.boxBounds;
        this._localStrokeBounds = this.leaf.__localBoxBounds;
        if (same) this.spreadRenderCancel();
    }
    spreadRenderCancel() {
        this._renderBounds = this._strokeBounds;
        this._localRenderBounds = this._localStrokeBounds;
    }
    boxChange() {
        this.boxChanged = true;
        this.localBoxChanged ? this.boundsChanged || (this.boundsChanged = true) : this.localBoxChange();
        this.hitCanvasChanged = true;
    }
    localBoxChange() {
        this.localBoxChanged = true;
        this.boundsChanged = true;
    }
    strokeChange() {
        this.strokeChanged = true;
        this.strokeSpread || (this.strokeSpread = 1);
        this.boundsChanged = true;
        this.hitCanvasChanged = true;
    }
    renderChange() {
        this.renderChanged = true;
        this.renderSpread || (this.renderSpread = 1);
        this.boundsChanged = true;
    }
    scaleChange() {
        this.scaleChanged = true;
        this._scaleOrRotationChange();
    }
    rotationChange() {
        this.rotationChanged = true;
        this.affectRotation = true;
        this._scaleOrRotationChange();
    }
    _scaleOrRotationChange() {
        this.affectScaleOrRotation = true;
        this.matrixChange();
        if (!this.leaf.__local) this.createLocal();
    }
    matrixChange() {
        this.matrixChanged = true;
        this.localBoxChanged ? this.boundsChanged || (this.boundsChanged = true) : this.localBoxChange();
    }
    surfaceChange() {
        this.surfaceChanged = true;
    }
    opacityChange() {
        this.opacityChanged = true;
        this.surfaceChanged || this.surfaceChange();
    }
    childrenSortChange() {
        if (!this.childrenSortChanged) {
            this.childrenSortChanged = this.affectChildrenSort = true;
            this.leaf.forceUpdate("surface");
        }
    }
    destroy() {}
}

class Event {
    constructor(type, target) {
        this.bubbles = false;
        this.type = type;
        if (target) this.target = target;
    }
    stopDefault() {
        this.isStopDefault = true;
        if (this.origin) Platform.event.stopDefault(this.origin);
    }
    stopNow() {
        this.isStopNow = true;
        this.isStop = true;
        if (this.origin) Platform.event.stopNow(this.origin);
    }
    stop() {
        this.isStop = true;
        if (this.origin) Platform.event.stop(this.origin);
    }
}

class ChildEvent extends Event {
    constructor(type, child, parent) {
        super(type, child);
        this.parent = parent;
        this.child = child;
    }
}

ChildEvent.ADD = "child.add";

ChildEvent.REMOVE = "child.remove";

ChildEvent.CREATED = "created";

ChildEvent.MOUNTED = "mounted";

ChildEvent.UNMOUNTED = "unmounted";

ChildEvent.DESTROY = "destroy";

const SCROLL = "property.scroll";

class PropertyEvent extends Event {
    constructor(type, target, attrName, oldValue, newValue) {
        super(type, target);
        this.attrName = attrName;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }
}

PropertyEvent.CHANGE = "property.change";

PropertyEvent.LEAFER_CHANGE = "property.leafer_change";

PropertyEvent.SCROLL = SCROLL;

const extraPropertyEventMap = {
    scrollX: SCROLL,
    scrollY: SCROLL
};

class ImageEvent extends Event {
    constructor(type, data) {
        super(type);
        Object.assign(this, data);
    }
}

ImageEvent.LOAD = "image.load";

ImageEvent.LOADED = "image.loaded";

ImageEvent.ERROR = "image.error";

class BoundsEvent extends Event {
    static checkHas(leaf, type, mode) {
        if (mode === "on") {
            type === WORLD ? leaf.__hasWorldEvent = true : leaf.__hasLocalEvent = true;
        } else {
            leaf.__hasLocalEvent = leaf.hasEvent(RESIZE) || leaf.hasEvent(INNER) || leaf.hasEvent(LOCAL);
            leaf.__hasWorldEvent = leaf.hasEvent(WORLD);
        }
    }
    static emitLocal(leaf) {
        if (leaf.leaferIsReady) {
            const {resized: resized} = leaf.__layout;
            if (resized !== "local") {
                leaf.emit(RESIZE, leaf);
                if (resized === "inner") leaf.emit(INNER, leaf);
            }
            leaf.emit(LOCAL, leaf);
        }
    }
    static emitWorld(leaf) {
        if (leaf.leaferIsReady) leaf.emit(WORLD, this);
    }
}

BoundsEvent.RESIZE = "bounds.resize";

BoundsEvent.INNER = "bounds.inner";

BoundsEvent.LOCAL = "bounds.local";

BoundsEvent.WORLD = "bounds.world";

const {RESIZE: RESIZE, INNER: INNER, LOCAL: LOCAL, WORLD: WORLD} = BoundsEvent;

const boundsEventMap = {};

[ RESIZE, INNER, LOCAL, WORLD ].forEach(key => boundsEventMap[key] = 1);

class ResizeEvent extends Event {
    get bigger() {
        if (!this.old) return true;
        const {width: width, height: height} = this.old;
        return this.width >= width && this.height >= height;
    }
    get smaller() {
        return !this.bigger;
    }
    get samePixelRatio() {
        if (!this.old) return true;
        return this.pixelRatio === this.old.pixelRatio;
    }
    constructor(size, oldSize) {
        if (isObject(size)) {
            super(ResizeEvent.RESIZE);
            Object.assign(this, size);
        } else {
            super(size);
        }
        this.old = oldSize;
    }
    static isResizing(leaf) {
        return this.resizingKeys && !isUndefined(this.resizingKeys[leaf.innerId]);
    }
}

ResizeEvent.RESIZE = "resize";

class WatchEvent extends Event {
    constructor(type, data) {
        super(type);
        this.data = data;
    }
}

WatchEvent.REQUEST = "watch.request";

WatchEvent.DATA = "watch.data";

class LayoutEvent extends Event {
    constructor(type, data, times) {
        super(type);
        if (data) {
            this.data = data;
            this.times = times;
        }
    }
}

LayoutEvent.REQUEST = "layout.request";

LayoutEvent.START = "layout.start";

LayoutEvent.BEFORE = "layout.before";

LayoutEvent.LAYOUT = "layout";

LayoutEvent.AFTER = "layout.after";

LayoutEvent.AGAIN = "layout.again";

LayoutEvent.END = "layout.end";

class RenderEvent extends Event {
    constructor(type, times, bounds, options) {
        super(type);
        if (times) this.times = times;
        if (bounds) {
            this.renderBounds = bounds;
            this.renderOptions = options;
        }
    }
}

RenderEvent.REQUEST = "render.request";

RenderEvent.CHILD_START = "render.child_start";

RenderEvent.CHILD_END = "render.child_end";

RenderEvent.START = "render.start";

RenderEvent.BEFORE = "render.before";

RenderEvent.RENDER = "render";

RenderEvent.AFTER = "render.after";

RenderEvent.AGAIN = "render.again";

RenderEvent.END = "render.end";

RenderEvent.NEXT = "render.next";

class LeaferEvent extends Event {}

LeaferEvent.START = "leafer.start";

LeaferEvent.BEFORE_READY = "leafer.before_ready";

LeaferEvent.READY = "leafer.ready";

LeaferEvent.AFTER_READY = "leafer.after_ready";

LeaferEvent.VIEW_READY = "leafer.view_ready";

LeaferEvent.VIEW_COMPLETED = "leafer.view_completed";

LeaferEvent.STOP = "leafer.stop";

LeaferEvent.RESTART = "leafer.restart";

LeaferEvent.END = "leafer.end";

LeaferEvent.UPDATE_MODE = "leafer.update_mode";

LeaferEvent.TRANSFORM = "leafer.transform";

LeaferEvent.MOVE = "leafer.move";

LeaferEvent.SCALE = "leafer.scale";

LeaferEvent.ROTATE = "leafer.rotate";

LeaferEvent.SKEW = "leafer.skew";

const {MOVE: MOVE, SCALE: SCALE, ROTATE: ROTATE, SKEW: SKEW} = LeaferEvent;

const leaferTransformAttrMap = {
    x: MOVE,
    y: MOVE,
    scaleX: SCALE,
    scaleY: SCALE,
    rotation: ROTATE,
    skewX: SKEW,
    skewY: SKEW
};

const empty = {};

class Eventer {
    set event(map) {
        this.on(map);
    }
    on(type, listener, options) {
        if (!listener) {
            let event;
            if (isArray(type)) type.forEach(item => this.on(item[0], item[1], item[2])); else for (let key in type) isArray(event = type[key]) ? this.on(key, event[0], event[1]) : this.on(key, event);
            return;
        }
        let capture, once;
        if (options) {
            if (options === "once") {
                once = true;
            } else if (typeof options === "boolean") {
                capture = options;
            } else {
                capture = options.capture;
                once = options.once;
            }
        }
        let events;
        const map = __getListenerMap(this, capture, true);
        const typeList = isString(type) ? type.split(" ") : type;
        const item = once ? {
            listener: listener,
            once: once
        } : {
            listener: listener
        };
        typeList.forEach(type => {
            if (type) {
                events = map[type];
                if (events) {
                    if (events.findIndex(item => item.listener === listener) === -1) events.push(item);
                } else {
                    map[type] = [ item ];
                }
                if (boundsEventMap[type]) BoundsEvent.checkHas(this, type, "on");
            }
        });
    }
    off(type, listener, options) {
        if (type) {
            const typeList = isString(type) ? type.split(" ") : type;
            if (listener) {
                let capture;
                if (options) capture = typeof options === "boolean" ? options : options === "once" ? false : options.capture;
                let events, index;
                const map = __getListenerMap(this, capture);
                typeList.forEach(type => {
                    if (type) {
                        events = map[type];
                        if (events) {
                            index = events.findIndex(item => item.listener === listener);
                            if (index > -1) events.splice(index, 1);
                            if (!events.length) delete map[type];
                            if (boundsEventMap[type]) BoundsEvent.checkHas(this, type, "off");
                        }
                    }
                });
            } else {
                const {__bubbleMap: b, __captureMap: c} = this;
                typeList.forEach(type => {
                    if (b) delete b[type];
                    if (c) delete c[type];
                });
            }
        } else {
            this.__bubbleMap = this.__captureMap = undefined;
        }
    }
    on_(type, listener, bind, options) {
        if (!listener) isArray(type) && type.forEach(item => this.on(item[0], item[2] ? item[1] = item[1].bind(item[2]) : item[1], item[3])); else this.on(type, bind ? listener = listener.bind(bind) : listener, options);
        return {
            type: type,
            current: this,
            listener: listener,
            options: options
        };
    }
    off_(id) {
        if (!id) return;
        const list = isArray(id) ? id : [ id ];
        list.forEach(item => {
            if (item) {
                if (!item.listener) isArray(item.type) && item.type.forEach(v => item.current.off(v[0], v[1], v[3])); else item.current.off(item.type, item.listener, item.options);
            }
        });
        list.length = 0;
    }
    once(type, listener, captureOrBind, capture) {
        if (!listener) return isArray(type) && type.forEach(item => this.once(item[0], item[1], item[2], item[3]));
        if (isObject(captureOrBind)) listener = listener.bind(captureOrBind); else capture = captureOrBind;
        this.on(type, listener, {
            once: true,
            capture: capture
        });
    }
    emit(type, event, capture) {
        if (!event && EventCreator.has(type)) event = EventCreator.get(type, {
            type: type,
            target: this,
            current: this
        });
        const map = __getListenerMap(this, capture);
        const list = map[type];
        if (list) {
            let item;
            for (let i = 0, len = list.length; i < len; i++) {
                if (item = list[i]) {
                    item.listener(event);
                    if (item.once) {
                        this.off(type, item.listener, capture);
                        i--, len--;
                    }
                    if (event && event.isStopNow) break;
                }
            }
        }
        this.syncEventer && this.syncEventer.emitEvent(event, capture);
    }
    emitEvent(event, capture) {
        event.current = this;
        this.emit(event.type, event, capture);
    }
    hasEvent(type, capture) {
        if (this.syncEventer && this.syncEventer.hasEvent(type, capture)) return true;
        const {__bubbleMap: b, __captureMap: c} = this;
        const hasB = b && b[type], hasC = c && c[type];
        return !!(isUndefined(capture) ? hasB || hasC : capture ? hasC : hasB);
    }
    destroy() {
        this.__captureMap = this.__bubbleMap = this.syncEventer = null;
    }
}

function __getListenerMap(eventer, capture, create) {
    if (capture) {
        const {__captureMap: c} = eventer;
        if (c) {
            return c;
        } else {
            return create ? eventer.__captureMap = {} : empty;
        }
    } else {
        const {__bubbleMap: b} = eventer;
        if (b) {
            return b;
        } else {
            return create ? eventer.__bubbleMap = {} : empty;
        }
    }
}

const {on: on, on_: on_, off: off, off_: off_, once: once, emit: emit, emitEvent: emitEvent, hasEvent: hasEvent, destroy: destroy} = Eventer.prototype;

const LeafEventer = {
    on: on,
    on_: on_,
    off: off,
    off_: off_,
    once: once,
    emit: emit,
    emitEvent: emitEvent,
    hasEvent: hasEvent,
    destroyEventer: destroy
};

const debug$1 = Debug.get("setAttr");

const LeafDataProxy = {
    __setAttr(name, newValue, checkFiniteNumber) {
        if (this.leaferIsCreated) {
            const oldValue = this.__.__getInput(name);
            if (checkFiniteNumber && !isFinite(newValue) && !isUndefined(newValue)) {
                debug$1.warn(this.innerName, name, newValue);
                newValue = undefined;
            }
            if (isObject(newValue) || oldValue !== newValue) {
                this.__realSetAttr(name, newValue);
                if (this.isLeafer) {
                    this.emitEvent(new PropertyEvent(PropertyEvent.LEAFER_CHANGE, this, name, oldValue, newValue));
                    const transformEventName = leaferTransformAttrMap[name];
                    if (transformEventName) {
                        this.emitEvent(new LeaferEvent(transformEventName, this));
                        this.emitEvent(new LeaferEvent(LeaferEvent.TRANSFORM, this));
                    }
                }
                this.emitPropertyEvent(PropertyEvent.CHANGE, name, oldValue, newValue);
                const extraPropertyEvent = extraPropertyEventMap[name];
                if (extraPropertyEvent) this.emitPropertyEvent(extraPropertyEvent, name, oldValue, newValue);
                return true;
            } else {
                return false;
            }
        } else {
            this.__realSetAttr(name, newValue);
            return true;
        }
    },
    emitPropertyEvent(type, name, oldValue, newValue) {
        const event = new PropertyEvent(type, this, name, oldValue, newValue);
        this.isLeafer || this.hasEvent(type) && this.emitEvent(event);
        this.leafer.emitEvent(event);
    },
    __realSetAttr(name, newValue) {
        const data = this.__;
        data[name] = newValue;
        if (this.__proxyData) this.setProxyAttr(name, newValue);
        if (data.normalStyle) this.lockNormalStyle || isUndefined(data.normalStyle[name]) || (data.normalStyle[name] = newValue);
    },
    __getAttr(name) {
        if (this.__proxyData) return this.getProxyAttr(name);
        return this.__.__get(name);
    }
};

const {setLayout: setLayout, multiplyParent: multiplyParent$1, translateInner: translateInner, defaultWorld: defaultWorld} = MatrixHelper;

const {toPoint: toPoint, tempPoint: tempPoint} = AroundHelper;

const LeafMatrix = {
    __updateWorldMatrix() {
        const {parent: parent, __layout: __layout, __world: __world, __scrollWorld: __scrollWorld, __: __} = this;
        multiplyParent$1(this.__local || __layout, parent ? parent.__scrollWorld || parent.__world : defaultWorld, __world, !!__layout.affectScaleOrRotation, __);
        if (__scrollWorld) translateInner(Object.assign(__scrollWorld, __world), __.scrollX, __.scrollY);
    },
    __updateLocalMatrix() {
        if (this.__local) {
            const layout = this.__layout, local = this.__local, data = this.__;
            if (layout.affectScaleOrRotation) {
                if (layout.scaleChanged && (layout.resized || (layout.resized = "scale")) || layout.rotationChanged) {
                    setLayout(local, data, null, null, layout.affectRotation);
                    layout.scaleChanged = layout.rotationChanged = undefined;
                }
            }
            local.e = data.x + data.offsetX;
            local.f = data.y + data.offsetY;
            if (data.around || data.origin) {
                toPoint(data.around || data.origin, layout.boxBounds, tempPoint);
                translateInner(local, -tempPoint.x, -tempPoint.y, !data.around);
            }
        }
        this.__layout.matrixChanged = undefined;
    }
};

const {updateMatrix: updateMatrix, updateAllMatrix: updateAllMatrix} = LeafHelper;

const {updateBounds: updateBounds} = BranchHelper;

const {toOuterOf: toOuterOf$1, copyAndSpread: copyAndSpread, copy: copy$1} = BoundsHelper;

const {toBounds: toBounds} = PathBounds;

const LeafBounds = {
    __updateWorldBounds() {
        const {__layout: __layout, __world: __world} = this;
        toOuterOf$1(__layout.renderBounds, __world, __world);
        if (__layout.resized) {
            if (__layout.resized === "inner") this.__onUpdateSize();
            if (this.__hasLocalEvent) BoundsEvent.emitLocal(this);
            __layout.resized = undefined;
        }
        if (this.__hasWorldEvent) BoundsEvent.emitWorld(this);
    },
    __updateLocalBounds() {
        const layout = this.__layout;
        if (layout.boxChanged) {
            if (!this.__.__pathInputed) this.__updatePath();
            this.__updateRenderPath();
            this.__updateBoxBounds();
            layout.resized = "inner";
        }
        if (layout.localBoxChanged) {
            if (this.__local) this.__updateLocalBoxBounds();
            layout.localBoxChanged = undefined;
            if (layout.strokeSpread) layout.strokeChanged = true;
            if (layout.renderSpread) layout.renderChanged = true;
            if (this.parent) this.parent.__layout.boxChange();
        }
        layout.boxChanged = undefined;
        if (layout.strokeChanged) {
            layout.strokeSpread = this.__updateStrokeSpread();
            if (layout.strokeSpread) {
                if (layout.strokeBounds === layout.boxBounds) layout.spreadStroke();
                this.__updateStrokeBounds();
                this.__updateLocalStrokeBounds();
            } else {
                layout.spreadStrokeCancel();
            }
            layout.strokeChanged = undefined;
            if (layout.renderSpread || layout.strokeSpread !== layout.strokeBoxSpread) layout.renderChanged = true;
            if (this.parent) this.parent.__layout.strokeChange();
            layout.resized = "inner";
        }
        if (layout.renderChanged) {
            layout.renderSpread = this.__updateRenderSpread();
            if (layout.renderSpread) {
                if (layout.renderBounds === layout.boxBounds || layout.renderBounds === layout.strokeBounds) layout.spreadRender();
                this.__updateRenderBounds();
                this.__updateLocalRenderBounds();
            } else {
                layout.spreadRenderCancel();
            }
            layout.renderChanged = undefined;
            if (this.parent) this.parent.__layout.renderChange();
        }
        layout.resized || (layout.resized = "local");
        layout.boundsChanged = undefined;
    },
    __updateLocalBoxBounds() {
        if (this.__hasMotionPath) this.__updateMotionPath();
        if (this.__hasAutoLayout) this.__updateAutoLayout();
        toOuterOf$1(this.__layout.boxBounds, this.__local, this.__local);
    },
    __updateLocalStrokeBounds() {
        toOuterOf$1(this.__layout.strokeBounds, this.__localMatrix, this.__layout.localStrokeBounds);
    },
    __updateLocalRenderBounds() {
        toOuterOf$1(this.__layout.renderBounds, this.__localMatrix, this.__layout.localRenderBounds);
    },
    __updateBoxBounds(_secondLayout, _bounds) {
        const b = this.__layout.boxBounds;
        const data = this.__;
        if (data.__usePathBox) {
            toBounds(data.path, b);
        } else {
            b.x = 0;
            b.y = 0;
            b.width = data.width;
            b.height = data.height;
        }
    },
    __updateAutoLayout() {
        this.__layout.matrixChanged = true;
        if (this.isBranch) {
            this.__extraUpdate();
            if (this.__.flow) {
                if (this.__layout.boxChanged) this.__updateFlowLayout();
                updateAllMatrix(this);
                updateBounds(this, this);
                if (this.__.__autoSide) this.__updateBoxBounds(true);
            } else {
                updateAllMatrix(this);
                updateBounds(this, this);
            }
        } else {
            updateMatrix(this);
        }
    },
    __updateNaturalSize() {
        const {__: data, __layout: layout} = this;
        data.__naturalWidth = layout.boxBounds.width;
        data.__naturalHeight = layout.boxBounds.height;
    },
    __updateStrokeBounds(_bounds) {
        const layout = this.__layout;
        copyAndSpread(layout.strokeBounds, layout.boxBounds, layout.strokeBoxSpread);
    },
    __updateRenderBounds(_bounds) {
        const layout = this.__layout, {renderSpread: renderSpread} = layout;
        isNumber(renderSpread) && renderSpread <= 0 ? copy$1(layout.renderBounds, layout.strokeBounds) : copyAndSpread(layout.renderBounds, layout.boxBounds, renderSpread);
    }
};

const LeafRender = {
    __render(canvas, options) {
        if (options.shape) return this.__renderShape(canvas, options);
        if (options.cellList && !options.cellList.has(this)) return;
        if (this.__worldOpacity) {
            const data = this.__;
            if (data.bright && !options.topRendering) return options.topList.add(this);
            canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
            canvas.opacity = options.dimOpacity && !data.dimskip ? data.opacity * options.dimOpacity : data.opacity;
            if (this.__.__single) {
                if (data.eraser === "path") return this.__renderEraser(canvas, options);
                const tempCanvas = canvas.getSameCanvas(true, true);
                this.__draw(tempCanvas, options, canvas);
                LeafHelper.copyCanvasByWorld(this, canvas, tempCanvas, this.__nowWorld, data.__blendMode, true);
                tempCanvas.recycle(this.__nowWorld);
            } else {
                this.__draw(canvas, options);
            }
            if (Debug.showBounds) Debug.drawBounds(this, canvas, options);
        }
    },
    __renderShape(canvas, options) {
        if (this.__worldOpacity) {
            canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
            this.__drawShape(canvas, options);
        }
    },
    __clip(canvas, options) {
        if (this.__worldOpacity) {
            canvas.setWorld(this.__nowWorld = this.__getNowWorld(options));
            this.__drawRenderPath(canvas);
            canvas.clipUI(this);
        }
    },
    __updateWorldOpacity() {
        this.__worldOpacity = this.__.visible ? this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity : 0;
        if (this.__layout.opacityChanged) this.__layout.opacityChanged = false;
    }
};

const {excludeRenderBounds: excludeRenderBounds} = LeafBoundsHelper, {hasSize: hasSize} = BoundsHelper;

const BranchRender = {
    __updateChange() {
        const {__layout: layout} = this;
        if (layout.childrenSortChanged) {
            this.__updateSortChildren();
            layout.childrenSortChanged = false;
        }
        this.__.__checkSingle();
    },
    __render(canvas, options) {
        const nowWorld = this.__nowWorld = this.__getNowWorld(options);
        if (this.__worldOpacity && hasSize(nowWorld)) {
            const data = this.__;
            if (data.__useDim) {
                if (data.dim) options.dimOpacity = data.dim === true ? .2 : data.dim; else if (data.bright && !options.topRendering) return options.topList.add(this); else if (data.dimskip) options.dimOpacity && (options.dimOpacity = 0);
            }
            if (data.__single && !this.isBranchLeaf) {
                if (data.eraser === "path") return this.__renderEraser(canvas, options);
                const tempCanvas = canvas.getSameCanvas(false, true);
                this.__renderBranch(tempCanvas, options);
                canvas.opacity = options.dimOpacity ? data.opacity * options.dimOpacity : data.opacity;
                canvas.copyWorldByReset(tempCanvas, nowWorld, nowWorld, data.__blendMode, true);
                tempCanvas.recycle(nowWorld);
            } else {
                this.__renderBranch(canvas, options);
            }
        }
    },
    __renderBranch(canvas, options) {
        if (this.__hasMask) {
            this.__renderMask(canvas, options);
        } else {
            const {children: children} = this;
            for (let i = 0, len = children.length; i < len; i++) {
                excludeRenderBounds(children[i], options) || children[i].__render(canvas, options);
            }
        }
    },
    __clip(canvas, options) {
        if (this.__worldOpacity) {
            const {children: children} = this;
            for (let i = 0, len = children.length; i < len; i++) {
                excludeRenderBounds(children[i], options) || children[i].__clip(canvas, options);
            }
        }
    }
};

const tempScaleData = {};

const {LEAF: LEAF, create: create} = IncrementId;

const {stintSet: stintSet} = DataHelper;

const {toInnerPoint: toInnerPoint, toOuterPoint: toOuterPoint, multiplyParent: multiplyParent} = MatrixHelper;

const {toOuterOf: toOuterOf} = BoundsHelper;

const {copy: copy, move: move} = PointHelper;

const {moveLocal: moveLocal, zoomOfLocal: zoomOfLocal, rotateOfLocal: rotateOfLocal, skewOfLocal: skewOfLocal, moveWorld: moveWorld, zoomOfWorld: zoomOfWorld, rotateOfWorld: rotateOfWorld, skewOfWorld: skewOfWorld, transform: transform, transformWorld: transformWorld, setTransform: setTransform, getFlipTransform: getFlipTransform, getLocalOrigin: getLocalOrigin, getRelativeWorld: getRelativeWorld, drop: drop} = LeafHelper;

exports.Leaf = class Leaf {
    get tag() {
        return this.__tag;
    }
    set tag(_value) {}
    get __tag() {
        return "Leaf";
    }
    get innerName() {
        return this.__.name || this.tag + this.innerId;
    }
    get __DataProcessor() {
        return LeafData;
    }
    get __LayoutProcessor() {
        return LeafLayout;
    }
    get leaferIsCreated() {
        return this.leafer && this.leafer.created;
    }
    get leaferIsReady() {
        return this.leafer && this.leafer.ready;
    }
    get isLeafer() {
        return false;
    }
    get isBranch() {
        return false;
    }
    get isBranchLeaf() {
        return false;
    }
    get __localMatrix() {
        return this.__local || this.__layout;
    }
    get __localBoxBounds() {
        return this.__local || this.__layout;
    }
    get worldTransform() {
        return this.__layout.getTransform("world");
    }
    get localTransform() {
        return this.__layout.getTransform("local");
    }
    get scrollWorldTransform() {
        this.updateLayout();
        return this.__scrollWorld || this.__world;
    }
    get boxBounds() {
        return this.getBounds("box", "inner");
    }
    get renderBounds() {
        return this.getBounds("render", "inner");
    }
    get worldBoxBounds() {
        return this.getBounds("box");
    }
    get worldStrokeBounds() {
        return this.getBounds("stroke");
    }
    get worldRenderBounds() {
        return this.getBounds("render");
    }
    get worldOpacity() {
        this.updateLayout();
        return this.__worldOpacity;
    }
    get __worldFlipped() {
        return this.__world.scaleX < 0 || this.__world.scaleY < 0;
    }
    get __onlyHitMask() {
        return this.__hasMask && !this.__.hitChildren;
    }
    get __ignoreHitWorld() {
        return (this.__hasMask || this.__hasEraser) && this.__.hitChildren;
    }
    get __inLazyBounds() {
        return this.leaferIsCreated && this.leafer.lazyBounds.hit(this.__world);
    }
    get pathInputed() {
        return this.__.__pathInputed;
    }
    set event(map) {
        this.on(map);
    }
    constructor(data) {
        this.innerId = create(LEAF);
        this.reset(data);
        if (this.__bubbleMap) this.__emitLifeEvent(ChildEvent.CREATED);
    }
    reset(data) {
        if (this.leafer) this.leafer.forceRender(this.__world);
        if (data !== 0) {
            this.__world = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                scaleX: 1,
                scaleY: 1
            };
            if (data !== null) this.__local = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: 0,
                f: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
        }
        this.__worldOpacity = 1;
        this.__ = new this.__DataProcessor(this);
        this.__layout = new this.__LayoutProcessor(this);
        if (this.__level) this.resetCustom();
        if (data) {
            if (data.__) data = data.toJSON();
            data.children ? this.set(data) : Object.assign(this, data);
        }
    }
    resetCustom() {
        this.__hasMask = this.__hasEraser = null;
        this.forceUpdate();
    }
    waitParent(item, bind) {
        if (bind) item = item.bind(bind);
        this.parent ? item() : this.on(ChildEvent.ADD, item, "once");
    }
    waitLeafer(item, bind) {
        if (bind) item = item.bind(bind);
        this.leafer ? item() : this.on(ChildEvent.MOUNTED, item, "once");
    }
    nextRender(item, bind, off) {
        this.leafer ? this.leafer.nextRender(item, bind, off) : this.waitLeafer(() => this.leafer.nextRender(item, bind, off));
    }
    removeNextRender(item) {
        this.nextRender(item, null, "off");
    }
    __bindLeafer(leafer) {
        if (this.isLeafer && leafer !== null) leafer = this;
        if (this.leafer && !leafer) this.leafer.leafs--;
        this.leafer = leafer;
        if (leafer) {
            leafer.leafs++;
            this.__level = this.parent ? this.parent.__level + 1 : 1;
            if (this.animation) this.__runAnimation("in");
            if (this.__bubbleMap) this.__emitLifeEvent(ChildEvent.MOUNTED);
        } else {
            this.__emitLifeEvent(ChildEvent.UNMOUNTED);
        }
        if (this.isBranch) {
            const {children: children} = this;
            for (let i = 0, len = children.length; i < len; i++) {
                children[i].__bindLeafer(leafer);
            }
        }
    }
    set(_data, _isTemp) {}
    get(_name) {
        return undefined;
    }
    setAttr(name, value) {
        this[name] = value;
    }
    getAttr(name) {
        return this[name];
    }
    getComputedAttr(name) {
        return this.__[name];
    }
    toJSON(options) {
        if (options) this.__layout.update();
        return this.__.__getInputData(null, options);
    }
    toString(options) {
        return JSON.stringify(this.toJSON(options));
    }
    toSVG() {
        return undefined;
    }
    __SVG(_data) {}
    toHTML() {
        return undefined;
    }
    __setAttr(_attrName, _newValue) {
        return true;
    }
    __getAttr(_attrName) {
        return undefined;
    }
    setProxyAttr(_attrName, _newValue) {}
    getProxyAttr(_attrName) {
        return undefined;
    }
    find(_condition, _options) {
        return undefined;
    }
    findTag(_tag) {
        return undefined;
    }
    findOne(_condition, _options) {
        return undefined;
    }
    findId(_id) {
        return undefined;
    }
    focus(_value) {}
    updateState() {}
    updateLayout() {
        this.__layout.update();
    }
    forceUpdate(attrName) {
        if (isUndefined(attrName)) attrName = "width"; else if (attrName === "surface") attrName = "blendMode";
        const value = this.__.__getInput(attrName);
        this.__[attrName] = isUndefined(value) ? null : undefined;
        this[attrName] = value;
    }
    forceRender(_bounds, _sync) {
        this.forceUpdate("surface");
    }
    __extraUpdate() {
        if (this.leaferIsReady) this.leafer.layouter.addExtra(this);
    }
    __updateWorldMatrix() {}
    __updateLocalMatrix() {}
    __updateWorldBounds() {}
    __updateLocalBounds() {}
    __updateLocalBoxBounds() {}
    __updateLocalStrokeBounds() {}
    __updateLocalRenderBounds() {}
    __updateBoxBounds(_secondLayout, _bounds) {}
    __updateContentBounds() {}
    __updateStrokeBounds(_bounds) {}
    __updateRenderBounds(_bounds) {}
    __updateAutoLayout() {}
    __updateFlowLayout() {}
    __updateNaturalSize() {}
    __updateStrokeSpread() {
        return 0;
    }
    __updateRenderSpread() {
        return 0;
    }
    __onUpdateSize() {}
    __updateEraser(value) {
        this.__hasEraser = value ? true : this.children.some(item => item.__.eraser);
    }
    __renderEraser(canvas, options) {
        canvas.save();
        this.__clip(canvas, options);
        const {renderBounds: r} = this.__layout;
        canvas.clearRect(r.x, r.y, r.width, r.height);
        canvas.restore();
    }
    __updateMask(_value) {
        this.__hasMask = this.children.some(item => item.__.mask && item.__.visible && item.__.opacity);
    }
    __renderMask(_canvas, _options) {}
    __getNowWorld(options) {
        if (options.matrix) {
            if (!this.__cameraWorld) this.__cameraWorld = {};
            const cameraWorld = this.__cameraWorld, world = this.__world;
            multiplyParent(world, options.matrix, cameraWorld, undefined, world);
            toOuterOf(this.__layout.renderBounds, cameraWorld, cameraWorld);
            stintSet(cameraWorld, "half", world.half);
            stintSet(cameraWorld, "ignorePixelSnap", world.ignorePixelSnap);
            return cameraWorld;
        } else {
            return this.__world;
        }
    }
    getClampRenderScale() {
        let {scaleX: scaleX} = this.__nowWorld || this.__world;
        if (scaleX < 0) scaleX = -scaleX;
        return scaleX > 1 ? scaleX : 1;
    }
    getRenderScaleData(abs, scaleFixed) {
        let {scaleX: scaleX, scaleY: scaleY} = ImageManager.patternLocked ? this.__world : this.__nowWorld;
        if (abs) scaleX < 0 && (scaleX = -scaleX), scaleY < 0 && (scaleY = -scaleY);
        if (scaleFixed === true || scaleFixed === "zoom-in" && scaleX > 1 && scaleY > 1) scaleX = scaleY = 1;
        tempScaleData.scaleX = scaleX;
        tempScaleData.scaleY = scaleY;
        return tempScaleData;
    }
    getTransform(relative) {
        return this.__layout.getTransform(relative || "local");
    }
    getBounds(type, relative) {
        return this.__layout.getBounds(type, relative);
    }
    getLayoutBounds(type, relative, unscale) {
        return this.__layout.getLayoutBounds(type, relative, unscale);
    }
    getLayoutPoints(type, relative) {
        return this.__layout.getLayoutPoints(type, relative);
    }
    getWorldBounds(inner, relative, change) {
        const matrix = relative ? getRelativeWorld(this, relative) : this.worldTransform;
        const to = change ? inner : {};
        toOuterOf(inner, matrix, to);
        return to;
    }
    worldToLocal(world, to, distance, relative) {
        if (this.parent) {
            this.parent.worldToInner(world, to, distance, relative);
        } else {
            if (to) copy(to, world);
        }
    }
    localToWorld(local, to, distance, relative) {
        if (this.parent) {
            this.parent.innerToWorld(local, to, distance, relative);
        } else {
            if (to) copy(to, local);
        }
    }
    worldToInner(world, to, distance, relative) {
        if (relative) {
            relative.innerToWorld(world, to, distance);
            world = to ? to : world;
        }
        toInnerPoint(this.scrollWorldTransform, world, to, distance);
    }
    innerToWorld(inner, to, distance, relative) {
        toOuterPoint(this.scrollWorldTransform, inner, to, distance);
        if (relative) relative.worldToInner(to ? to : inner, null, distance);
    }
    getBoxPoint(world, relative, distance, change) {
        return this.getBoxPointByInner(this.getInnerPoint(world, relative, distance, change), null, null, true);
    }
    getBoxPointByInner(inner, _relative, _distance, change) {
        const point = change ? inner : Object.assign({}, inner), {x: x, y: y} = this.boxBounds;
        move(point, -x, -y);
        return point;
    }
    getInnerPoint(world, relative, distance, change) {
        const point = change ? world : {};
        this.worldToInner(world, point, distance, relative);
        return point;
    }
    getInnerPointByBox(box, _relative, _distance, change) {
        const point = change ? box : Object.assign({}, box), {x: x, y: y} = this.boxBounds;
        move(point, x, y);
        return point;
    }
    getInnerPointByLocal(local, _relative, distance, change) {
        return this.getInnerPoint(local, this.parent, distance, change);
    }
    getLocalPoint(world, relative, distance, change) {
        const point = change ? world : {};
        this.worldToLocal(world, point, distance, relative);
        return point;
    }
    getLocalPointByInner(inner, _relative, distance, change) {
        return this.getWorldPoint(inner, this.parent, distance, change);
    }
    getPagePoint(world, relative, distance, change) {
        const layer = this.leafer ? this.leafer.zoomLayer : this;
        return layer.getInnerPoint(world, relative, distance, change);
    }
    getWorldPoint(inner, relative, distance, change) {
        const point = change ? inner : {};
        this.innerToWorld(inner, point, distance, relative);
        return point;
    }
    getWorldPointByBox(box, relative, distance, change) {
        return this.getWorldPoint(this.getInnerPointByBox(box, null, null, change), relative, distance, true);
    }
    getWorldPointByLocal(local, relative, distance, change) {
        const point = change ? local : {};
        this.localToWorld(local, point, distance, relative);
        return point;
    }
    getWorldPointByPage(page, relative, distance, change) {
        const layer = this.leafer ? this.leafer.zoomLayer : this;
        return layer.getWorldPoint(page, relative, distance, change);
    }
    setTransform(matrix, resize, transition) {
        setTransform(this, matrix, resize, transition);
    }
    transform(matrix, resize, transition) {
        transform(this, matrix, resize, transition);
    }
    move(x, y, transition) {
        moveLocal(this, x, y, transition);
    }
    moveInner(x, y, transition) {
        moveWorld(this, x, y, true, transition);
    }
    scaleOf(origin, scaleX, scaleY, resize, transition) {
        zoomOfLocal(this, getLocalOrigin(this, origin), scaleX, scaleY, resize, transition);
    }
    rotateOf(origin, rotation, transition) {
        rotateOfLocal(this, getLocalOrigin(this, origin), rotation, transition);
    }
    skewOf(origin, skewX, skewY, resize, transition) {
        skewOfLocal(this, getLocalOrigin(this, origin), skewX, skewY, resize, transition);
    }
    transformWorld(worldTransform, resize, transition) {
        transformWorld(this, worldTransform, resize, transition);
    }
    moveWorld(x, y, transition) {
        moveWorld(this, x, y, false, transition);
    }
    scaleOfWorld(worldOrigin, scaleX, scaleY, resize, transition) {
        zoomOfWorld(this, worldOrigin, scaleX, scaleY, resize, transition);
    }
    rotateOfWorld(worldOrigin, rotation) {
        rotateOfWorld(this, worldOrigin, rotation);
    }
    skewOfWorld(worldOrigin, skewX, skewY, resize, transition) {
        skewOfWorld(this, worldOrigin, skewX, skewY, resize, transition);
    }
    flip(axis, transition) {
        transform(this, getFlipTransform(this, axis), false, transition);
    }
    scaleResize(scaleX, scaleY = scaleX, _noResize) {
        this.scaleX *= scaleX;
        this.scaleY *= scaleY;
    }
    __scaleResize(_scaleX, _scaleY) {}
    resizeWidth(_width) {}
    resizeHeight(_height) {}
    hit(_world, _hitRadius) {
        return true;
    }
    __hitWorld(_point, _forceHitFill) {
        return true;
    }
    __hit(_local, _forceHitFill) {
        return true;
    }
    __hitFill(_inner) {
        return true;
    }
    __hitStroke(_inner, _strokeWidth) {
        return true;
    }
    __hitPixel(_inner) {
        return true;
    }
    __drawHitPath(_canvas) {}
    __updateHitCanvas() {}
    __render(_canvas, _options) {}
    __drawFast(_canvas, _options) {}
    __draw(_canvas, _options, _originCanvas) {}
    __clip(_canvas, _options) {}
    __renderShape(_canvas, _options) {}
    __drawShape(_canvas, _options) {}
    __updateWorldOpacity() {}
    __updateChange() {}
    __drawPath(_canvas) {}
    __drawRenderPath(_canvas) {}
    __updatePath() {}
    __updateRenderPath() {}
    getMotionPathData() {
        return Plugin.need("path");
    }
    getMotionPoint(_motionDistance) {
        return Plugin.need("path");
    }
    getMotionTotal() {
        return 0;
    }
    __updateMotionPath() {}
    __runAnimation(_type, _complete) {}
    __updateSortChildren() {}
    add(_child, _index) {}
    remove(_child, destroy) {
        if (this.parent) this.parent.remove(this, destroy);
    }
    dropTo(parent, index, resize) {
        drop(this, parent, index, resize);
    }
    on(_type, _listener, _options) {}
    off(_type, _listener, _options) {}
    on_(_type, _listener, _bind, _options) {
        return undefined;
    }
    off_(_id) {}
    once(_type, _listener, _captureOrBind, _capture) {}
    emit(_type, _event, _capture) {}
    emitEvent(_event, _capture) {}
    hasEvent(_type, _capture) {
        return false;
    }
    static changeAttr(attrName, defaultValue, fn) {
        fn ? this.addAttr(attrName, defaultValue, fn) : defineDataProcessor(this.prototype, attrName, defaultValue);
    }
    static addAttr(attrName, defaultValue, fn, helpValue) {
        if (!fn) fn = boundsType;
        fn(defaultValue, helpValue)(this.prototype, attrName);
    }
    __emitLifeEvent(type) {
        if (this.hasEvent(type)) this.emitEvent(new ChildEvent(type, this, this.parent));
    }
    destroy() {
        if (!this.destroyed) {
            if (this.parent) this.remove();
            if (this.children) this.clear();
            this.__emitLifeEvent(ChildEvent.DESTROY);
            this.__.destroy();
            this.__layout.destroy();
            this.destroyEventer();
            this.destroyed = true;
        }
    }
};

exports.Leaf = __decorate([ useModule(LeafDataProxy), useModule(LeafMatrix), useModule(LeafBounds), useModule(LeafEventer), useModule(LeafRender) ], exports.Leaf);

const {setListWithFn: setListWithFn} = BoundsHelper;

const {sort: sort} = BranchHelper;

const {localBoxBounds: localBoxBounds, localStrokeBounds: localStrokeBounds, localRenderBounds: localRenderBounds, maskLocalBoxBounds: maskLocalBoxBounds, maskLocalStrokeBounds: maskLocalStrokeBounds, maskLocalRenderBounds: maskLocalRenderBounds} = LeafBoundsHelper;

const debug = new Debug("Branch");

exports.Branch = class Branch extends exports.Leaf {
    __updateStrokeSpread() {
        const {children: children} = this;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].__layout.strokeSpread) return 1;
        }
        return 0;
    }
    __updateRenderSpread() {
        const {children: children} = this;
        for (let i = 0, len = children.length; i < len; i++) {
            if (children[i].__layout.renderSpread) return 1;
        }
        return 0;
    }
    __updateBoxBounds(_secondLayout, bounds) {
        setListWithFn(bounds || this.__layout.boxBounds, this.children, this.__hasMask ? maskLocalBoxBounds : localBoxBounds);
    }
    __updateStrokeBounds(bounds) {
        setListWithFn(bounds || this.__layout.strokeBounds, this.children, this.__hasMask ? maskLocalStrokeBounds : localStrokeBounds);
    }
    __updateRenderBounds(bounds) {
        setListWithFn(bounds || this.__layout.renderBounds, this.children, this.__hasMask ? maskLocalRenderBounds : localRenderBounds);
    }
    __updateSortChildren() {
        let affectSort;
        const {children: children} = this;
        if (children.length > 1) {
            for (let i = 0, len = children.length; i < len; i++) {
                children[i].__tempNumber = i;
                if (children[i].__.zIndex) affectSort = true;
            }
            children.sort(sort);
            this.__layout.affectChildrenSort = affectSort;
        }
    }
    add(child, index) {
        if (child === this || child.destroyed) return debug.warn("add self or destroyed");
        const noIndex = isUndefined(index);
        if (!child.__) {
            if (isArray(child)) return child.forEach(item => {
                this.add(item, index);
                noIndex || index++;
            }); else child = UICreator.get(child.tag, child);
        }
        if (child.parent) child.parent.remove(child);
        child.parent = this;
        noIndex ? this.children.push(child) : this.children.splice(index, 0, child);
        if (child.isBranch) this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1;
        const childLayout = child.__layout;
        childLayout.boxChanged || childLayout.boxChange();
        childLayout.matrixChanged || childLayout.matrixChange();
        if (child.__bubbleMap) child.__emitLifeEvent(ChildEvent.ADD);
        if (this.leafer) {
            child.__bindLeafer(this.leafer);
            if (this.leafer.created) this.__emitChildEvent(ChildEvent.ADD, child);
        }
        this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
    }
    addMany(...children) {
        this.add(children);
    }
    remove(child, destroy) {
        if (child) {
            if (child.__) {
                if (child.animationOut) child.__runAnimation("out", () => this.__remove(child, destroy)); else this.__remove(child, destroy);
            } else this.find(child).forEach(item => this.remove(item, destroy));
        } else if (isUndefined(child)) {
            super.remove(null, destroy);
        }
    }
    removeAll(destroy) {
        const {children: children} = this;
        if (children.length) {
            this.children = [];
            this.__preRemove();
            this.__.__childBranchNumber = 0;
            children.forEach(child => {
                this.__realRemoveChild(child);
                if (destroy) child.destroy();
            });
        }
    }
    clear() {
        this.removeAll(true);
    }
    __remove(child, destroy) {
        const index = this.children.indexOf(child);
        if (index > -1) {
            this.children.splice(index, 1);
            if (child.isBranch) this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1;
            this.__preRemove();
            this.__realRemoveChild(child);
            if (destroy) child.destroy();
        }
    }
    __preRemove() {
        if (this.__hasMask) this.__updateMask();
        if (this.__hasEraser) this.__updateEraser();
        this.__layout.boxChange();
        this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
    }
    __realRemoveChild(child) {
        child.__emitLifeEvent(ChildEvent.REMOVE);
        child.parent = null;
        if (this.leafer) {
            child.__bindLeafer(null);
            if (this.leafer.created) {
                this.__emitChildEvent(ChildEvent.REMOVE, child);
                if (this.leafer.hitCanvasManager) this.leafer.hitCanvasManager.clear();
            }
        }
    }
    __emitChildEvent(type, child) {
        const event = new ChildEvent(type, child, this);
        if (this.hasEvent(type) && !this.isLeafer) this.emitEvent(event);
        this.leafer.emitEvent(event);
    }
};

exports.Branch = __decorate([ useModule(BranchRender) ], exports.Branch);

class LeafList {
    get length() {
        return this.list.length;
    }
    constructor(item) {
        this.reset();
        if (item) isArray(item) ? this.addList(item) : this.add(item);
    }
    has(leaf) {
        return leaf && !isUndefined(this.keys[leaf.innerId]);
    }
    indexAt(index) {
        return this.list[index];
    }
    indexOf(leaf) {
        const index = this.keys[leaf.innerId];
        return isUndefined(index) ? -1 : index;
    }
    add(leaf) {
        const {list: list, keys: keys} = this;
        if (isUndefined(keys[leaf.innerId])) {
            list.push(leaf);
            keys[leaf.innerId] = list.length - 1;
        }
    }
    addAt(leaf, index = 0) {
        const {keys: keys} = this;
        if (isUndefined(keys[leaf.innerId])) {
            const {list: list} = this;
            for (let i = index, len = list.length; i < len; i++) keys[list[i].innerId]++;
            if (index === 0) {
                list.unshift(leaf);
            } else {
                if (index > list.length) index = list.length;
                list.splice(index, 0, leaf);
            }
            keys[leaf.innerId] = index;
        }
    }
    addList(list) {
        for (let i = 0; i < list.length; i++) this.add(list[i]);
    }
    remove(leaf) {
        const {list: list} = this;
        let findIndex;
        for (let i = 0, len = list.length; i < len; i++) {
            if (!isUndefined(findIndex)) {
                this.keys[list[i].innerId] = i - 1;
            } else if (list[i].innerId === leaf.innerId) {
                findIndex = i;
                delete this.keys[leaf.innerId];
            }
        }
        if (!isUndefined(findIndex)) list.splice(findIndex, 1);
    }
    sort(reverse) {
        const {list: list} = this;
        if (reverse) {
            list.sort((a, b) => b.__level - a.__level);
        } else {
            list.sort((a, b) => a.__level - b.__level);
        }
    }
    forEach(itemCallback) {
        this.list.forEach(itemCallback);
    }
    clone() {
        const list = new LeafList;
        list.list = [ ...this.list ];
        list.keys = Object.assign({}, this.keys);
        return list;
    }
    update() {
        this.keys = {};
        const {list: list, keys: keys} = this;
        for (let i = 0, len = list.length; i < len; i++) keys[list[i].innerId] = i;
    }
    reset() {
        this.list = [];
        this.keys = {};
    }
    destroy() {
        this.reset();
    }
}

class LeafLevelList {
    get length() {
        return this._length;
    }
    constructor(item) {
        this._length = 0;
        this.reset();
        if (item) isArray(item) ? this.addList(item) : this.add(item);
    }
    has(leaf) {
        return !isUndefined(this.keys[leaf.innerId]);
    }
    without(leaf) {
        return isUndefined(this.keys[leaf.innerId]);
    }
    sort(reverse) {
        const {levels: levels} = this;
        if (reverse) {
            levels.sort((a, b) => b - a);
        } else {
            levels.sort((a, b) => a - b);
        }
    }
    addList(list) {
        list.forEach(leaf => {
            this.add(leaf);
        });
    }
    add(leaf) {
        const {keys: keys, levelMap: levelMap} = this;
        if (!keys[leaf.innerId]) {
            keys[leaf.innerId] = 1;
            if (!levelMap[leaf.__level]) {
                levelMap[leaf.__level] = [ leaf ];
                this.levels.push(leaf.__level);
            } else {
                levelMap[leaf.__level].push(leaf);
            }
            this._length++;
        }
    }
    forEach(itemCallback) {
        let list;
        this.levels.forEach(level => {
            list = this.levelMap[level];
            for (let i = 0, len = list.length; i < len; i++) {
                itemCallback(list[i]);
            }
        });
    }
    reset() {
        this.levelMap = {};
        this.keys = {};
        this.levels = [];
        this._length = 0;
    }
    destroy() {
        this.levelMap = null;
    }
}

const version = "2.0.0";

exports.AlignHelper = AlignHelper;

exports.AroundHelper = AroundHelper;

exports.AutoBounds = AutoBounds;

exports.BezierHelper = BezierHelper;

exports.Bounds = Bounds;

exports.BoundsEvent = BoundsEvent;

exports.BoundsHelper = BoundsHelper;

exports.BranchHelper = BranchHelper;

exports.BranchRender = BranchRender;

exports.CanvasManager = CanvasManager;

exports.ChildEvent = ChildEvent;

exports.Creator = Creator;

exports.DataHelper = DataHelper;

exports.Debug = Debug;

exports.EllipseHelper = EllipseHelper;

exports.Event = Event;

exports.EventCreator = EventCreator;

exports.Eventer = Eventer;

exports.FileHelper = FileHelper;

exports.FourNumberHelper = FourNumberHelper;

exports.ImageEvent = ImageEvent;

exports.ImageManager = ImageManager;

exports.IncrementId = IncrementId;

exports.LayoutEvent = LayoutEvent;

exports.LeafBounds = LeafBounds;

exports.LeafBoundsHelper = LeafBoundsHelper;

exports.LeafData = LeafData;

exports.LeafDataProxy = LeafDataProxy;

exports.LeafEventer = LeafEventer;

exports.LeafHelper = LeafHelper;

exports.LeafLayout = LeafLayout;

exports.LeafLevelList = LeafLevelList;

exports.LeafList = LeafList;

exports.LeafMatrix = LeafMatrix;

exports.LeafRender = LeafRender;

exports.LeaferCanvasBase = LeaferCanvasBase;

exports.LeaferEvent = LeaferEvent;

exports.LeaferImage = LeaferImage;

exports.MathHelper = MathHelper;

exports.Matrix = Matrix;

exports.MatrixHelper = MatrixHelper;

exports.NeedConvertToCanvasCommandMap = NeedConvertToCanvasCommandMap;

exports.OneRadian = OneRadian;

exports.PI2 = PI2;

exports.PI_2 = PI_2;

exports.PathBounds = PathBounds;

exports.PathCommandDataHelper = PathCommandDataHelper;

exports.PathCommandMap = PathCommandMap;

exports.PathCommandNodeHelper = PathCommandNodeHelper;

exports.PathConvert = PathConvert;

exports.PathCorner = PathCorner;

exports.PathCreator = PathCreator;

exports.PathDrawer = PathDrawer;

exports.PathHelper = PathHelper;

exports.PathNumberCommandLengthMap = PathNumberCommandLengthMap;

exports.PathNumberCommandMap = PathNumberCommandMap;

exports.Platform = Platform;

exports.Plugin = Plugin;

exports.Point = Point;

exports.PointHelper = PointHelper;

exports.PropertyEvent = PropertyEvent;

exports.RectHelper = RectHelper;

exports.RenderEvent = RenderEvent;

exports.ResizeEvent = ResizeEvent;

exports.Resource = Resource;

exports.Run = Run;

exports.StringNumberMap = StringNumberMap;

exports.TaskItem = TaskItem;

exports.TaskProcessor = TaskProcessor;

exports.TwoPointBoundsHelper = TwoPointBoundsHelper;

exports.UICreator = UICreator;

exports.UnitConvertHelper = UnitConvertHelper;

exports.WaitHelper = WaitHelper;

exports.WatchEvent = WatchEvent;

exports.affectRenderBoundsType = affectRenderBoundsType;

exports.affectStrokeBoundsType = affectStrokeBoundsType;

exports.attr = attr;

exports.autoLayoutType = autoLayoutType;

exports.boundsType = boundsType;

exports.canvasPatch = canvasPatch;

exports.canvasSizeAttrs = canvasSizeAttrs;

exports.createDescriptor = createDescriptor;

exports.cursorType = cursorType;

exports.dataProcessor = dataProcessor;

exports.dataType = dataType;

exports.decorateLeafAttr = decorateLeafAttr;

exports.defineDataProcessor = defineDataProcessor;

exports.defineKey = defineKey;

exports.defineLeafAttr = defineLeafAttr;

exports.dimType = dimType;

exports.doBoundsType = doBoundsType;

exports.doStrokeType = doStrokeType;

exports.emptyData = emptyData;

exports.eraserType = eraserType;

exports.extraPropertyEventMap = extraPropertyEventMap;

exports.getBoundsData = getBoundsData;

exports.getDescriptor = getDescriptor;

exports.getMatrixData = getMatrixData;

exports.getPointData = getPointData;

exports.hitType = hitType;

exports.isArray = isArray;

exports.isData = isData;

exports.isEmptyData = isEmptyData;

exports.isFinite = isFinite;

exports.isNull = isNull;

exports.isNumber = isNumber;

exports.isObject = isObject;

exports.isString = isString;

exports.isUndefined = isUndefined;

exports.layoutProcessor = layoutProcessor;

exports.leaferTransformAttrMap = leaferTransformAttrMap;

exports.maskType = maskType;

exports.naturalBoundsType = naturalBoundsType;

exports.opacityType = opacityType;

exports.path = path;

exports.pathInputType = pathInputType;

exports.pathType = pathType;

exports.pen = pen;

exports.positionType = positionType;

exports.registerUI = registerUI;

exports.registerUIEvent = registerUIEvent;

exports.rewrite = rewrite;

exports.rewriteAble = rewriteAble;

exports.rotationType = rotationType;

exports.scaleType = scaleType;

exports.scrollType = scrollType;

exports.sortType = sortType;

exports.strokeType = strokeType;

exports.surfaceType = surfaceType;

exports.tempBounds = tempBounds;

exports.tempMatrix = tempMatrix;

exports.tempPoint = tempPoint$2;

exports.tryToNumber = tryToNumber;

exports.useModule = useModule;

exports.version = version;

exports.visibleType = visibleType;
