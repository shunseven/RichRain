// node_modules/@leafer/core/lib/core.esm.min.js
var t;
!(function(t2) {
  t2[t2.No = 0] = "No", t2[t2.Yes = 1] = "Yes", t2[t2.NoAndSkip = 2] = "NoAndSkip", t2[t2.YesAndSkip = 3] = "YesAndSkip";
})(t || (t = {}));
var e = {};
function s(t2) {
  return void 0 === t2;
}
function r(t2) {
  return null == t2;
}
function i(t2) {
  return "string" == typeof t2;
}
var { isFinite: n } = Number;
function o(t2) {
  return "number" == typeof t2;
}
var a = /^-?\d+(?:\.\d+)?$/;
function h(t2) {
  return "string" == typeof t2 && a.test(t2) ? +t2 : t2;
}
var { isArray: l } = Array;
function d(t2) {
  return t2 && "object" == typeof t2;
}
function c(t2) {
  return d(t2) && !l(t2);
}
function u(t2) {
  return "{}" === JSON.stringify(t2);
}
var _ = { default: (t2, e2) => (p(e2, t2), p(t2, e2), t2), assign(t2, e2, s2) {
  let r2;
  Object.keys(e2).forEach((i2) => {
    var n2, o2;
    if (r2 = e2[i2], (null == r2 ? void 0 : r2.constructor) === Object && (null === (n2 = t2[i2]) || void 0 === n2 ? void 0 : n2.constructor) === Object) return p(t2[i2], e2[i2], s2 && s2[i2]);
    s2 && i2 in s2 ? (null === (o2 = s2[i2]) || void 0 === o2 ? void 0 : o2.constructor) === Object && p(t2[i2] = {}, e2[i2], s2[i2]) : t2[i2] = e2[i2];
  });
}, copyAttrs: (t2, e2, r2) => (r2.forEach((r3) => {
  s(e2[r3]) || (t2[r3] = e2[r3]);
}), t2), clone: (t2) => JSON.parse(JSON.stringify(t2)), toMap(t2) {
  const e2 = {};
  for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) e2[t2[s2]] = true;
  return e2;
}, stintSet(t2, e2, s2) {
  s2 || (s2 = void 0), t2[e2] !== s2 && (t2[e2] = s2);
} };
var { assign: p } = _;
var f = class {
  get __useNaturalRatio() {
    return true;
  }
  get __isLinePath() {
    const { path: t2 } = this;
    return t2 && 6 === t2.length && 1 === t2[0];
  }
  get __usePathBox() {
    return this.__pathInputed;
  }
  get __blendMode() {
    if (this.eraser && "path" !== this.eraser) return "destination-out";
    const { blendMode: t2 } = this;
    return "pass-through" === t2 ? null : t2;
  }
  constructor(t2) {
    this.__leaf = t2;
  }
  __get(t2) {
    if (this.__input) {
      const e2 = this.__input[t2];
      if (!s(e2)) return e2;
    }
    return this[t2];
  }
  __getData() {
    const t2 = { tag: this.__leaf.tag }, { __input: e2 } = this;
    let r2;
    for (let i2 in this) "_" !== i2[0] && (r2 = e2 ? e2[i2] : void 0, t2[i2] = s(r2) ? this[i2] : r2);
    return t2;
  }
  __setInput(t2, e2) {
    this.__input || (this.__input = {}), this.__input[t2] = e2;
  }
  __getInput(t2) {
    if (this.__input) {
      const e2 = this.__input[t2];
      if (!s(e2)) return e2;
    }
    if ("path" !== t2 || this.__pathInputed) return this["_" + t2];
  }
  __removeInput(t2) {
    this.__input && !s(this.__input[t2]) && (this.__input[t2] = void 0);
  }
  __getInputData(t2, e2) {
    const r2 = {};
    if (t2) if (l(t2)) for (let e3 of t2) r2[e3] = this.__getInput(e3);
    else for (let e3 in t2) r2[e3] = this.__getInput(e3);
    else {
      let t3, e3, { __input: i2 } = this;
      r2.tag = this.__leaf.tag;
      for (let n2 in this) if ("_" !== n2[0] && (t3 = this["_" + n2], !s(t3))) {
        if ("path" === n2 && !this.__pathInputed) continue;
        e3 = i2 ? i2[n2] : void 0, r2[n2] = s(e3) ? t3 : e3;
      }
    }
    if (e2 && e2.matrix) {
      const { a: t3, b: e3, c: s2, d: i2, e: n2, f: o2 } = this.__leaf.__localMatrix;
      r2.matrix = { a: t3, b: e3, c: s2, d: i2, e: n2, f: o2 };
    }
    return r2;
  }
  __setMiddle(t2, e2) {
    this.__middle || (this.__middle = {}), this.__middle[t2] = e2;
  }
  __getMiddle(t2) {
    return this.__middle && this.__middle[t2];
  }
  __checkSingle() {
    const t2 = this;
    if ("pass-through" === t2.blendMode) {
      const e2 = this.__leaf;
      t2.opacity < 1 && (e2.isBranch || t2.__hasMultiPaint) || e2.__hasEraser || t2.eraser || t2.filter ? t2.__single = true : t2.__single && (t2.__single = false);
    } else t2.__single = true;
  }
  __removeNaturalSize() {
    this.__naturalWidth = this.__naturalHeight = void 0;
  }
  destroy() {
    this.__input = this.__middle = null;
  }
};
var g = { RUNTIME: "runtime", LEAF: "leaf", TASK: "task", CNAVAS: "canvas", IMAGE: "image", types: {}, create(t2) {
  const { types: e2 } = y;
  return e2[t2] ? e2[t2]++ : (e2[t2] = 1, 0);
} };
var y = g;
var m;
var x;
var w;
var { max: b } = Math;
var B = [0, 0, 0, 0];
var v = { zero: [...B], tempFour: B, set: (t2, e2, s2, r2, i2) => (void 0 === s2 && (s2 = r2 = i2 = e2), t2[0] = e2, t2[1] = s2, t2[2] = r2, t2[3] = i2, t2), setTemp: (t2, e2, s2, r2) => k(B, t2, e2, s2, r2), toTempAB(t2, e2, s2) {
  w = s2 ? o(t2) ? e2 : t2 : [], o(t2) ? (m = O(t2), x = e2) : o(e2) ? (m = t2, x = O(e2)) : (m = t2, x = e2), 4 !== m.length && (m = C(m)), 4 !== x.length && (x = C(x));
}, get(t2, e2) {
  let r2;
  if (!o(t2)) switch (t2.length) {
    case 4:
      r2 = s(e2) ? t2 : [...t2];
      break;
    case 2:
      r2 = [t2[0], t2[1], t2[0], t2[1]];
      break;
    case 3:
      r2 = [t2[0], t2[1], t2[2], t2[1]];
      break;
    case 1:
      t2 = t2[0];
      break;
    default:
      t2 = 0;
  }
  if (r2 || (r2 = [t2, t2, t2, t2]), !s(e2)) for (let t3 = 0; t3 < 4; t3++) r2[t3] > e2 && (r2[t3] = e2);
  return r2;
}, max: (t2, e2, s2) => o(t2) && o(e2) ? b(t2, e2) : (T(t2, e2, s2), k(w, b(m[0], x[0]), b(m[1], x[1]), b(m[2], x[2]), b(m[3], x[3]))), add: (t2, e2, s2) => o(t2) && o(e2) ? t2 + e2 : (T(t2, e2, s2), k(w, m[0] + x[0], m[1] + x[1], m[2] + x[2], m[3] + x[3])), swapAndScale(t2, e2, s2, r2) {
  if (o(t2)) return e2 === s2 ? t2 * e2 : [t2 * s2, t2 * e2];
  const i2 = r2 ? t2 : [], [n2, a2, h2, l2] = 4 === t2.length ? t2 : C(t2);
  return k(i2, h2 * s2, l2 * e2, n2 * s2, a2 * e2);
} };
var { set: k, get: C, setTemp: O, toTempAB: T } = v;
var { round: P, pow: S, max: L, floor: R, PI: E } = Math;
var I = { within: (t2, e2, r2) => (d(e2) && (r2 = e2.max, e2 = e2.min), !s(e2) && t2 < e2 && (t2 = e2), !s(r2) && t2 > r2 && (t2 = r2), t2), fourNumber: v.get, formatRotation: (t2, e2) => (t2 %= 360, e2 ? t2 < 0 && (t2 += 360) : (t2 > 180 && (t2 -= 360), t2 < -180 && (t2 += 360)), I.float(t2)), getGapRotation(t2, e2, s2 = 0) {
  let r2 = t2 + s2;
  if (e2 > 1) {
    const t3 = Math.abs(r2 % e2);
    (t3 < 1 || t3 > e2 - 1) && (r2 = Math.round(r2 / e2) * e2);
  }
  return r2 - s2;
}, float(t2, e2) {
  const r2 = s(e2) ? 1e12 : S(10, e2);
  return -0 === (t2 = P(t2 * r2) / r2) ? 0 : t2;
}, sign: (t2) => t2 < 0 ? -1 : 1, getScaleData(t2, e2, s2, r2) {
  if (r2 || (r2 = {}), e2) {
    const t3 = (o(e2) ? e2 : e2.width || 0) / s2.width, i2 = (o(e2) ? e2 : e2.height || 0) / s2.height;
    r2.scaleX = t3 || i2 || 1, r2.scaleY = i2 || t3 || 1;
  } else t2 && I.assignScale(r2, t2);
  return r2;
}, assignScale(t2, e2) {
  o(e2) ? t2.scaleX = t2.scaleY = e2 : (t2.scaleX = e2.x, t2.scaleY = e2.y);
}, getFloorScale: (t2, e2 = 1) => L(R(t2), e2) / t2, randInt: M, randColor: (t2) => `rgba(${M(255)},${M(255)},${M(255)},${t2 || 1})` };
function M(t2) {
  return Math.round(Math.random() * t2);
}
var A = E / 180;
var W = 2 * E;
var N = E / 2;
function Y() {
  return { x: 0, y: 0 };
}
function D() {
  return { x: 0, y: 0, width: 0, height: 0 };
}
function X() {
  return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
}
var { sin: z, cos: F, acos: U, sqrt: j } = Math;
var { float: H } = I;
var V = {};
function G() {
  return Object.assign(Object.assign(Object.assign({}, { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }), { x: 0, y: 0, width: 0, height: 0 }), { scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 });
}
var q = { defaultMatrix: { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }, defaultWorld: G(), tempMatrix: {}, set(t2, e2 = 1, s2 = 0, r2 = 0, i2 = 1, n2 = 0, o2 = 0) {
  t2.a = e2, t2.b = s2, t2.c = r2, t2.d = i2, t2.e = n2, t2.f = o2;
}, get: X, getWorld: G, copy(t2, e2) {
  t2.a = e2.a, t2.b = e2.b, t2.c = e2.c, t2.d = e2.d, t2.e = e2.e, t2.f = e2.f;
}, translate(t2, e2, s2) {
  t2.e += e2, t2.f += s2;
}, translateInner(t2, e2, s2, r2) {
  t2.e += t2.a * e2 + t2.c * s2, t2.f += t2.b * e2 + t2.d * s2, r2 && (t2.e -= e2, t2.f -= s2);
}, scale(t2, e2, s2 = e2) {
  t2.a *= e2, t2.b *= e2, t2.c *= s2, t2.d *= s2;
}, pixelScale(t2, e2, s2) {
  s2 || (s2 = t2), s2.a = t2.a * e2, s2.b = t2.b * e2, s2.c = t2.c * e2, s2.d = t2.d * e2, s2.e = t2.e * e2, s2.f = t2.f * e2;
}, scaleOfOuter(t2, e2, s2, r2) {
  Q.toInnerPoint(t2, e2, V), Q.scaleOfInner(t2, V, s2, r2);
}, scaleOfInner(t2, e2, s2, r2 = s2) {
  Q.translateInner(t2, e2.x, e2.y), Q.scale(t2, s2, r2), Q.translateInner(t2, -e2.x, -e2.y);
}, rotate(t2, e2) {
  const { a: s2, b: r2, c: i2, d: n2 } = t2, o2 = F(e2 *= A), a2 = z(e2);
  t2.a = s2 * o2 - r2 * a2, t2.b = s2 * a2 + r2 * o2, t2.c = i2 * o2 - n2 * a2, t2.d = i2 * a2 + n2 * o2;
}, rotateOfOuter(t2, e2, s2) {
  Q.toInnerPoint(t2, e2, V), Q.rotateOfInner(t2, V, s2);
}, rotateOfInner(t2, e2, s2) {
  Q.translateInner(t2, e2.x, e2.y), Q.rotate(t2, s2), Q.translateInner(t2, -e2.x, -e2.y);
}, skew(t2, e2, s2) {
  const { a: r2, b: i2, c: n2, d: o2 } = t2;
  s2 && (s2 *= A, t2.a = r2 + n2 * s2, t2.b = i2 + o2 * s2), e2 && (e2 *= A, t2.c = n2 + r2 * e2, t2.d = o2 + i2 * e2);
}, skewOfOuter(t2, e2, s2, r2) {
  Q.toInnerPoint(t2, e2, V), Q.skewOfInner(t2, V, s2, r2);
}, skewOfInner(t2, e2, s2, r2 = 0) {
  Q.translateInner(t2, e2.x, e2.y), Q.skew(t2, s2, r2), Q.translateInner(t2, -e2.x, -e2.y);
}, multiply(t2, e2) {
  const { a: s2, b: r2, c: i2, d: n2, e: o2, f: a2 } = t2;
  t2.a = e2.a * s2 + e2.b * i2, t2.b = e2.a * r2 + e2.b * n2, t2.c = e2.c * s2 + e2.d * i2, t2.d = e2.c * r2 + e2.d * n2, t2.e = e2.e * s2 + e2.f * i2 + o2, t2.f = e2.e * r2 + e2.f * n2 + a2;
}, multiplyParent(t2, e2, r2, i2, n2) {
  const { e: o2, f: a2 } = t2;
  if (r2 || (r2 = t2), s(i2) && (i2 = 1 !== t2.a || t2.b || t2.c || 1 !== t2.d), i2) {
    const { a: s2, b: i3, c: o3, d: a3 } = t2;
    r2.a = s2 * e2.a + i3 * e2.c, r2.b = s2 * e2.b + i3 * e2.d, r2.c = o3 * e2.a + a3 * e2.c, r2.d = o3 * e2.b + a3 * e2.d, n2 && (r2.scaleX = e2.scaleX * n2.scaleX, r2.scaleY = e2.scaleY * n2.scaleY);
  } else r2.a = e2.a, r2.b = e2.b, r2.c = e2.c, r2.d = e2.d, n2 && (r2.scaleX = e2.scaleX, r2.scaleY = e2.scaleY);
  r2.e = o2 * e2.a + a2 * e2.c + e2.e, r2.f = o2 * e2.b + a2 * e2.d + e2.f;
}, divide(t2, e2) {
  Q.multiply(t2, Q.tempInvert(e2));
}, divideParent(t2, e2) {
  Q.multiplyParent(t2, Q.tempInvert(e2));
}, tempInvert(t2) {
  const { tempMatrix: e2 } = Q;
  return Q.copy(e2, t2), Q.invert(e2), e2;
}, invert(t2) {
  const { a: e2, b: s2, c: r2, d: i2, e: n2, f: o2 } = t2;
  if (s2 || r2) {
    const a2 = 1 / (e2 * i2 - s2 * r2);
    t2.a = i2 * a2, t2.b = -s2 * a2, t2.c = -r2 * a2, t2.d = e2 * a2, t2.e = -(n2 * i2 - o2 * r2) * a2, t2.f = -(o2 * e2 - n2 * s2) * a2;
  } else if (1 === e2 && 1 === i2) t2.e = -n2, t2.f = -o2;
  else {
    const s3 = 1 / (e2 * i2);
    t2.a = i2 * s3, t2.d = e2 * s3, t2.e = -n2 * i2 * s3, t2.f = -o2 * e2 * s3;
  }
}, toOuterPoint(t2, e2, s2, r2) {
  const { x: i2, y: n2 } = e2;
  s2 || (s2 = e2), s2.x = i2 * t2.a + n2 * t2.c, s2.y = i2 * t2.b + n2 * t2.d, r2 || (s2.x += t2.e, s2.y += t2.f);
}, toInnerPoint(t2, e2, s2, r2) {
  const { a: i2, b: n2, c: o2, d: a2 } = t2, h2 = 1 / (i2 * a2 - n2 * o2), { x: l2, y: d2 } = e2;
  if (s2 || (s2 = e2), s2.x = (l2 * a2 - d2 * o2) * h2, s2.y = (d2 * i2 - l2 * n2) * h2, !r2) {
    const { e: e3, f: r3 } = t2;
    s2.x -= (e3 * a2 - r3 * o2) * h2, s2.y -= (r3 * i2 - e3 * n2) * h2;
  }
}, setLayout(t2, e2, r2, i2, n2) {
  const { x: o2, y: a2, scaleX: h2, scaleY: l2 } = e2;
  if (s(n2) && (n2 = e2.rotation || e2.skewX || e2.skewY), n2) {
    const { rotation: s2, skewX: r3, skewY: i3 } = e2, n3 = s2 * A, o3 = F(n3), a3 = z(n3);
    if (r3 || i3) {
      const e3 = r3 * A, s3 = i3 * A;
      t2.a = (o3 + s3 * -a3) * h2, t2.b = (a3 + s3 * o3) * h2, t2.c = (e3 * o3 - a3) * l2, t2.d = (o3 + e3 * a3) * l2;
    } else t2.a = o3 * h2, t2.b = a3 * h2, t2.c = -a3 * l2, t2.d = o3 * l2;
  } else t2.a = h2, t2.b = 0, t2.c = 0, t2.d = l2;
  t2.e = o2, t2.f = a2, (r2 = r2 || i2) && Q.translateInner(t2, -r2.x, -r2.y, !i2);
}, getLayout(t2, e2, s2, r2) {
  const { a: i2, b: n2, c: o2, d: a2, e: h2, f: l2 } = t2;
  let d2, c2, u2, _2, p2, f2 = h2, g2 = l2;
  if (n2 || o2) {
    const t3 = i2 * a2 - n2 * o2;
    if (o2 && !r2) {
      d2 = j(i2 * i2 + n2 * n2), c2 = t3 / d2;
      const e4 = i2 / d2;
      u2 = n2 > 0 ? U(e4) : -U(e4);
    } else {
      c2 = j(o2 * o2 + a2 * a2), d2 = t3 / c2;
      const e4 = o2 / c2;
      u2 = N - (a2 > 0 ? U(-e4) : -U(e4));
    }
    const e3 = H(F(u2)), s3 = z(u2);
    d2 = H(d2), c2 = H(c2), _2 = e3 ? H((o2 / c2 + s3) / e3 / A, 9) : 0, p2 = e3 ? H((n2 / d2 - s3) / e3 / A, 9) : 0, u2 = H(u2 / A);
  } else d2 = i2, c2 = a2, u2 = _2 = p2 = 0;
  return (e2 = s2 || e2) && (f2 += e2.x * i2 + e2.y * o2, g2 += e2.x * n2 + e2.y * a2, s2 || (f2 -= e2.x, g2 -= e2.y)), { x: f2, y: g2, scaleX: d2, scaleY: c2, rotation: u2, skewX: _2, skewY: p2 };
}, withScale(t2, e2, s2 = e2) {
  const r2 = t2;
  if (!e2 || !s2) {
    const { a: r3, b: i2, c: n2, d: o2 } = t2;
    i2 || n2 ? s2 = (r3 * o2 - i2 * n2) / (e2 = j(r3 * r3 + i2 * i2)) : (e2 = r3, s2 = o2);
  }
  return r2.scaleX = e2, r2.scaleY = s2, r2;
}, reset(t2) {
  Q.set(t2);
} };
var Q = q;
var { float: J } = I;
var { toInnerPoint: Z, toOuterPoint: $ } = q;
var { sin: K, cos: tt, abs: et, sqrt: st, atan2: rt, min: it, round: nt } = Math;
var ot = { defaultPoint: { x: 0, y: 0 }, tempPoint: {}, tempRadiusPoint: {}, set(t2, e2 = 0, s2 = 0) {
  t2.x = e2, t2.y = s2;
}, setRadius(t2, e2, r2) {
  t2.radiusX = e2, t2.radiusY = s(r2) ? e2 : r2;
}, copy(t2, e2) {
  t2.x = e2.x, t2.y = e2.y;
}, copyFrom(t2, e2, s2) {
  t2.x = e2, t2.y = s2;
}, round(t2, e2) {
  t2.x = e2 ? nt(t2.x - 0.5) + 0.5 : nt(t2.x), t2.y = e2 ? nt(t2.y - 0.5) + 0.5 : nt(t2.y);
}, move(t2, e2, s2) {
  d(e2) ? (t2.x += e2.x, t2.y += e2.y) : (t2.x += e2, t2.y += s2);
}, scale(t2, e2, s2 = e2) {
  t2.x && (t2.x *= e2), t2.y && (t2.y *= s2);
}, scaleOf(t2, e2, s2, r2 = s2) {
  t2.x += (t2.x - e2.x) * (s2 - 1), t2.y += (t2.y - e2.y) * (r2 - 1);
}, rotate(t2, e2, s2) {
  s2 || (s2 = at.defaultPoint);
  const r2 = tt(e2 *= A), i2 = K(e2), n2 = t2.x - s2.x, o2 = t2.y - s2.y;
  t2.x = s2.x + n2 * r2 - o2 * i2, t2.y = s2.y + n2 * i2 + o2 * r2;
}, tempToInnerOf(t2, e2) {
  const { tempPoint: s2 } = at;
  return lt(s2, t2), Z(e2, s2, s2), s2;
}, tempToOuterOf(t2, e2) {
  const { tempPoint: s2 } = at;
  return lt(s2, t2), $(e2, s2, s2), s2;
}, tempToInnerRadiusPointOf(t2, e2) {
  const { tempRadiusPoint: s2 } = at;
  return lt(s2, t2), at.toInnerRadiusPointOf(t2, e2, s2), s2;
}, copyRadiusPoint: (t2, e2, s2, r2) => (lt(t2, e2), dt(t2, s2, r2), t2), toInnerRadiusPointOf(t2, e2, s2) {
  s2 || (s2 = t2), Z(e2, t2, s2), s2.radiusX = Math.abs(t2.radiusX / e2.scaleX), s2.radiusY = Math.abs(t2.radiusY / e2.scaleY);
}, toInnerOf(t2, e2, s2) {
  Z(e2, t2, s2);
}, toOuterOf(t2, e2, s2) {
  $(e2, t2, s2);
}, getCenter: (t2, e2) => ({ x: t2.x + (e2.x - t2.x) / 2, y: t2.y + (e2.y - t2.y) / 2 }), getCenterX: (t2, e2) => t2 + (e2 - t2) / 2, getCenterY: (t2, e2) => t2 + (e2 - t2) / 2, getDistance: (t2, e2) => ht(t2.x, t2.y, e2.x, e2.y), getDistanceFrom(t2, e2, s2, r2) {
  const i2 = et(s2 - t2), n2 = et(r2 - e2);
  return st(i2 * i2 + n2 * n2);
}, getMinDistanceFrom: (t2, e2, s2, r2, i2, n2) => it(ht(t2, e2, s2, r2), ht(s2, r2, i2, n2)), getAngle: (t2, e2) => ct(t2, e2) / A, getRotation: (t2, e2, s2, r2) => (r2 || (r2 = e2), at.getRadianFrom(t2.x, t2.y, e2.x, e2.y, s2.x, s2.y, r2.x, r2.y) / A), getRadianFrom(t2, e2, r2, i2, n2, o2, a2, h2) {
  s(a2) && (a2 = r2, h2 = i2);
  const l2 = t2 - r2, d2 = e2 - i2, c2 = n2 - a2, u2 = o2 - h2;
  return Math.atan2(l2 * u2 - d2 * c2, l2 * c2 + d2 * u2);
}, getAtan2: (t2, e2) => rt(e2.y - t2.y, e2.x - t2.x), getDistancePoint(t2, e2, s2, r2, i2) {
  const n2 = ct(t2, e2);
  return i2 && (t2 = e2), r2 || (e2 = {}), e2.x = t2.x + tt(n2) * s2, e2.y = t2.y + K(n2) * s2, e2;
}, toNumberPoints(t2) {
  let e2 = t2;
  return d(t2[0]) && (e2 = [], t2.forEach((t3) => e2.push(t3.x, t3.y))), e2;
}, isSame: (t2, e2) => J(t2.x) === J(e2.x) && J(t2.y) === J(e2.y), reset(t2) {
  at.reset(t2);
} };
var at = ot;
var { getDistanceFrom: ht, copy: lt, setRadius: dt, getAtan2: ct } = at;
var ut = class _ut {
  constructor(t2, e2) {
    this.set(t2, e2);
  }
  set(t2, e2) {
    return d(t2) ? ot.copy(this, t2) : ot.set(this, t2, e2), this;
  }
  get() {
    const { x: t2, y: e2 } = this;
    return { x: t2, y: e2 };
  }
  clone() {
    return new _ut(this);
  }
  move(t2, e2) {
    return ot.move(this, t2, e2), this;
  }
  scale(t2, e2) {
    return ot.scale(this, t2, e2), this;
  }
  scaleOf(t2, e2, s2) {
    return ot.scaleOf(this, t2, e2, s2), this;
  }
  rotate(t2, e2) {
    return ot.rotate(this, t2, e2), this;
  }
  rotateOf(t2, e2) {
    return ot.rotate(this, e2, t2), this;
  }
  getRotation(t2, e2, s2) {
    return ot.getRotation(this, t2, e2, s2);
  }
  toInnerOf(t2, e2) {
    return ot.toInnerOf(this, t2, e2), this;
  }
  toOuterOf(t2, e2) {
    return ot.toOuterOf(this, t2, e2), this;
  }
  getCenter(t2) {
    return new _ut(ot.getCenter(this, t2));
  }
  getDistance(t2) {
    return ot.getDistance(this, t2);
  }
  getDistancePoint(t2, e2, s2, r2) {
    return new _ut(ot.getDistancePoint(this, t2, e2, s2, r2));
  }
  getAngle(t2) {
    return ot.getAngle(this, t2);
  }
  getAtan2(t2) {
    return ot.getAtan2(this, t2);
  }
  isSame(t2) {
    return ot.isSame(this, t2);
  }
  reset() {
    return ot.reset(this), this;
  }
};
var _t = new ut();
var pt = class _pt {
  constructor(t2, e2, s2, r2, i2, n2) {
    this.set(t2, e2, s2, r2, i2, n2);
  }
  set(t2, e2, s2, r2, i2, n2) {
    return d(t2) ? q.copy(this, t2) : q.set(this, t2, e2, s2, r2, i2, n2), this;
  }
  setWith(t2) {
    return q.copy(this, t2), this.scaleX = t2.scaleX, this.scaleY = t2.scaleY, this;
  }
  get() {
    const { a: t2, b: e2, c: s2, d: r2, e: i2, f: n2 } = this;
    return { a: t2, b: e2, c: s2, d: r2, e: i2, f: n2 };
  }
  clone() {
    return new _pt(this);
  }
  translate(t2, e2) {
    return q.translate(this, t2, e2), this;
  }
  translateInner(t2, e2) {
    return q.translateInner(this, t2, e2), this;
  }
  scale(t2, e2) {
    return q.scale(this, t2, e2), this;
  }
  scaleWith(t2, e2) {
    return q.scale(this, t2, e2), this.scaleX *= t2, this.scaleY *= e2 || t2, this;
  }
  pixelScale(t2) {
    return q.pixelScale(this, t2), this;
  }
  scaleOfOuter(t2, e2, s2) {
    return q.scaleOfOuter(this, t2, e2, s2), this;
  }
  scaleOfInner(t2, e2, s2) {
    return q.scaleOfInner(this, t2, e2, s2), this;
  }
  rotate(t2) {
    return q.rotate(this, t2), this;
  }
  rotateOfOuter(t2, e2) {
    return q.rotateOfOuter(this, t2, e2), this;
  }
  rotateOfInner(t2, e2) {
    return q.rotateOfInner(this, t2, e2), this;
  }
  skew(t2, e2) {
    return q.skew(this, t2, e2), this;
  }
  skewOfOuter(t2, e2, s2) {
    return q.skewOfOuter(this, t2, e2, s2), this;
  }
  skewOfInner(t2, e2, s2) {
    return q.skewOfInner(this, t2, e2, s2), this;
  }
  multiply(t2) {
    return q.multiply(this, t2), this;
  }
  multiplyParent(t2) {
    return q.multiplyParent(this, t2), this;
  }
  divide(t2) {
    return q.divide(this, t2), this;
  }
  divideParent(t2) {
    return q.divideParent(this, t2), this;
  }
  invert() {
    return q.invert(this), this;
  }
  invertWith() {
    return q.invert(this), this.scaleX = 1 / this.scaleX, this.scaleY = 1 / this.scaleY, this;
  }
  toOuterPoint(t2, e2, s2) {
    q.toOuterPoint(this, t2, e2, s2);
  }
  toInnerPoint(t2, e2, s2) {
    q.toInnerPoint(this, t2, e2, s2);
  }
  setLayout(t2, e2, s2) {
    return q.setLayout(this, t2, e2, s2), this;
  }
  getLayout(t2, e2, s2) {
    return q.getLayout(this, t2, e2, s2);
  }
  withScale(t2, e2) {
    return q.withScale(this, t2, e2);
  }
  reset() {
    q.reset(this);
  }
};
var ft = new pt();
var gt = { tempPointBounds: {}, setPoint(t2, e2, s2) {
  t2.minX = t2.maxX = e2, t2.minY = t2.maxY = s2;
}, addPoint(t2, e2, s2) {
  t2.minX = e2 < t2.minX ? e2 : t2.minX, t2.minY = s2 < t2.minY ? s2 : t2.minY, t2.maxX = e2 > t2.maxX ? e2 : t2.maxX, t2.maxY = s2 > t2.maxY ? s2 : t2.maxY;
}, addBounds(t2, e2, s2, r2, i2) {
  yt(t2, e2, s2), yt(t2, e2 + r2, s2 + i2);
}, copy(t2, e2) {
  t2.minX = e2.minX, t2.minY = e2.minY, t2.maxX = e2.maxX, t2.maxY = e2.maxY;
}, addPointBounds(t2, e2) {
  t2.minX = e2.minX < t2.minX ? e2.minX : t2.minX, t2.minY = e2.minY < t2.minY ? e2.minY : t2.minY, t2.maxX = e2.maxX > t2.maxX ? e2.maxX : t2.maxX, t2.maxY = e2.maxY > t2.maxY ? e2.maxY : t2.maxY;
}, toBounds(t2, e2) {
  e2.x = t2.minX, e2.y = t2.minY, e2.width = t2.maxX - t2.minX, e2.height = t2.maxY - t2.minY;
} };
var { addPoint: yt } = gt;
var mt;
var xt;
!(function(t2) {
  t2[t2.top = 0] = "top", t2[t2.right = 1] = "right", t2[t2.bottom = 2] = "bottom", t2[t2.left = 3] = "left";
})(mt || (mt = {})), (function(t2) {
  t2[t2.topLeft = 0] = "topLeft", t2[t2.top = 1] = "top", t2[t2.topRight = 2] = "topRight", t2[t2.right = 3] = "right", t2[t2.bottomRight = 4] = "bottomRight", t2[t2.bottom = 5] = "bottom", t2[t2.bottomLeft = 6] = "bottomLeft", t2[t2.left = 7] = "left", t2[t2.center = 8] = "center", t2[t2["top-left"] = 0] = "top-left", t2[t2["top-right"] = 2] = "top-right", t2[t2["bottom-right"] = 4] = "bottom-right", t2[t2["bottom-left"] = 6] = "bottom-left";
})(xt || (xt = {}));
var wt = [{ x: 0, y: 0 }, { x: 0.5, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 0.5 }, { x: 1, y: 1 }, { x: 0.5, y: 1 }, { x: 0, y: 1 }, { x: 0, y: 0.5 }, { x: 0.5, y: 0.5 }];
wt.forEach((t2) => t2.type = "percent");
var bt = { directionData: wt, tempPoint: {}, get: Bt, toPoint(t2, e2, s2, r2, i2, n2) {
  const o2 = Bt(t2);
  s2.x = o2.x, s2.y = o2.y, "percent" === o2.type && (s2.x *= e2.width, s2.y *= e2.height, i2 && (n2 || (s2.x -= i2.x, s2.y -= i2.y), o2.x && (s2.x -= 1 === o2.x ? i2.width : 0.5 === o2.x ? o2.x * i2.width : 0), o2.y && (s2.y -= 1 === o2.y ? i2.height : 0.5 === o2.y ? o2.y * i2.height : 0))), r2 || (s2.x += e2.x, s2.y += e2.y);
}, getPoint: (t2, e2, s2) => (s2 || (s2 = {}), bt.toPoint(t2, e2, s2, true), s2) };
function Bt(t2) {
  return i(t2) ? wt[xt[t2]] : t2;
}
var { toPoint: vt } = bt;
var kt = { toPoint(t2, e2, s2, r2, i2, n2) {
  vt(t2, s2, r2, i2, e2, n2);
} };
var { tempPointBounds: Ct, setPoint: Ot, addPoint: Tt, toBounds: Pt } = gt;
var { toOuterPoint: St } = q;
var { float: Lt, fourNumber: Rt } = I;
var { floor: Et, ceil: It } = Math;
var Mt;
var At;
var Wt;
var Nt;
var Yt = {};
var Dt = {};
var Xt = {};
var zt = { tempBounds: Xt, set(t2, e2 = 0, s2 = 0, r2 = 0, i2 = 0) {
  t2.x = e2, t2.y = s2, t2.width = r2, t2.height = i2;
}, copy(t2, e2) {
  t2.x = e2.x, t2.y = e2.y, t2.width = e2.width, t2.height = e2.height;
}, copyAndSpread(t2, e2, s2, r2, i2) {
  const { x: n2, y: o2, width: a2, height: h2 } = e2;
  if (l(s2)) {
    const e3 = Rt(s2);
    r2 ? Ft.set(t2, n2 + e3[3], o2 + e3[0], a2 - e3[1] - e3[3], h2 - e3[2] - e3[0]) : Ft.set(t2, n2 - e3[3], o2 - e3[0], a2 + e3[1] + e3[3], h2 + e3[2] + e3[0]);
  } else r2 && (s2 = -s2), Ft.set(t2, n2 - s2, o2 - s2, a2 + 2 * s2, h2 + 2 * s2);
  i2 && ("width" === i2 ? (t2.y = o2, t2.height = h2) : (t2.x = n2, t2.width = a2));
}, minX: (t2) => t2.width > 0 ? t2.x : t2.x + t2.width, minY: (t2) => t2.height > 0 ? t2.y : t2.y + t2.height, maxX: (t2) => t2.width > 0 ? t2.x + t2.width : t2.x, maxY: (t2) => t2.height > 0 ? t2.y + t2.height : t2.y, move(t2, e2, s2) {
  t2.x += e2, t2.y += s2;
}, scroll(t2, e2) {
  t2.x += e2.scrollX, t2.y += e2.scrollY;
}, getByMove: (t2, e2, s2) => (t2 = Object.assign({}, t2), Ft.move(t2, e2, s2), t2), toOffsetOutBounds(t2, e2, s2) {
  e2 ? jt(e2, t2) : e2 = t2, s2 || (s2 = t2), e2.offsetX = Ft.maxX(s2), e2.offsetY = Ft.maxY(s2), Ft.move(e2, -e2.offsetX, -e2.offsetY);
}, scale(t2, e2, s2 = e2, r2) {
  r2 || ot.scale(t2, e2, s2), t2.width *= e2, t2.height *= s2;
}, scaleOf(t2, e2, s2, r2 = s2) {
  ot.scaleOf(t2, e2, s2, r2), t2.width *= s2, t2.height *= r2;
}, tempToOuterOf: (t2, e2) => (Ft.copy(Xt, t2), Ft.toOuterOf(Xt, e2), Xt), getOuterOf: (t2, e2) => (t2 = Object.assign({}, t2), Ft.toOuterOf(t2, e2), t2), toOuterOf(t2, e2, s2) {
  if (s2 || (s2 = t2), 0 === e2.b && 0 === e2.c) {
    const { a: r2, d: i2, e: n2, f: o2 } = e2;
    r2 > 0 ? (s2.width = t2.width * r2, s2.x = n2 + t2.x * r2) : (s2.width = t2.width * -r2, s2.x = n2 + t2.x * r2 - s2.width), i2 > 0 ? (s2.height = t2.height * i2, s2.y = o2 + t2.y * i2) : (s2.height = t2.height * -i2, s2.y = o2 + t2.y * i2 - s2.height);
  } else Yt.x = t2.x, Yt.y = t2.y, St(e2, Yt, Dt), Ot(Ct, Dt.x, Dt.y), Yt.x = t2.x + t2.width, St(e2, Yt, Dt), Tt(Ct, Dt.x, Dt.y), Yt.y = t2.y + t2.height, St(e2, Yt, Dt), Tt(Ct, Dt.x, Dt.y), Yt.x = t2.x, St(e2, Yt, Dt), Tt(Ct, Dt.x, Dt.y), Pt(Ct, s2);
}, toInnerOf(t2, e2, s2) {
  s2 || (s2 = t2), Ft.move(s2, -e2.e, -e2.f), Ft.scale(s2, 1 / e2.a, 1 / e2.d);
}, getFitMatrix(t2, e2, s2 = 1) {
  const r2 = Math.min(s2, Ft.getFitScale(t2, e2));
  return new pt(r2, 0, 0, r2, -e2.x * r2, -e2.y * r2);
}, getFitScale(t2, e2, s2) {
  const r2 = t2.width / e2.width, i2 = t2.height / e2.height;
  return s2 ? Math.max(r2, i2) : Math.min(r2, i2);
}, put(t2, e2, s2 = "center", r2 = 1, n2 = true, o2) {
  o2 || (o2 = e2), i(r2) && (r2 = Ft.getFitScale(t2, e2, "cover" === r2)), Xt.width = n2 ? e2.width *= r2 : e2.width * r2, Xt.height = n2 ? e2.height *= r2 : e2.height * r2, kt.toPoint(s2, Xt, t2, o2, true, true);
}, getSpread(t2, e2, s2) {
  const r2 = {};
  return Ft.copyAndSpread(r2, t2, e2, false, s2), r2;
}, spread(t2, e2, s2) {
  Ft.copyAndSpread(t2, t2, e2, false, s2);
}, shrink(t2, e2, s2) {
  Ft.copyAndSpread(t2, t2, e2, true, s2);
}, ceil(t2) {
  const { x: e2, y: s2 } = t2;
  t2.x = Et(t2.x), t2.y = Et(t2.y), t2.width = e2 > t2.x ? It(t2.width + e2 - t2.x) : It(t2.width), t2.height = s2 > t2.y ? It(t2.height + s2 - t2.y) : It(t2.height);
}, unsign(t2) {
  t2.width < 0 && (t2.x += t2.width, t2.width = -t2.width), t2.height < 0 && (t2.y += t2.height, t2.height = -t2.height);
}, float(t2, e2) {
  t2.x = Lt(t2.x, e2), t2.y = Lt(t2.y, e2), t2.width = Lt(t2.width, e2), t2.height = Lt(t2.height, e2);
}, add(t2, e2, s2) {
  Mt = t2.x + t2.width, At = t2.y + t2.height, Wt = e2.x, Nt = e2.y, s2 || (Wt += e2.width, Nt += e2.height), Mt = Mt > Wt ? Mt : Wt, At = At > Nt ? At : Nt, t2.x = t2.x < e2.x ? t2.x : e2.x, t2.y = t2.y < e2.y ? t2.y : e2.y, t2.width = Mt - t2.x, t2.height = At - t2.y;
}, addList(t2, e2) {
  Ft.setListWithFn(t2, e2, void 0, true);
}, setList(t2, e2, s2 = false) {
  Ft.setListWithFn(t2, e2, void 0, s2);
}, addListWithFn(t2, e2, s2) {
  Ft.setListWithFn(t2, e2, s2, true);
}, setListWithFn(t2, e2, s2, r2 = false) {
  let i2, n2 = true;
  for (let o2 = 0, a2 = e2.length; o2 < a2; o2++) i2 = s2 ? s2(e2[o2], o2) : e2[o2], i2 && (i2.width || i2.height) && (n2 ? (n2 = false, r2 || jt(t2, i2)) : Ut(t2, i2));
  n2 && Ft.reset(t2);
}, setPoints(t2, e2) {
  e2.forEach((t3, e3) => 0 === e3 ? Ot(Ct, t3.x, t3.y) : Tt(Ct, t3.x, t3.y)), Pt(Ct, t2);
}, setPoint(t2, e2) {
  Ft.set(t2, e2.x, e2.y);
}, addPoint(t2, e2) {
  Ut(t2, e2, true);
}, getPoints(t2) {
  const { x: e2, y: s2, width: r2, height: i2 } = t2;
  return [{ x: e2, y: s2 }, { x: e2 + r2, y: s2 }, { x: e2 + r2, y: s2 + i2 }, { x: e2, y: s2 + i2 }];
}, hitRadiusPoint: (t2, e2, s2) => (s2 && (e2 = ot.tempToInnerRadiusPointOf(e2, s2)), e2.x >= t2.x - e2.radiusX && e2.x <= t2.x + t2.width + e2.radiusX && e2.y >= t2.y - e2.radiusY && e2.y <= t2.y + t2.height + e2.radiusY), hitPoint: (t2, e2, s2) => (s2 && (e2 = ot.tempToInnerOf(e2, s2)), e2.x >= t2.x && e2.x <= t2.x + t2.width && e2.y >= t2.y && e2.y <= t2.y + t2.height), hit: (t2, e2, s2) => (s2 && (e2 = Ft.tempToOuterOf(e2, s2)), !(t2.y + t2.height < e2.y || e2.y + e2.height < t2.y || t2.x + t2.width < e2.x || e2.x + e2.width < t2.x)), includes: (t2, e2, s2) => (s2 && (e2 = Ft.tempToOuterOf(e2, s2)), t2.x <= e2.x && t2.y <= e2.y && t2.x + t2.width >= e2.x + e2.width && t2.y + t2.height >= e2.y + e2.height), getIntersectData(t2, e2, s2) {
  if (s2 && (e2 = Ft.tempToOuterOf(e2, s2)), !Ft.hit(t2, e2)) return { x: 0, y: 0, width: 0, height: 0 };
  let { x: r2, y: i2, width: n2, height: o2 } = e2;
  return Mt = r2 + n2, At = i2 + o2, Wt = t2.x + t2.width, Nt = t2.y + t2.height, r2 = r2 > t2.x ? r2 : t2.x, i2 = i2 > t2.y ? i2 : t2.y, Mt = Mt < Wt ? Mt : Wt, At = At < Nt ? At : Nt, n2 = Mt - r2, o2 = At - i2, { x: r2, y: i2, width: n2, height: o2 };
}, intersect(t2, e2, s2) {
  Ft.copy(t2, Ft.getIntersectData(t2, e2, s2));
}, isSame: (t2, e2) => t2.x === e2.x && t2.y === e2.y && t2.width === e2.width && t2.height === e2.height, isEmpty: (t2) => 0 === t2.x && 0 === t2.y && 0 === t2.width && 0 === t2.height, hasSize: (t2) => t2.width && t2.height, reset(t2) {
  Ft.set(t2);
} };
var Ft = zt;
var { add: Ut, copy: jt } = Ft;
var Ht = class _Ht {
  get minX() {
    return zt.minX(this);
  }
  get minY() {
    return zt.minY(this);
  }
  get maxX() {
    return zt.maxX(this);
  }
  get maxY() {
    return zt.maxY(this);
  }
  constructor(t2, e2, s2, r2) {
    this.set(t2, e2, s2, r2);
  }
  set(t2, e2, s2, r2) {
    return d(t2) ? zt.copy(this, t2) : zt.set(this, t2, e2, s2, r2), this;
  }
  get() {
    const { x: t2, y: e2, width: s2, height: r2 } = this;
    return { x: t2, y: e2, width: s2, height: r2 };
  }
  clone() {
    return new _Ht(this);
  }
  move(t2, e2) {
    return zt.move(this, t2, e2), this;
  }
  scale(t2, e2, s2) {
    return zt.scale(this, t2, e2, s2), this;
  }
  scaleOf(t2, e2, s2) {
    return zt.scaleOf(this, t2, e2, s2), this;
  }
  toOuterOf(t2, e2) {
    return zt.toOuterOf(this, t2, e2), this;
  }
  toInnerOf(t2, e2) {
    return zt.toInnerOf(this, t2, e2), this;
  }
  getFitMatrix(t2, e2) {
    return zt.getFitMatrix(this, t2, e2);
  }
  put(t2, e2, s2) {
    zt.put(this, t2, e2, s2);
  }
  spread(t2, e2) {
    return zt.spread(this, t2, e2), this;
  }
  shrink(t2, e2) {
    return zt.shrink(this, t2, e2), this;
  }
  ceil() {
    return zt.ceil(this), this;
  }
  unsign() {
    return zt.unsign(this), this;
  }
  float(t2) {
    return zt.float(this, t2), this;
  }
  add(t2) {
    return zt.add(this, t2), this;
  }
  addList(t2) {
    return zt.setList(this, t2, true), this;
  }
  setList(t2) {
    return zt.setList(this, t2), this;
  }
  addListWithFn(t2, e2) {
    return zt.setListWithFn(this, t2, e2, true), this;
  }
  setListWithFn(t2, e2) {
    return zt.setListWithFn(this, t2, e2), this;
  }
  setPoint(t2) {
    return zt.setPoint(this, t2), this;
  }
  setPoints(t2) {
    return zt.setPoints(this, t2), this;
  }
  addPoint(t2) {
    return zt.addPoint(this, t2), this;
  }
  getPoints() {
    return zt.getPoints(this);
  }
  hitPoint(t2, e2) {
    return zt.hitPoint(this, t2, e2);
  }
  hitRadiusPoint(t2, e2) {
    return zt.hitRadiusPoint(this, t2, e2);
  }
  hit(t2, e2) {
    return zt.hit(this, t2, e2);
  }
  includes(t2, e2) {
    return zt.includes(this, t2, e2);
  }
  intersect(t2, e2) {
    return zt.intersect(this, t2, e2), this;
  }
  getIntersect(t2, e2) {
    return new _Ht(zt.getIntersectData(this, t2, e2));
  }
  isSame(t2) {
    return zt.isSame(this, t2);
  }
  isEmpty() {
    return zt.isEmpty(this);
  }
  reset() {
    zt.reset(this);
  }
};
var Vt = new Ht();
var Gt = class {
  constructor(t2, e2, s2, r2, i2, n2) {
    d(t2) ? this.copy(t2) : this.set(t2, e2, s2, r2, i2, n2);
  }
  set(t2 = 0, e2 = 0, s2 = 0, r2 = 0, i2 = 0, n2 = 0) {
    this.top = t2, this.right = e2, this.bottom = s2, this.left = r2, this.width = i2, this.height = n2;
  }
  copy(t2) {
    const { top: e2, right: s2, bottom: r2, left: i2, width: n2, height: o2 } = t2;
    this.set(e2, s2, r2, i2, n2, o2);
  }
  getBoundsFrom(t2) {
    const { top: e2, right: s2, bottom: r2, left: i2, width: n2, height: o2 } = this;
    return new Ht(i2, e2, n2 || t2.width - i2 - s2, o2 || t2.height - e2 - r2);
  }
};
var qt = { number: (t2, e2) => d(t2) ? "percent" === t2.type ? t2.value * e2 : t2.value : t2 };
var Qt = { 0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, ".": 1, e: 1, E: 1 };
var { floor: Jt, max: Zt } = Math;
var $t = { toURL(t2, e2) {
  let s2 = encodeURIComponent(t2);
  return "text" === e2 ? s2 = "data:text/plain;charset=utf-8," + s2 : "svg" === e2 && (s2 = "data:image/svg+xml," + s2), s2;
}, image: { hitCanvasSize: 100, maxCacheSize: 4096e3, maxPatternSize: 8847360, crossOrigin: "anonymous", isLarge: (t2, e2, s2, r2) => t2.width * t2.height * (e2 ? e2 * s2 : 1) > (r2 || Kt.maxCacheSize), isSuperLarge: (t2, e2, s2) => Kt.isLarge(t2, e2, s2, Kt.maxPatternSize), getRealURL(t2) {
  const { prefix: e2, suffix: s2 } = Kt;
  return !s2 || t2.startsWith("data:") || t2.startsWith("blob:") || (t2 += (t2.includes("?") ? "&" : "?") + s2), e2 && "/" === t2[0] && (t2 = e2 + t2), t2;
}, resize(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2) {
  const d2 = Zt(Jt(e2 + (r2 || 0)), 1), c2 = Zt(Jt(s2 + (i2 || 0)), 1);
  let u2, _2, p2;
  l2 && (p2 = qt.number(l2.offset, (u2 = "x" === l2.type) ? e2 : s2)) && (u2 || (_2 = true));
  const f2 = $t.origin.createCanvas(_2 ? 2 * d2 : d2, u2 ? 2 * c2 : c2), g2 = f2.getContext("2d");
  if (a2 && (g2.globalAlpha = a2), g2.imageSmoothingEnabled = false !== o2, Kt.canUse(t2)) {
    if (n2) {
      const r3 = e2 / n2.width, i3 = s2 / n2.height;
      g2.setTransform(r3, 0, 0, i3, -n2.x * r3, -n2.y * i3), g2.drawImage(t2, 0, 0, t2.width, t2.height);
    } else g2.drawImage(t2, 0, 0, e2, s2);
    p2 && (g2.drawImage(f2, 0, 0, d2, c2, u2 ? p2 - d2 : d2, u2 ? c2 : p2 - c2, d2, c2), g2.drawImage(f2, 0, 0, d2, c2, u2 ? p2 : d2, u2 ? c2 : p2, d2, c2));
  }
  return f2;
}, canUse: (t2) => t2 && t2.width && !t2.__closed, setPatternTransform(t2, e2, s2) {
  try {
    e2 && t2.setTransform && (t2.setTransform(e2), e2 = void 0);
  } catch (t3) {
  }
  s2 && _.stintSet(s2, "transform", e2);
} } };
var { image: Kt } = $t;
var { randColor: te } = I;
var ee = class _ee {
  constructor(t2) {
    this.repeatMap = {}, this.name = t2;
  }
  static get(t2) {
    return new _ee(t2);
  }
  static set filter(t2) {
    this.filterList = se(t2);
  }
  static set exclude(t2) {
    this.excludeList = se(t2);
  }
  static drawRepaint(t2, e2) {
    const s2 = te();
    t2.fillWorld(e2, s2.replace("1)", ".1)")), t2.strokeWorld(e2, s2);
  }
  static drawBounds(t2, e2, s2) {
    const r2 = "hit" === _ee.showBounds, i2 = t2.__nowWorld, n2 = te();
    r2 && (e2.setWorld(i2), t2.__drawHitPath(e2), e2.fillStyle = n2.replace("1)", ".2)"), e2.fill()), e2.resetTransform(), e2.setStroke(n2, 2), r2 ? e2.stroke() : e2.strokeWorld(i2, n2);
  }
  log(...t2) {
    if (re.enable) {
      if (re.filterList.length && re.filterList.every((t3) => t3 !== this.name)) return;
      if (re.excludeList.length && re.excludeList.some((t3) => t3 === this.name)) return;
      console.log("%c" + this.name, "color:#21ae62", ...t2);
    }
  }
  tip(...t2) {
    re.enable && this.warn(...t2);
  }
  warn(...t2) {
    re.showWarn && console.warn(this.name, ...t2);
  }
  repeat(t2, ...e2) {
    this.repeatMap[t2] || (this.warn("repeat:" + t2, ...e2), this.repeatMap[t2] = true);
  }
  error(...t2) {
    try {
      throw new Error();
    } catch (e2) {
      console.error(this.name, ...t2, e2);
    }
  }
};
function se(t2) {
  return t2 ? i(t2) && (t2 = [t2]) : t2 = [], t2;
}
ee.filterList = [], ee.excludeList = [], ee.showWarn = true;
var re = ee;
var ie = ee.get("RunTime");
var ne = { currentId: 0, currentName: "", idMap: {}, nameMap: {}, nameToIdMap: {}, start(t2, e2) {
  const s2 = g.create(g.RUNTIME);
  return oe.currentId = oe.idMap[s2] = e2 ? performance.now() : Date.now(), oe.currentName = oe.nameMap[s2] = t2, oe.nameToIdMap[t2] = s2, s2;
}, end(t2, e2) {
  const s2 = oe.idMap[t2], r2 = oe.nameMap[t2], i2 = e2 ? (performance.now() - s2) / 1e3 : Date.now() - s2;
  oe.idMap[t2] = oe.nameMap[t2] = oe.nameToIdMap[r2] = void 0, ie.log(r2, i2, "ms");
}, endOfName(t2, e2) {
  const r2 = oe.nameToIdMap[t2];
  s(r2) || oe.end(r2, e2);
} };
var oe = ne;
var ae = [];
var he = { list: {}, add(t2, ...e2) {
  this.list[t2] = true, ae.push(...e2);
}, has(t2, e2) {
  const s2 = this.list[t2];
  return !s2 && e2 && this.need(t2), s2;
}, need(t2) {
  console.error("please install and import plugin: " + (t2.includes("-x") ? "" : "@leafer-in/") + t2);
} };
setTimeout(() => ae.forEach((t2) => he.has(t2, true)));
var le = { editor: (t2) => he.need("editor") };
var de = ee.get("UICreator");
var ce = { list: {}, register(t2) {
  const { __tag: e2 } = t2.prototype;
  ue[e2] && de.repeat(e2), ue[e2] = t2;
}, get(t2, e2, r2, i2, n2, o2) {
  ue[t2] || de.error("not register " + t2);
  const a2 = new ue[t2](e2);
  return s(r2) || (a2.x = r2, i2 && (a2.y = i2), n2 && (a2.width = n2), o2 && (a2.height = o2)), a2;
} };
var { list: ue } = ce;
var _e = ee.get("EventCreator");
var pe = { nameList: {}, register(t2) {
  let e2;
  Object.keys(t2).forEach((s2) => {
    e2 = t2[s2], i(e2) && (fe[e2] && _e.repeat(e2), fe[e2] = t2);
  });
}, changeName(t2, e2) {
  const s2 = fe[t2];
  if (s2) {
    const r2 = Object.keys(s2).find((e3) => s2[e3] === t2);
    r2 && (s2[r2] = e2, fe[e2] = s2);
  }
}, has(t2) {
  return !!this.nameList[t2];
}, get: (t2, ...e2) => new fe[t2](...e2) };
var { nameList: fe } = pe;
var ge = class {
  constructor() {
    this.list = [];
  }
  add(t2) {
    t2.manager = this, this.list.push(t2);
  }
  get(t2) {
    let e2;
    const { list: s2 } = this;
    for (let r3 = 0, i2 = s2.length; r3 < i2; r3++) if (e2 = s2[r3], e2.recycled && e2.isSameSize(t2)) return e2.recycled = false, e2.manager || (e2.manager = this), e2;
    const r2 = le.canvas(t2);
    return this.add(r2), r2;
  }
  recycle(t2) {
    t2.recycled = true;
  }
  clearRecycled() {
    let t2;
    const e2 = [];
    for (let s2 = 0, r2 = this.list.length; s2 < r2; s2++) t2 = this.list[s2], t2.recycled ? t2.destroy() : e2.push(t2);
    this.list = e2;
  }
  clear() {
    this.list.forEach((t2) => {
      t2.destroy();
    }), this.list.length = 0;
  }
  destroy() {
    this.clear();
  }
};
function ye(t2, e2, s2, r2) {
  var i2, n2 = arguments.length, o2 = n2 < 3 ? e2 : null === r2 ? r2 = Object.getOwnPropertyDescriptor(e2, s2) : r2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(t2, e2, s2, r2);
  else for (var a2 = t2.length - 1; a2 >= 0; a2--) (i2 = t2[a2]) && (o2 = (n2 < 3 ? i2(o2) : n2 > 3 ? i2(e2, s2, o2) : i2(e2, s2)) || o2);
  return n2 > 3 && o2 && Object.defineProperty(e2, s2, o2), o2;
}
function me(t2, e2, s2, r2) {
  return new (s2 || (s2 = Promise))(function(i2, n2) {
    function o2(t3) {
      try {
        h2(r2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function a2(t3) {
      try {
        h2(r2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function h2(t3) {
      var e3;
      t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof s2 ? e3 : new s2(function(t4) {
        t4(e3);
      })).then(o2, a2);
    }
    h2((r2 = r2.apply(t2, e2 || [])).next());
  });
}
function xe(t2) {
  return (e2, s2) => {
    t2 || (t2 = s2);
    const r2 = { get() {
      return this.context[t2];
    }, set(e3) {
      this.context[t2] = e3;
    } };
    "strokeCap" === s2 && (r2.set = function(e3) {
      this.context[t2] = "none" === e3 ? "butt" : e3;
    }), Object.defineProperty(e2, s2, r2);
  };
}
var we = [];
function be() {
  return (t2, e2) => {
    we.push(e2);
  };
}
var Be = [];
var ve = class {
  set blendMode(t2) {
    "normal" === t2 && (t2 = "source-over"), this.context.globalCompositeOperation = t2;
  }
  get blendMode() {
    return this.context.globalCompositeOperation;
  }
  set dashPattern(t2) {
    this.context.setLineDash(t2 || Be);
  }
  get dashPattern() {
    return this.context.getLineDash();
  }
  __bindContext() {
    let t2;
    we.forEach((e2) => {
      t2 = this.context[e2], t2 && (this[e2] = t2.bind(this.context));
    }), this.textBaseline = "alphabetic";
  }
  setTransform(t2, e2, s2, r2, i2, n2) {
  }
  resetTransform() {
  }
  getTransform() {
  }
  save() {
  }
  restore() {
  }
  transform(t2, e2, s2, r2, i2, n2) {
    d(t2) ? this.context.transform(t2.a, t2.b, t2.c, t2.d, t2.e, t2.f) : this.context.transform(t2, e2, s2, r2, i2, n2);
  }
  translate(t2, e2) {
  }
  scale(t2, e2) {
  }
  rotate(t2) {
  }
  fill(t2, e2) {
  }
  stroke(t2) {
  }
  clip(t2, e2) {
  }
  fillRect(t2, e2, s2, r2) {
  }
  strokeRect(t2, e2, s2, r2) {
  }
  clearRect(t2, e2, s2, r2) {
  }
  drawImage(t2, e2, s2, r2, i2, n2, o2, a2, h2) {
    switch (arguments.length) {
      case 9:
        if (e2 < 0) {
          const t3 = -e2 / r2 * a2;
          r2 += e2, e2 = 0, n2 += t3, a2 -= t3;
        }
        if (s2 < 0) {
          const t3 = -s2 / i2 * h2;
          i2 += s2, s2 = 0, o2 += t3, h2 -= t3;
        }
        this.context.drawImage(t2, e2, s2, r2, i2, n2, o2, a2, h2);
        break;
      case 5:
        this.context.drawImage(t2, e2, s2, r2, i2);
        break;
      case 3:
        this.context.drawImage(t2, e2, s2);
    }
  }
  beginPath() {
  }
  moveTo(t2, e2) {
  }
  lineTo(t2, e2) {
  }
  bezierCurveTo(t2, e2, s2, r2, i2, n2) {
  }
  quadraticCurveTo(t2, e2, s2, r2) {
  }
  closePath() {
  }
  arc(t2, e2, s2, r2, i2, n2) {
  }
  arcTo(t2, e2, s2, r2, i2) {
  }
  ellipse(t2, e2, s2, r2, i2, n2, o2, a2) {
  }
  rect(t2, e2, s2, r2) {
  }
  roundRect(t2, e2, s2, r2, i2) {
  }
  createConicGradient(t2, e2, s2) {
  }
  createLinearGradient(t2, e2, s2, r2) {
  }
  createPattern(t2, e2) {
  }
  createRadialGradient(t2, e2, s2, r2, i2, n2) {
  }
  fillText(t2, e2, s2, r2) {
  }
  measureText(t2) {
  }
  strokeText(t2, e2, s2, r2) {
  }
  destroy() {
    this.context = null;
  }
};
ye([xe("imageSmoothingEnabled")], ve.prototype, "smooth", void 0), ye([xe("imageSmoothingQuality")], ve.prototype, "smoothLevel", void 0), ye([xe("globalAlpha")], ve.prototype, "opacity", void 0), ye([xe()], ve.prototype, "fillStyle", void 0), ye([xe()], ve.prototype, "strokeStyle", void 0), ye([xe("lineWidth")], ve.prototype, "strokeWidth", void 0), ye([xe("lineCap")], ve.prototype, "strokeCap", void 0), ye([xe("lineJoin")], ve.prototype, "strokeJoin", void 0), ye([xe("lineDashOffset")], ve.prototype, "dashOffset", void 0), ye([xe()], ve.prototype, "miterLimit", void 0), ye([xe()], ve.prototype, "shadowBlur", void 0), ye([xe()], ve.prototype, "shadowColor", void 0), ye([xe()], ve.prototype, "shadowOffsetX", void 0), ye([xe()], ve.prototype, "shadowOffsetY", void 0), ye([xe()], ve.prototype, "filter", void 0), ye([xe()], ve.prototype, "font", void 0), ye([xe()], ve.prototype, "fontKerning", void 0), ye([xe()], ve.prototype, "fontStretch", void 0), ye([xe()], ve.prototype, "fontVariantCaps", void 0), ye([xe()], ve.prototype, "textAlign", void 0), ye([xe()], ve.prototype, "textBaseline", void 0), ye([xe()], ve.prototype, "textRendering", void 0), ye([xe()], ve.prototype, "wordSpacing", void 0), ye([xe()], ve.prototype, "letterSpacing", void 0), ye([xe()], ve.prototype, "direction", void 0), ye([be()], ve.prototype, "setTransform", null), ye([be()], ve.prototype, "resetTransform", null), ye([be()], ve.prototype, "getTransform", null), ye([be()], ve.prototype, "save", null), ye([be()], ve.prototype, "restore", null), ye([be()], ve.prototype, "translate", null), ye([be()], ve.prototype, "scale", null), ye([be()], ve.prototype, "rotate", null), ye([be()], ve.prototype, "fill", null), ye([be()], ve.prototype, "stroke", null), ye([be()], ve.prototype, "clip", null), ye([be()], ve.prototype, "fillRect", null), ye([be()], ve.prototype, "strokeRect", null), ye([be()], ve.prototype, "clearRect", null), ye([be()], ve.prototype, "beginPath", null), ye([be()], ve.prototype, "moveTo", null), ye([be()], ve.prototype, "lineTo", null), ye([be()], ve.prototype, "bezierCurveTo", null), ye([be()], ve.prototype, "quadraticCurveTo", null), ye([be()], ve.prototype, "closePath", null), ye([be()], ve.prototype, "arc", null), ye([be()], ve.prototype, "arcTo", null), ye([be()], ve.prototype, "ellipse", null), ye([be()], ve.prototype, "rect", null), ye([be()], ve.prototype, "roundRect", null), ye([be()], ve.prototype, "createConicGradient", null), ye([be()], ve.prototype, "createLinearGradient", null), ye([be()], ve.prototype, "createPattern", null), ye([be()], ve.prototype, "createRadialGradient", null), ye([be()], ve.prototype, "fillText", null), ye([be()], ve.prototype, "measureText", null), ye([be()], ve.prototype, "strokeText", null);
var { copy: ke, multiplyParent: Ce, pixelScale: Oe } = q;
var { round: Te } = Math;
var Pe = new Ht();
var Se = new Ht();
var Le = { width: 1, height: 1, pixelRatio: 1 };
var Re = ["width", "height", "pixelRatio"];
var Ee = class extends ve {
  get width() {
    return this.size.width;
  }
  get height() {
    return this.size.height;
  }
  get pixelRatio() {
    return this.size.pixelRatio;
  }
  get pixelWidth() {
    return this.width * this.pixelRatio || 0;
  }
  get pixelHeight() {
    return this.height * this.pixelRatio || 0;
  }
  get pixelSnap() {
    return this.config.pixelSnap;
  }
  set pixelSnap(t2) {
    this.config.pixelSnap = t2;
  }
  get allowBackgroundColor() {
    return this.view && this.parentView;
  }
  constructor(t2, e2) {
    super(), this.size = {}, this.worldTransform = {}, t2 || (t2 = Le), this.manager = e2, this.innerId = g.create(g.CNAVAS);
    const { width: s2, height: r2, pixelRatio: i2 } = t2;
    this.autoLayout = !s2 || !r2, this.size.pixelRatio = i2 || $t.devicePixelRatio, this.config = t2, this.init();
  }
  init() {
  }
  __createContext() {
    const { view: t2 } = this, { contextSettings: e2 } = this.config;
    this.context = e2 ? t2.getContext("2d", e2) : t2.getContext("2d"), this.__bindContext();
  }
  export(t2, e2) {
  }
  toBlob(t2, e2) {
  }
  toDataURL(t2, e2) {
  }
  saveAs(t2, e2) {
  }
  resize(t2, e2 = true) {
    if (this.isSameSize(t2)) return;
    let s2;
    this.context && !this.unreal && e2 && this.width && (s2 = this.getSameCanvas(), s2.copyWorld(this));
    const r2 = this.size;
    _.copyAttrs(r2, t2, Re), Re.forEach((t3) => r2[t3] || (r2[t3] = 1)), this.bounds = new Ht(0, 0, this.width, this.height), this.updateViewSize(), this.updateClientBounds(), this.context && (this.smooth = this.config.smooth, !this.unreal && s2 && (this.clearWorld(s2.bounds), this.copyWorld(s2), s2.recycle()));
  }
  updateViewSize() {
  }
  updateClientBounds() {
  }
  getClientBounds(t2) {
    return t2 && this.updateClientBounds(), this.clientBounds || this.bounds;
  }
  startAutoLayout(t2, e2) {
  }
  stopAutoLayout() {
  }
  setCursor(t2) {
  }
  setWorld(t2, e2) {
    const { pixelRatio: s2, pixelSnap: r2 } = this, i2 = this.worldTransform;
    e2 && Ce(t2, e2, i2), Oe(t2, s2, i2), r2 && !t2.ignorePixelSnap && (t2.half && t2.half * s2 % 2 ? (i2.e = Te(i2.e - 0.5) + 0.5, i2.f = Te(i2.f - 0.5) + 0.5) : (i2.e = Te(i2.e), i2.f = Te(i2.f))), this.setTransform(i2.a, i2.b, i2.c, i2.d, i2.e, i2.f);
  }
  useWorldTransform(t2) {
    t2 && (this.worldTransform = t2);
    const e2 = this.worldTransform;
    e2 && this.setTransform(e2.a, e2.b, e2.c, e2.d, e2.e, e2.f);
  }
  setStroke(t2, e2, s2, r2) {
    e2 && (this.strokeWidth = e2), t2 && (this.strokeStyle = t2), s2 && this.setStrokeOptions(s2, r2);
  }
  setStrokeOptions(t2, e2) {
    let { strokeCap: r2, strokeJoin: i2, dashPattern: n2, dashOffset: o2, miterLimit: a2 } = t2;
    e2 && (e2.strokeCap && (r2 = e2.strokeCap), e2.strokeJoin && (i2 = e2.strokeJoin), s(e2.dashPattern) || (n2 = e2.dashPattern), s(e2.dashOffset) || (o2 = e2.dashOffset), e2.miterLimit && (a2 = e2.miterLimit)), this.strokeCap = r2, this.strokeJoin = i2, this.dashPattern = n2, this.dashOffset = o2, this.miterLimit = a2;
  }
  saveBlendMode(t2) {
    this.savedBlendMode = this.blendMode, this.blendMode = t2;
  }
  restoreBlendMode() {
    this.blendMode = this.savedBlendMode;
  }
  hitFill(t2, e2) {
    return true;
  }
  hitStroke(t2, e2) {
    return true;
  }
  hitPixel(t2, e2, s2 = 1) {
    return true;
  }
  setWorldShadow(t2, e2, s2, r2) {
    const { pixelRatio: i2 } = this;
    this.shadowOffsetX = t2 * i2, this.shadowOffsetY = e2 * i2, this.shadowBlur = s2 * i2, this.shadowColor = r2 || "black";
  }
  setWorldBlur(t2) {
    const { pixelRatio: e2 } = this;
    this.filter = `blur(${t2 * e2}px)`;
  }
  copyWorld(t2, e2, s2, r2, i2) {
    r2 && (this.blendMode = r2), e2 ? (this.setTempPixelBounds(e2, i2), s2 ? (this.setTempPixelBounds2(s2, i2), s2 = Se) : s2 = Pe, this.drawImage(t2.view, Pe.x, Pe.y, Pe.width, Pe.height, s2.x, s2.y, s2.width, s2.height)) : this.drawImage(t2.view, 0, 0), r2 && (this.blendMode = "source-over");
  }
  copyWorldToInner(t2, e2, s2, r2, i2) {
    e2.b || e2.c ? (this.save(), this.resetTransform(), this.copyWorld(t2, e2, zt.tempToOuterOf(s2, e2), r2, i2), this.restore()) : (r2 && (this.blendMode = r2), this.setTempPixelBounds(e2, i2), this.drawImage(t2.view, Pe.x, Pe.y, Pe.width, Pe.height, s2.x, s2.y, s2.width, s2.height), r2 && (this.blendMode = "source-over"));
  }
  copyWorldByReset(t2, e2, s2, r2, i2, n2) {
    this.resetTransform(), this.copyWorld(t2, e2, s2, r2, n2), i2 || this.useWorldTransform();
  }
  useGrayscaleAlpha(t2) {
    let e2, s2;
    this.setTempPixelBounds(t2, true, true);
    const { context: r2 } = this, i2 = r2.getImageData(Pe.x, Pe.y, Pe.width, Pe.height), { data: n2 } = i2;
    for (let t3 = 0, r3 = n2.length; t3 < r3; t3 += 4) s2 = 0.299 * n2[t3] + 0.587 * n2[t3 + 1] + 0.114 * n2[t3 + 2], (e2 = n2[t3 + 3]) && (n2[t3 + 3] = 255 === e2 ? s2 : e2 * (s2 / 255));
    r2.putImageData(i2, Pe.x, Pe.y);
  }
  useMask(t2, e2, s2) {
    this.copyWorld(t2, e2, s2, "destination-in");
  }
  useEraser(t2, e2, s2) {
    this.copyWorld(t2, e2, s2, "destination-out");
  }
  fillWorld(t2, e2, s2, r2) {
    s2 && (this.blendMode = s2), this.fillStyle = e2, this.setTempPixelBounds(t2, r2), this.fillRect(Pe.x, Pe.y, Pe.width, Pe.height), s2 && (this.blendMode = "source-over");
  }
  strokeWorld(t2, e2, s2, r2) {
    s2 && (this.blendMode = s2), this.strokeStyle = e2, this.setTempPixelBounds(t2, r2), this.strokeRect(Pe.x, Pe.y, Pe.width, Pe.height), s2 && (this.blendMode = "source-over");
  }
  clipWorld(t2, e2 = true) {
    this.beginPath(), this.setTempPixelBounds(t2, e2), this.rect(Pe.x, Pe.y, Pe.width, Pe.height), this.clip();
  }
  clipUI(t2) {
    t2.windingRule ? this.clip(t2.windingRule) : this.clip();
  }
  clearWorld(t2, e2 = true) {
    this.setTempPixelBounds(t2, e2), this.clearRect(Pe.x, Pe.y, Pe.width, Pe.height);
  }
  clear() {
    const { pixelRatio: t2 } = this;
    this.clearRect(0, 0, this.width * t2 + 2, this.height * t2 + 2);
  }
  setTempPixelBounds(t2, e2, s2) {
    this.copyToPixelBounds(Pe, t2, e2, s2);
  }
  setTempPixelBounds2(t2, e2, s2) {
    this.copyToPixelBounds(Se, t2, e2, s2);
  }
  copyToPixelBounds(t2, e2, s2, r2) {
    t2.set(e2), r2 && t2.intersect(this.bounds), t2.scale(this.pixelRatio), s2 && t2.ceil();
  }
  isSameSize(t2) {
    return this.width === t2.width && this.height === t2.height && (!t2.pixelRatio || this.pixelRatio === t2.pixelRatio);
  }
  getSameCanvas(t2, e2) {
    const { size: s2, pixelSnap: r2 } = this, i2 = this.manager ? this.manager.get(s2) : le.canvas(Object.assign({}, s2));
    return i2.save(), t2 && (ke(i2.worldTransform, this.worldTransform), i2.useWorldTransform()), e2 && (i2.smooth = this.smooth), i2.pixelSnap !== r2 && (i2.pixelSnap = r2), i2;
  }
  recycle(t2) {
    this.recycled || (this.restore(), t2 ? this.clearWorld(t2) : this.clear(), this.manager ? this.manager.recycle(this) : this.destroy());
  }
  updateRender(t2) {
  }
  unrealCanvas() {
  }
  destroy() {
    this.manager = this.view = this.parentView = null;
  }
};
var Ie = { creator: {}, parse(t2, e2) {
}, convertToCanvasData(t2, e2) {
} };
var Me = { N: 21, D: 22, X: 23, G: 24, F: 25, O: 26, P: 27, U: 28 };
var Ae = Object.assign({ M: 1, m: 10, L: 2, l: 20, H: 3, h: 30, V: 4, v: 40, C: 5, c: 50, S: 6, s: 60, Q: 7, q: 70, T: 8, t: 80, A: 9, a: 90, Z: 11, z: 11, R: 12 }, Me);
var We = { M: 3, m: 3, L: 3, l: 3, H: 2, h: 2, V: 2, v: 2, C: 7, c: 7, S: 5, s: 5, Q: 5, q: 5, T: 3, t: 3, A: 8, a: 8, Z: 1, z: 1, N: 5, D: 9, X: 6, G: 9, F: 5, O: 7, P: 4, U: 6 };
var Ne = { m: 10, l: 20, H: 3, h: 30, V: 4, v: 40, c: 50, S: 6, s: 60, q: 70, T: 8, t: 80, A: 9, a: 90 };
var Ye = Object.assign(Object.assign({}, Ne), Me);
var De = Ae;
var Xe = {};
for (let t2 in De) Xe[De[t2]] = t2;
var ze = {};
for (let t2 in De) ze[De[t2]] = We[t2];
var Fe = { drawRoundRect(t2, e2, s2, r2, i2, n2) {
  const o2 = I.fourNumber(n2, Math.min(r2 / 2, i2 / 2)), a2 = e2 + r2, h2 = s2 + i2;
  o2[0] ? t2.moveTo(e2 + o2[0], s2) : t2.moveTo(e2, s2), o2[1] ? t2.arcTo(a2, s2, a2, h2, o2[1]) : t2.lineTo(a2, s2), o2[2] ? t2.arcTo(a2, h2, e2, h2, o2[2]) : t2.lineTo(a2, h2), o2[3] ? t2.arcTo(e2, h2, e2, s2, o2[3]) : t2.lineTo(e2, h2), o2[0] ? t2.arcTo(e2, s2, a2, s2, o2[0]) : t2.lineTo(e2, s2);
} };
var { sin: Ue, cos: je, hypot: He, atan2: Ve, ceil: Ge, abs: qe, PI: Qe, sqrt: Je, pow: Ze } = Math;
var { setPoint: $e, addPoint: Ke } = gt;
var { set: ts, toNumberPoints: es } = ot;
var { M: ss, L: rs, C: is, Q: ns, Z: os } = Ae;
var as = {};
var hs = { points(t2, e2, s2, r2) {
  let i2 = es(e2);
  if (t2.push(ss, i2[0], i2[1]), s2 && i2.length > 5) {
    let e3, n2, o2, a2, h2, l2, d2, c2, u2, _2, p2, f2, g2, y2, m2, x2 = i2.length;
    const w2 = true === s2 ? 0.5 : s2;
    r2 && (i2 = [i2[x2 - 2], i2[x2 - 1], ...i2, i2[0], i2[1], i2[2], i2[3]], x2 = i2.length);
    for (let s3 = 2; s3 < x2 - 2; s3 += 2) e3 = i2[s3 - 2], n2 = i2[s3 - 1], o2 = i2[s3], a2 = i2[s3 + 1], h2 = i2[s3 + 2], l2 = i2[s3 + 3], p2 = o2 - e3, f2 = a2 - n2, g2 = Je(Ze(p2, 2) + Ze(f2, 2)), y2 = Je(Ze(h2 - o2, 2) + Ze(l2 - a2, 2)), (g2 || y2) && (m2 = g2 + y2, g2 = w2 * g2 / m2, y2 = w2 * y2 / m2, h2 -= e3, l2 -= n2, d2 = o2 - g2 * h2, c2 = a2 - g2 * l2, 2 === s3 ? r2 || t2.push(ns, d2, c2, o2, a2) : (p2 || f2) && t2.push(is, u2, _2, d2, c2, o2, a2), u2 = o2 + y2 * h2, _2 = a2 + y2 * l2);
    r2 || t2.push(ns, u2, _2, i2[x2 - 2], i2[x2 - 1]);
  } else for (let e3 = 2, s3 = i2.length; e3 < s3; e3 += 2) t2.push(rs, i2[e3], i2[e3 + 1]);
  r2 && t2.push(os);
}, rect(t2, e2, s2, r2, i2) {
  Ie.creator.path = t2, Ie.creator.moveTo(e2, s2).lineTo(e2 + r2, s2).lineTo(e2 + r2, s2 + i2).lineTo(e2, s2 + i2).lineTo(e2, s2);
}, roundRect(t2, e2, s2, r2, i2, n2) {
  Ie.creator.path = [], Fe.drawRoundRect(Ie.creator, e2, s2, r2, i2, n2), t2.push(...Ie.convertToCanvasData(Ie.creator.path, true));
}, arcTo(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2, d2) {
  const c2 = r2 - e2, u2 = i2 - s2, _2 = n2 - r2, p2 = o2 - i2;
  let f2 = Ve(u2, c2), g2 = Ve(p2, _2);
  const y2 = He(c2, u2), m2 = He(_2, p2);
  let x2 = g2 - f2;
  if (x2 < 0 && (x2 += W), y2 < 1e-12 || m2 < 1e-12 || x2 < 1e-12 || qe(x2 - Qe) < 1e-12) return t2 && t2.push(rs, r2, i2), h2 && ($e(h2, e2, s2), Ke(h2, r2, i2)), d2 && ts(d2, e2, s2), void (l2 && ts(l2, r2, i2));
  const w2 = c2 * p2 - _2 * u2 < 0, b2 = w2 ? -1 : 1, B2 = a2 / je(x2 / 2), v2 = r2 + B2 * je(f2 + x2 / 2 + N * b2), k2 = i2 + B2 * Ue(f2 + x2 / 2 + N * b2);
  return f2 -= N * b2, g2 -= N * b2, cs(t2, v2, k2, a2, a2, 0, f2 / A, g2 / A, w2, h2, l2, d2);
}, arc: (t2, e2, s2, r2, i2, n2, o2, a2, h2, l2) => cs(t2, e2, s2, r2, r2, 0, i2, n2, o2, a2, h2, l2), ellipse(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2, d2, c2) {
  const u2 = n2 * A, _2 = Ue(u2), p2 = je(u2);
  let f2 = o2 * A, g2 = a2 * A;
  f2 > Qe && (f2 -= W), g2 < 0 && (g2 += W);
  let y2 = g2 - f2;
  y2 < 0 ? y2 += W : y2 > W && (y2 -= W), h2 && (y2 -= W);
  const m2 = Ge(qe(y2 / N)), x2 = y2 / m2, w2 = Ue(x2 / 4), b2 = 8 / 3 * w2 * w2 / Ue(x2 / 2);
  g2 = f2 + x2;
  let B2, v2, k2, C2, O2, T2, P2, S2, L2 = je(f2), R2 = Ue(f2), E2 = k2 = p2 * r2 * L2 - _2 * i2 * R2, I3 = C2 = _2 * r2 * L2 + p2 * i2 * R2, M2 = e2 + k2, Y3 = s2 + C2;
  t2 && t2.push(t2.length ? rs : ss, M2, Y3), l2 && $e(l2, M2, Y3), c2 && ts(c2, M2, Y3);
  for (let n3 = 0; n3 < m2; n3++) B2 = je(g2), v2 = Ue(g2), k2 = p2 * r2 * B2 - _2 * i2 * v2, C2 = _2 * r2 * B2 + p2 * i2 * v2, O2 = e2 + E2 - b2 * (p2 * r2 * R2 + _2 * i2 * L2), T2 = s2 + I3 - b2 * (_2 * r2 * R2 - p2 * i2 * L2), P2 = e2 + k2 + b2 * (p2 * r2 * v2 + _2 * i2 * B2), S2 = s2 + C2 + b2 * (_2 * r2 * v2 - p2 * i2 * B2), t2 && t2.push(is, O2, T2, P2, S2, e2 + k2, s2 + C2), l2 && ds(e2 + E2, s2 + I3, O2, T2, P2, S2, e2 + k2, s2 + C2, l2, true), E2 = k2, I3 = C2, L2 = B2, R2 = v2, f2 = g2, g2 += x2;
  d2 && ts(d2, e2 + k2, s2 + C2);
}, quadraticCurveTo(t2, e2, s2, r2, i2, n2, o2) {
  t2.push(is, (e2 + 2 * r2) / 3, (s2 + 2 * i2) / 3, (n2 + 2 * r2) / 3, (o2 + 2 * i2) / 3, n2, o2);
}, toTwoPointBoundsByQuadraticCurve(t2, e2, s2, r2, i2, n2, o2, a2) {
  ds(t2, e2, (t2 + 2 * s2) / 3, (e2 + 2 * r2) / 3, (i2 + 2 * s2) / 3, (n2 + 2 * r2) / 3, i2, n2, o2, a2);
}, toTwoPointBounds(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2) {
  const d2 = [];
  let c2, u2, _2, p2, f2, g2, y2, m2, x2 = t2, w2 = s2, b2 = i2, B2 = o2;
  for (let t3 = 0; t3 < 2; ++t3) if (1 == t3 && (x2 = e2, w2 = r2, b2 = n2, B2 = a2), c2 = -3 * x2 + 9 * w2 - 9 * b2 + 3 * B2, u2 = 6 * x2 - 12 * w2 + 6 * b2, _2 = 3 * w2 - 3 * x2, Math.abs(c2) < 1e-12) {
    if (Math.abs(u2) < 1e-12) continue;
    p2 = -_2 / u2, 0 < p2 && p2 < 1 && d2.push(p2);
  } else y2 = u2 * u2 - 4 * _2 * c2, m2 = Math.sqrt(y2), y2 < 0 || (f2 = (-u2 + m2) / (2 * c2), 0 < f2 && f2 < 1 && d2.push(f2), g2 = (-u2 - m2) / (2 * c2), 0 < g2 && g2 < 1 && d2.push(g2));
  l2 ? Ke(h2, t2, e2) : $e(h2, t2, e2), Ke(h2, o2, a2);
  for (let l3 = 0, c3 = d2.length; l3 < c3; l3++) ls(d2[l3], t2, e2, s2, r2, i2, n2, o2, a2, as), Ke(h2, as.x, as.y);
}, getPointAndSet(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2) {
  const d2 = 1 - t2, c2 = d2 * d2 * d2, u2 = 3 * d2 * d2 * t2, _2 = 3 * d2 * t2 * t2, p2 = t2 * t2 * t2;
  l2.x = c2 * e2 + u2 * r2 + _2 * n2 + p2 * a2, l2.y = c2 * s2 + u2 * i2 + _2 * o2 + p2 * h2;
}, getPoint(t2, e2, s2, r2, i2, n2, o2, a2, h2) {
  const l2 = {};
  return ls(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2), l2;
}, getDerivative(t2, e2, s2, r2, i2) {
  const n2 = 1 - t2;
  return 3 * n2 * n2 * (s2 - e2) + 6 * n2 * t2 * (r2 - s2) + 3 * t2 * t2 * (i2 - r2);
} };
var { getPointAndSet: ls, toTwoPointBounds: ds, ellipse: cs } = hs;
var { sin: us, cos: _s, sqrt: ps, atan2: fs } = Math;
var { ellipse: gs } = hs;
var ys = { ellipticalArc(t2, e2, s2, r2, i2, n2, o2, a2, h2, l2, d2) {
  const c2 = (h2 - e2) / 2, u2 = (l2 - s2) / 2, _2 = n2 * A, p2 = us(_2), f2 = _s(_2), g2 = -f2 * c2 - p2 * u2, y2 = -f2 * u2 + p2 * c2, m2 = r2 * r2, x2 = i2 * i2, w2 = y2 * y2, b2 = g2 * g2, B2 = m2 * x2 - m2 * w2 - x2 * b2;
  let v2 = 0;
  if (B2 < 0) {
    const t3 = ps(1 - B2 / (m2 * x2));
    r2 *= t3, i2 *= t3;
  } else v2 = (o2 === a2 ? -1 : 1) * ps(B2 / (m2 * w2 + x2 * b2));
  const k2 = v2 * r2 * y2 / i2, C2 = -v2 * i2 * g2 / r2, O2 = fs((y2 - C2) / i2, (g2 - k2) / r2), T2 = fs((-y2 - C2) / i2, (-g2 - k2) / r2);
  let P2 = T2 - O2;
  0 === a2 && P2 > 0 ? P2 -= W : 1 === a2 && P2 < 0 && (P2 += W);
  const S2 = e2 + c2 + f2 * k2 - p2 * C2, L2 = s2 + u2 + p2 * k2 + f2 * C2, R2 = P2 < 0 ? 1 : 0;
  d2 || $t.ellipseToCurve ? gs(t2, S2, L2, r2, i2, n2, O2 / A, T2 / A, R2) : r2 !== i2 || n2 ? t2.push(Ae.G, S2, L2, r2, i2, n2, O2 / A, T2 / A, R2) : t2.push(Ae.O, S2, L2, r2, O2 / A, T2 / A, R2);
} };
var ms = { toCommand: (t2) => [], toNode: (t2) => [] };
var { M: xs, m: ws, L: bs, l: Bs, H: vs, h: ks, V: Cs, v: Os, C: Ts, c: Ps, S: Ss, s: Ls, Q: Rs, q: Es, T: Is, t: Ms, A: As, a: Ws, Z: Ns, z: Ys, N: Ds, D: Xs, X: zs, G: Fs, F: Us, O: js, P: Hs, U: Vs } = Ae;
var { rect: Gs, roundRect: qs, arcTo: Qs, arc: Js, ellipse: Zs, quadraticCurveTo: $s } = hs;
var { ellipticalArc: Ks } = ys;
var tr = ee.get("PathConvert");
var er = {};
var sr = { current: { dot: 0 }, stringify(t2, e2) {
  let s2, r2, i2, n2 = 0, o2 = t2.length, a2 = "";
  for (; n2 < o2; ) {
    r2 = t2[n2], s2 = ze[r2], a2 += r2 === i2 ? " " : Xe[r2];
    for (let r3 = 1; r3 < s2; r3++) a2 += I.float(t2[n2 + r3], e2), r3 === s2 - 1 || (a2 += " ");
    i2 = r2, n2 += s2;
  }
  return a2;
}, parse(t2, e2) {
  let s2, r2, i2, n2 = "";
  const o2 = [], a2 = e2 ? Ye : Ne;
  for (let e3 = 0, h2 = t2.length; e3 < h2; e3++) r2 = t2[e3], Qt[r2] ? ("." === r2 && (rr.dot && (ir(o2, n2), n2 = ""), rr.dot++), "0" === n2 && "." !== r2 && (ir(o2, n2), n2 = ""), n2 += r2) : Ae[r2] ? (n2 && (ir(o2, n2), n2 = ""), rr.name = Ae[r2], rr.length = We[r2], rr.index = 0, ir(o2, rr.name), !s2 && a2[r2] && (s2 = true)) : "-" === r2 || "+" === r2 ? "e" === i2 || "E" === i2 ? n2 += r2 : (n2 && ir(o2, n2), n2 = r2) : n2 && (ir(o2, n2), n2 = ""), i2 = r2;
  return n2 && ir(o2, n2), s2 ? sr.toCanvasData(o2, e2) : o2;
}, toCanvasData(t2, e2) {
  let s2, r2, i2, n2, o2, a2 = 0, h2 = 0, l2 = 0, d2 = 0, c2 = 0, u2 = t2.length;
  const _2 = [];
  for (; c2 < u2; ) {
    switch (i2 = t2[c2], i2) {
      case ws:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2;
      case xs:
        a2 = t2[c2 + 1], h2 = t2[c2 + 2], _2.push(xs, a2, h2), c2 += 3;
        break;
      case ks:
        t2[c2 + 1] += a2;
      case vs:
        a2 = t2[c2 + 1], _2.push(bs, a2, h2), c2 += 2;
        break;
      case Os:
        t2[c2 + 1] += h2;
      case Cs:
        h2 = t2[c2 + 1], _2.push(bs, a2, h2), c2 += 2;
        break;
      case Bs:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2;
      case bs:
        a2 = t2[c2 + 1], h2 = t2[c2 + 2], _2.push(bs, a2, h2), c2 += 3;
        break;
      case Ls:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2, t2[c2 + 3] += a2, t2[c2 + 4] += h2, i2 = Ss;
      case Ss:
        o2 = n2 === Ts || n2 === Ss, l2 = o2 ? 2 * a2 - s2 : t2[c2 + 1], d2 = o2 ? 2 * h2 - r2 : t2[c2 + 2], s2 = t2[c2 + 1], r2 = t2[c2 + 2], a2 = t2[c2 + 3], h2 = t2[c2 + 4], _2.push(Ts, l2, d2, s2, r2, a2, h2), c2 += 5;
        break;
      case Ps:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2, t2[c2 + 3] += a2, t2[c2 + 4] += h2, t2[c2 + 5] += a2, t2[c2 + 6] += h2, i2 = Ts;
      case Ts:
        s2 = t2[c2 + 3], r2 = t2[c2 + 4], a2 = t2[c2 + 5], h2 = t2[c2 + 6], _2.push(Ts, t2[c2 + 1], t2[c2 + 2], s2, r2, a2, h2), c2 += 7;
        break;
      case Ms:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2, i2 = Is;
      case Is:
        o2 = n2 === Rs || n2 === Is, s2 = o2 ? 2 * a2 - s2 : t2[c2 + 1], r2 = o2 ? 2 * h2 - r2 : t2[c2 + 2], e2 ? $s(_2, a2, h2, s2, r2, t2[c2 + 1], t2[c2 + 2]) : _2.push(Rs, s2, r2, t2[c2 + 1], t2[c2 + 2]), a2 = t2[c2 + 1], h2 = t2[c2 + 2], c2 += 3;
        break;
      case Es:
        t2[c2 + 1] += a2, t2[c2 + 2] += h2, t2[c2 + 3] += a2, t2[c2 + 4] += h2, i2 = Rs;
      case Rs:
        s2 = t2[c2 + 1], r2 = t2[c2 + 2], e2 ? $s(_2, a2, h2, s2, r2, t2[c2 + 3], t2[c2 + 4]) : _2.push(Rs, s2, r2, t2[c2 + 3], t2[c2 + 4]), a2 = t2[c2 + 3], h2 = t2[c2 + 4], c2 += 5;
        break;
      case Ws:
        t2[c2 + 6] += a2, t2[c2 + 7] += h2;
      case As:
        Ks(_2, a2, h2, t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], t2[c2 + 4], t2[c2 + 5], t2[c2 + 6], t2[c2 + 7], e2), a2 = t2[c2 + 6], h2 = t2[c2 + 7], c2 += 8;
        break;
      case Ys:
      case Ns:
        _2.push(Ns), c2++;
        break;
      case Ds:
        a2 = t2[c2 + 1], h2 = t2[c2 + 2], e2 ? Gs(_2, a2, h2, t2[c2 + 3], t2[c2 + 4]) : nr(_2, t2, c2, 5), c2 += 5;
        break;
      case Xs:
        a2 = t2[c2 + 1], h2 = t2[c2 + 2], e2 ? qs(_2, a2, h2, t2[c2 + 3], t2[c2 + 4], [t2[c2 + 5], t2[c2 + 6], t2[c2 + 7], t2[c2 + 8]]) : nr(_2, t2, c2, 9), c2 += 9;
        break;
      case zs:
        a2 = t2[c2 + 1], h2 = t2[c2 + 2], e2 ? qs(_2, a2, h2, t2[c2 + 3], t2[c2 + 4], t2[c2 + 5]) : nr(_2, t2, c2, 6), c2 += 6;
        break;
      case Fs:
        Zs(e2 ? _2 : nr(_2, t2, c2, 9), t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], t2[c2 + 4], t2[c2 + 5], t2[c2 + 6], t2[c2 + 7], t2[c2 + 8], null, er), a2 = er.x, h2 = er.y, c2 += 9;
        break;
      case Us:
        e2 ? Zs(_2, t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], t2[c2 + 4], 0, 0, 360, false) : nr(_2, t2, c2, 5), a2 = t2[c2 + 1] + t2[c2 + 3], h2 = t2[c2 + 2], c2 += 5;
        break;
      case js:
        Js(e2 ? _2 : nr(_2, t2, c2, 7), t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], t2[c2 + 4], t2[c2 + 5], t2[c2 + 6], null, er), a2 = er.x, h2 = er.y, c2 += 7;
        break;
      case Hs:
        e2 ? Js(_2, t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], 0, 360, false) : nr(_2, t2, c2, 4), a2 = t2[c2 + 1] + t2[c2 + 3], h2 = t2[c2 + 2], c2 += 4;
        break;
      case Vs:
        Qs(e2 ? _2 : nr(_2, t2, c2, 6), a2, h2, t2[c2 + 1], t2[c2 + 2], t2[c2 + 3], t2[c2 + 4], t2[c2 + 5], null, er), a2 = er.x, h2 = er.y, c2 += 6;
        break;
      default:
        return tr.error(`command: ${i2} [index:${c2}]`, t2), _2;
    }
    n2 = i2;
  }
  return _2;
}, objectToCanvasData(t2) {
  if (t2[0].name.length > 1) return ms.toCommand(t2);
  {
    const e2 = [];
    return t2.forEach((t3) => {
      switch (t3.name) {
        case "M":
          e2.push(xs, t3.x, t3.y);
          break;
        case "L":
          e2.push(bs, t3.x, t3.y);
          break;
        case "C":
          e2.push(Ts, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
          break;
        case "Q":
          e2.push(Rs, t3.x1, t3.y1, t3.x, t3.y);
          break;
        case "Z":
          e2.push(Ns);
      }
    }), e2;
  }
}, copyData(t2, e2, s2, r2) {
  for (let i2 = s2, n2 = s2 + r2; i2 < n2; i2++) t2.push(e2[i2]);
}, pushData(t2, e2) {
  rr.index === rr.length && (rr.index = 1, t2.push(rr.name)), t2.push(Number(e2)), rr.index++, rr.dot = 0;
} };
var { current: rr, pushData: ir, copyData: nr } = sr;
var { M: or, L: ar, C: hr, Q: lr, Z: dr, N: cr, D: ur, X: _r, G: pr, F: fr, O: gr, P: yr, U: mr } = Ae;
var { getMinDistanceFrom: xr, getRadianFrom: wr } = ot;
var { tan: br, min: Br, abs: vr } = Math;
var kr = {};
var Cr = { beginPath(t2) {
  t2.length = 0;
}, moveTo(t2, e2, s2) {
  t2.push(or, e2, s2);
}, lineTo(t2, e2, s2) {
  t2.push(ar, e2, s2);
}, bezierCurveTo(t2, e2, s2, r2, i2, n2, o2) {
  t2.push(hr, e2, s2, r2, i2, n2, o2);
}, quadraticCurveTo(t2, e2, s2, r2, i2) {
  t2.push(lr, e2, s2, r2, i2);
}, closePath(t2) {
  t2.push(dr);
}, rect(t2, e2, s2, r2, i2) {
  t2.push(cr, e2, s2, r2, i2);
}, roundRect(t2, e2, s2, r2, i2, n2) {
  if (o(n2)) t2.push(_r, e2, s2, r2, i2, n2);
  else {
    const o2 = I.fourNumber(n2);
    o2 ? t2.push(ur, e2, s2, r2, i2, ...o2) : t2.push(cr, e2, s2, r2, i2);
  }
}, ellipse(t2, e2, s2, i2, n2, o2, a2, h2, l2) {
  if (i2 === n2) return Tr(t2, e2, s2, i2, a2, h2, l2);
  r(o2) ? t2.push(fr, e2, s2, i2, n2) : (r(a2) && (a2 = 0), r(h2) && (h2 = 360), t2.push(pr, e2, s2, i2, n2, o2, a2, h2, l2 ? 1 : 0));
}, arc(t2, e2, s2, i2, n2, o2, a2) {
  r(n2) ? t2.push(yr, e2, s2, i2) : (r(n2) && (n2 = 0), r(o2) && (o2 = 360), t2.push(gr, e2, s2, i2, n2, o2, a2 ? 1 : 0));
}, arcTo(t2, e2, r2, i2, n2, o2, a2, h2) {
  if (!s(a2)) {
    const t3 = xr(a2, h2, e2, r2, i2, n2);
    o2 = Br(o2, Br(t3 / 2, t3 / 2 * vr(br(wr(a2, h2, e2, r2, i2, n2) / 2))));
  }
  t2.push(mr, e2, r2, i2, n2, o2);
}, drawEllipse(t2, e2, s2, i2, n2, o2, a2, h2, l2) {
  hs.ellipse(null, e2, s2, i2, n2, r(o2) ? 0 : o2, r(a2) ? 0 : a2, r(h2) ? 360 : h2, l2, null, null, kr), t2.push(or, kr.x, kr.y), Or(t2, e2, s2, i2, n2, o2, a2, h2, l2);
}, drawArc(t2, e2, s2, i2, n2, o2, a2) {
  hs.arc(null, e2, s2, i2, r(n2) ? 0 : n2, r(o2) ? 360 : o2, a2, null, null, kr), t2.push(or, kr.x, kr.y), Tr(t2, e2, s2, i2, n2, o2, a2);
}, drawPoints(t2, e2, s2, r2) {
  hs.points(t2, e2, s2, r2);
} };
var { ellipse: Or, arc: Tr } = Cr;
var { moveTo: Pr, lineTo: Sr, quadraticCurveTo: Lr, bezierCurveTo: Rr, closePath: Er, beginPath: Ir, rect: Mr, roundRect: Ar, ellipse: Wr, arc: Nr, arcTo: Yr, drawEllipse: Dr, drawArc: Xr, drawPoints: zr } = Cr;
var Fr = class {
  set path(t2) {
    this.__path = t2;
  }
  get path() {
    return this.__path;
  }
  constructor(t2) {
    this.set(t2);
  }
  set(t2) {
    return this.__path = t2 ? i(t2) ? Ie.parse(t2) : t2 : [], this;
  }
  beginPath() {
    return Ir(this.__path), this.paint(), this;
  }
  moveTo(t2, e2) {
    return Pr(this.__path, t2, e2), this.paint(), this;
  }
  lineTo(t2, e2) {
    return Sr(this.__path, t2, e2), this.paint(), this;
  }
  bezierCurveTo(t2, e2, s2, r2, i2, n2) {
    return Rr(this.__path, t2, e2, s2, r2, i2, n2), this.paint(), this;
  }
  quadraticCurveTo(t2, e2, s2, r2) {
    return Lr(this.__path, t2, e2, s2, r2), this.paint(), this;
  }
  closePath() {
    return Er(this.__path), this.paint(), this;
  }
  rect(t2, e2, s2, r2) {
    return Mr(this.__path, t2, e2, s2, r2), this.paint(), this;
  }
  roundRect(t2, e2, s2, r2, i2) {
    return Ar(this.__path, t2, e2, s2, r2, i2), this.paint(), this;
  }
  ellipse(t2, e2, s2, r2, i2, n2, o2, a2) {
    return Wr(this.__path, t2, e2, s2, r2, i2, n2, o2, a2), this.paint(), this;
  }
  arc(t2, e2, s2, r2, i2, n2) {
    return Nr(this.__path, t2, e2, s2, r2, i2, n2), this.paint(), this;
  }
  arcTo(t2, e2, s2, r2, i2) {
    return Yr(this.__path, t2, e2, s2, r2, i2), this.paint(), this;
  }
  drawEllipse(t2, e2, s2, r2, i2, n2, o2, a2) {
    return Dr(this.__path, t2, e2, s2, r2, i2, n2, o2, a2), this.paint(), this;
  }
  drawArc(t2, e2, s2, r2, i2, n2) {
    return Xr(this.__path, t2, e2, s2, r2, i2, n2), this.paint(), this;
  }
  drawPoints(t2, e2, s2) {
    return zr(this.__path, t2, e2, s2), this.paint(), this;
  }
  clearPath() {
    return this.beginPath();
  }
  paint() {
  }
};
var { M: Ur, L: jr, C: Hr, Q: Vr, Z: Gr, N: qr, D: Qr, X: Jr, G: Zr, F: $r, O: Kr, P: ti, U: ei } = Ae;
var si = ee.get("PathDrawer");
var ri = { drawPathByData(t2, e2) {
  if (!e2) return;
  let s2, r2 = 0, i2 = e2.length;
  for (; r2 < i2; ) switch (s2 = e2[r2], s2) {
    case Ur:
      t2.moveTo(e2[r2 + 1], e2[r2 + 2]), r2 += 3;
      break;
    case jr:
      t2.lineTo(e2[r2 + 1], e2[r2 + 2]), r2 += 3;
      break;
    case Hr:
      t2.bezierCurveTo(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], e2[r2 + 5], e2[r2 + 6]), r2 += 7;
      break;
    case Vr:
      t2.quadraticCurveTo(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4]), r2 += 5;
      break;
    case Gr:
      t2.closePath(), r2 += 1;
      break;
    case qr:
      t2.rect(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4]), r2 += 5;
      break;
    case Qr:
      t2.roundRect(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], [e2[r2 + 5], e2[r2 + 6], e2[r2 + 7], e2[r2 + 8]]), r2 += 9;
      break;
    case Jr:
      t2.roundRect(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], e2[r2 + 5]), r2 += 6;
      break;
    case Zr:
      t2.ellipse(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], e2[r2 + 5] * A, e2[r2 + 6] * A, e2[r2 + 7] * A, e2[r2 + 8]), r2 += 9;
      break;
    case $r:
      t2.ellipse(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], 0, 0, W, false), r2 += 5;
      break;
    case Kr:
      t2.arc(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4] * A, e2[r2 + 5] * A, e2[r2 + 6]), r2 += 7;
      break;
    case ti:
      t2.arc(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], 0, W, false), r2 += 4;
      break;
    case ei:
      t2.arcTo(e2[r2 + 1], e2[r2 + 2], e2[r2 + 3], e2[r2 + 4], e2[r2 + 5]), r2 += 6;
      break;
    default:
      return void si.error(`command: ${s2} [index:${r2}]`, e2);
  }
} };
var { M: ii, L: ni, C: oi, Q: ai, Z: hi, N: li, D: di, X: ci, G: ui, F: _i, O: pi, P: fi, U: gi } = Ae;
var { toTwoPointBounds: yi, toTwoPointBoundsByQuadraticCurve: mi, arcTo: xi, arc: wi, ellipse: bi } = hs;
var { addPointBounds: Bi, copy: vi, addPoint: ki, setPoint: Ci, addBounds: Oi, toBounds: Ti } = gt;
var Pi = ee.get("PathBounds");
var Si;
var Li;
var Ri;
var Ei = {};
var Ii = {};
var Mi = {};
var Ai = { toBounds(t2, e2) {
  Ai.toTwoPointBounds(t2, Ii), Ti(Ii, e2);
}, toTwoPointBounds(t2, e2) {
  if (!t2 || !t2.length) return Ci(e2, 0, 0);
  let s2, r2, i2, n2, o2, a2 = 0, h2 = 0, l2 = 0;
  const d2 = t2.length;
  for (; a2 < d2; ) switch (o2 = t2[a2], 0 === a2 && (o2 === hi || o2 === oi || o2 === ai ? Ci(e2, h2, l2) : Ci(e2, t2[a2 + 1], t2[a2 + 2])), o2) {
    case ii:
    case ni:
      h2 = t2[a2 + 1], l2 = t2[a2 + 2], ki(e2, h2, l2), a2 += 3;
      break;
    case oi:
      i2 = t2[a2 + 5], n2 = t2[a2 + 6], yi(h2, l2, t2[a2 + 1], t2[a2 + 2], t2[a2 + 3], t2[a2 + 4], i2, n2, Ei), Bi(e2, Ei), h2 = i2, l2 = n2, a2 += 7;
      break;
    case ai:
      s2 = t2[a2 + 1], r2 = t2[a2 + 2], i2 = t2[a2 + 3], n2 = t2[a2 + 4], mi(h2, l2, s2, r2, i2, n2, Ei), Bi(e2, Ei), h2 = i2, l2 = n2, a2 += 5;
      break;
    case hi:
      a2 += 1;
      break;
    case li:
      h2 = t2[a2 + 1], l2 = t2[a2 + 2], Oi(e2, h2, l2, t2[a2 + 3], t2[a2 + 4]), a2 += 5;
      break;
    case di:
    case ci:
      h2 = t2[a2 + 1], l2 = t2[a2 + 2], Oi(e2, h2, l2, t2[a2 + 3], t2[a2 + 4]), a2 += o2 === di ? 9 : 6;
      break;
    case ui:
      bi(null, t2[a2 + 1], t2[a2 + 2], t2[a2 + 3], t2[a2 + 4], t2[a2 + 5], t2[a2 + 6], t2[a2 + 7], t2[a2 + 8], Ei, Mi), 0 === a2 ? vi(e2, Ei) : Bi(e2, Ei), h2 = Mi.x, l2 = Mi.y, a2 += 9;
      break;
    case _i:
      h2 = t2[a2 + 1], l2 = t2[a2 + 2], Li = t2[a2 + 3], Ri = t2[a2 + 4], Oi(e2, h2 - Li, l2 - Ri, 2 * Li, 2 * Ri), h2 += Li, a2 += 5;
      break;
    case pi:
      wi(null, t2[a2 + 1], t2[a2 + 2], t2[a2 + 3], t2[a2 + 4], t2[a2 + 5], t2[a2 + 6], Ei, Mi), 0 === a2 ? vi(e2, Ei) : Bi(e2, Ei), h2 = Mi.x, l2 = Mi.y, a2 += 7;
      break;
    case fi:
      h2 = t2[a2 + 1], l2 = t2[a2 + 2], Si = t2[a2 + 3], Oi(e2, h2 - Si, l2 - Si, 2 * Si, 2 * Si), h2 += Si, a2 += 4;
      break;
    case gi:
      xi(null, h2, l2, t2[a2 + 1], t2[a2 + 2], t2[a2 + 3], t2[a2 + 4], t2[a2 + 5], Ei, Mi), 0 === a2 ? vi(e2, Ei) : Bi(e2, Ei), h2 = Mi.x, l2 = Mi.y, a2 += 6;
      break;
    default:
      return void Pi.error(`command: ${o2} [index:${a2}]`, t2);
  }
} };
var { M: Wi, L: Ni, Z: Yi } = Ae;
var { getCenterX: Di, getCenterY: Xi } = ot;
var { arcTo: zi } = Cr;
var Fi = { smooth(t2, e2, s2) {
  let r2, i2, n2, o2 = 0, a2 = 0, h2 = 0, d2 = 0, c2 = 0, u2 = 0, _2 = 0, p2 = 0, f2 = 0;
  l(e2) && (e2 = e2[0] || 0);
  const g2 = t2.length, y2 = [];
  for (; o2 < g2; ) {
    switch (r2 = t2[o2], r2) {
      case Wi:
        d2 = p2 = t2[o2 + 1], c2 = f2 = t2[o2 + 2], o2 += 3, t2[o2] === Ni ? (u2 = t2[o2 + 1], _2 = t2[o2 + 2], y2.push(Wi, Di(d2, u2), Xi(c2, _2))) : y2.push(Wi, d2, c2);
        break;
      case Ni:
        switch (a2 = t2[o2 + 1], h2 = t2[o2 + 2], o2 += 3, t2[o2]) {
          case Ni:
            zi(y2, a2, h2, t2[o2 + 1], t2[o2 + 2], e2, p2, f2);
            break;
          case Yi:
            zi(y2, a2, h2, d2, c2, e2, p2, f2);
            break;
          default:
            y2.push(Ni, a2, h2);
        }
        p2 = a2, f2 = h2;
        break;
      case Yi:
        i2 !== Yi && (zi(y2, d2, c2, u2, _2, e2, p2, f2), y2.push(Yi)), o2 += 1;
        break;
      default:
        n2 = ze[r2];
        for (let e3 = 0; e3 < n2; e3++) y2.push(t2[o2 + e3]);
        o2 += n2;
    }
    i2 = r2;
  }
  return r2 !== Yi && (y2[1] = d2, y2[2] = c2), y2;
} };
function Ui(t2) {
  return new Fr(t2);
}
var ji = Ui();
Ie.creator = Ui(), Ie.parse = sr.parse, Ie.convertToCanvasData = sr.toCanvasData;
var { drawRoundRect: Hi } = Fe;
function Vi(t2) {
  !(function(t3) {
    t3 && !t3.roundRect && (t3.roundRect = function(t4, e2, s2, r2, i2) {
      Hi(this, t4, e2, s2, r2, i2);
    });
  })(t2);
}
var Gi = { alphaPixelTypes: ["png", "webp", "svg"], upperCaseTypeMap: {}, mineType: (t2) => !t2 || t2.startsWith("image") ? t2 : ("jpg" === t2 && (t2 = "jpeg"), "image/" + t2), fileType(t2) {
  const e2 = t2.split(".");
  return e2[e2.length - 1];
}, isOpaqueImage(t2) {
  const e2 = qi.fileType(t2);
  return ["jpg", "jpeg"].some((t3) => t3 === e2);
}, getExportOptions(t2) {
  switch (typeof t2) {
    case "object":
      return t2;
    case "number":
      return { quality: t2 };
    case "boolean":
      return { blob: t2 };
    default:
      return {};
  }
} };
var qi = Gi;
qi.alphaPixelTypes.forEach((t2) => qi.upperCaseTypeMap[t2] = t2.toUpperCase());
var Qi = ee.get("TaskProcessor");
var Ji = class {
  constructor(t2) {
    this.parallel = true, this.time = 1, this.id = g.create(g.TASK), this.task = t2;
  }
  run() {
    return me(this, void 0, void 0, function* () {
      try {
        if (this.isComplete || this.runing) return;
        if (this.runing = true, this.canUse && !this.canUse()) return this.cancel();
        this.task && (yield this.task());
      } catch (t2) {
        Qi.error(t2);
      }
    });
  }
  complete() {
    this.isComplete = true, this.parent = this.task = this.canUse = null;
  }
  cancel() {
    this.isCancel = true, this.complete();
  }
};
var Zi = class {
  get total() {
    return this.list.length + this.delayNumber;
  }
  get finishedIndex() {
    return this.isComplete ? 0 : this.index + this.parallelSuccessNumber;
  }
  get remain() {
    return this.isComplete ? this.total : this.total - this.finishedIndex;
  }
  get percent() {
    const { total: t2 } = this;
    let e2 = 0, s2 = 0;
    for (let r2 = 0; r2 < t2; r2++) r2 <= this.finishedIndex ? (s2 += this.list[r2].time, r2 === this.finishedIndex && (e2 = s2)) : e2 += this.list[r2].time;
    return this.isComplete ? 1 : s2 / e2;
  }
  constructor(t2) {
    this.config = { parallel: 6 }, this.list = [], this.running = false, this.isComplete = true, this.index = 0, this.delayNumber = 0, t2 && _.assign(this.config, t2), this.empty();
  }
  add(t2, e2, r2) {
    let i2, n2, a2, h2;
    const l2 = new Ji(t2);
    return l2.parent = this, o(e2) ? h2 = e2 : e2 && (n2 = e2.parallel, i2 = e2.start, a2 = e2.time, h2 = e2.delay, r2 || (r2 = e2.canUse)), a2 && (l2.time = a2), false === n2 && (l2.parallel = false), r2 && (l2.canUse = r2), s(h2) ? this.push(l2, i2) : (this.delayNumber++, setTimeout(() => {
      this.delayNumber && (this.delayNumber--, this.push(l2, i2));
    }, h2)), this.isComplete = false, l2;
  }
  push(t2, e2) {
    this.list.push(t2), false === e2 || this.timer || (this.timer = setTimeout(() => this.start()));
  }
  empty() {
    this.index = 0, this.parallelSuccessNumber = 0, this.list = [], this.parallelList = [], this.delayNumber = 0;
  }
  start() {
    this.running || (this.running = true, this.isComplete = false, this.run());
  }
  pause() {
    clearTimeout(this.timer), this.timer = null, this.running = false;
  }
  resume() {
    this.start();
  }
  skip() {
    this.index++, this.resume();
  }
  stop() {
    this.isComplete = true, this.list.forEach((t2) => {
      t2.isComplete || t2.run();
    }), this.pause(), this.empty();
  }
  run() {
    this.running && (this.setParallelList(), this.parallelList.length > 1 ? this.runParallelTasks() : this.remain ? this.runTask() : this.onComplete());
  }
  runTask() {
    const t2 = this.list[this.index];
    t2 ? t2.run().then(() => {
      this.onTask(t2), this.index++, t2.isCancel ? this.runTask() : this.nextTask();
    }).catch((t3) => {
      this.onError(t3);
    }) : this.timer = setTimeout(() => this.nextTask());
  }
  runParallelTasks() {
    this.parallelList.forEach((t2) => this.runParallelTask(t2));
  }
  runParallelTask(t2) {
    t2.run().then(() => {
      this.onTask(t2), this.fillParallelTask();
    }).catch((t3) => {
      this.onParallelError(t3);
    });
  }
  nextTask() {
    this.total === this.finishedIndex ? this.onComplete() : this.timer = setTimeout(() => this.run());
  }
  setParallelList() {
    let t2;
    const { config: e2, list: s2, index: r2 } = this;
    this.parallelList = [], this.parallelSuccessNumber = 0;
    let i2 = r2 + e2.parallel;
    if (i2 > s2.length && (i2 = s2.length), e2.parallel > 1) for (let e3 = r2; e3 < i2 && (t2 = s2[e3], t2.parallel); e3++) this.parallelList.push(t2);
  }
  fillParallelTask() {
    let t2;
    const e2 = this.parallelList;
    this.parallelSuccessNumber++, e2.pop();
    const s2 = e2.length, r2 = this.finishedIndex + s2;
    if (e2.length) {
      if (!this.running) return;
      r2 < this.total && (t2 = this.list[r2], t2 && t2.parallel && (e2.push(t2), this.runParallelTask(t2)));
    } else this.index += this.parallelSuccessNumber, this.parallelSuccessNumber = 0, this.nextTask();
  }
  onComplete() {
    this.stop(), this.config.onComplete && this.config.onComplete();
  }
  onTask(t2) {
    t2.complete(), this.config.onTask && this.config.onTask();
  }
  onParallelError(t2) {
    this.parallelList.forEach((t3) => {
      t3.parallel = false;
    }), this.parallelList.length = 0, this.parallelSuccessNumber = 0, this.onError(t2);
  }
  onError(t2) {
    this.pause(), this.config.onError && this.config.onError(t2);
  }
  destroy() {
    this.stop();
  }
};
var $i = ee.get("Resource");
var Ki = { tasker: new Zi(), map: {}, get isComplete() {
  return tn.tasker.isComplete;
}, set(t2, e2) {
  tn.map[t2] && $i.repeat(t2), tn.map[t2] = e2;
}, get: (t2) => tn.map[t2], remove(t2) {
  const e2 = tn.map[t2];
  e2 && (e2.destroy && e2.destroy(), delete tn.map[t2]);
}, loadImage(t2, e2) {
  return new Promise((s2, r2) => {
    const i2 = this.setImage(t2, t2, e2);
    i2.load(() => s2(i2), (t3) => r2(t3));
  });
}, setImage(t2, e2, s2) {
  let r2;
  return i(e2) ? r2 = { url: e2 } : e2.url || (r2 = { url: t2, view: e2 }), r2 && (s2 && (r2.format = s2), e2 = le.image(r2)), tn.set(t2, e2), e2;
}, destroy() {
  tn.map = {};
} };
var tn = Ki;
var en = { maxRecycled: 10, recycledList: [], patternTasker: new Zi({ parallel: 1 }), get(t2) {
  let e2 = Ki.get(t2.url);
  return e2 || Ki.set(t2.url, e2 = le.image(t2)), e2.use++, e2;
}, recycle(t2) {
  t2.use--, setTimeout(() => {
    t2.use || ($t.image.isLarge(t2) ? t2.url && Ki.remove(t2.url) : (t2.clearLevels(), sn.recycledList.push(t2)));
  });
}, recyclePaint(t2) {
  sn.recycle(t2.image);
}, clearRecycled(t2) {
  const e2 = sn.recycledList;
  (e2.length > sn.maxRecycled || t2) && (e2.forEach((e3) => (!e3.use || t2) && e3.url && Ki.remove(e3.url)), e2.length = 0);
}, clearLevels() {
}, hasAlphaPixel: (t2) => Gi.alphaPixelTypes.some((e2) => sn.isFormat(e2, t2)), isFormat(t2, e2) {
  if (e2.format) return e2.format === t2;
  const { url: s2 } = e2;
  if (s2.startsWith("data:")) {
    if (s2.startsWith("data:" + Gi.mineType(t2))) return true;
  } else {
    if (s2.includes("." + t2) || s2.includes("." + Gi.upperCaseTypeMap[t2])) return true;
    if ("png" === t2 && !s2.includes(".")) return true;
  }
  return false;
}, destroy() {
  this.clearRecycled(true);
} };
var sn = en;
var { IMAGE: rn, create: nn } = g;
var on = class {
  get url() {
    return this.config.url;
  }
  get crossOrigin() {
    const { crossOrigin: t2 } = this.config;
    return s(t2) ? $t.image.crossOrigin : t2;
  }
  get completed() {
    return this.ready || !!this.error;
  }
  constructor(t2) {
    if (this.use = 0, this.waitComplete = [], this.innerId = nn(rn), this.config = t2 || (t2 = { url: "" }), t2.view) {
      const { view: e2 } = t2;
      this.setView(e2.config ? e2.view : e2);
    }
    en.isFormat("svg", t2) && (this.isSVG = true), en.hasAlphaPixel(t2) && (this.hasAlphaPixel = true);
  }
  load(t2, e2, s2) {
    return this.loading || (this.loading = true, Ki.tasker.add(() => me(this, void 0, void 0, function* () {
      return yield $t.origin.loadImage(this.getLoadUrl(s2), this.crossOrigin, this).then((t3) => {
        s2 && this.setThumbView(t3), this.setView(t3);
      }).catch((t3) => {
        this.error = t3, this.onComplete(false);
      });
    }))), this.waitComplete.push(t2, e2), this.waitComplete.length - 2;
  }
  unload(t2, e2) {
    const s2 = this.waitComplete;
    if (e2) {
      const e3 = s2[t2 + 1];
      e3 && e3({ type: "stop" });
    }
    s2[t2] = s2[t2 + 1] = void 0;
  }
  setView(t2) {
    this.ready = true, this.width || (this.width = t2.width, this.height = t2.height, this.view = t2), this.onComplete(true);
  }
  onComplete(t2) {
    let e2;
    this.waitComplete.forEach((s2, r2) => {
      e2 = r2 % 2, s2 && (t2 ? e2 || s2(this) : e2 && s2(this.error));
    }), this.waitComplete.length = 0, this.loading = false;
  }
  getFull(t2) {
    return this.view;
  }
  getCanvas(t2, e2, s2, r2, i2, n2, o2, a2) {
    if (t2 || (t2 = this.width), e2 || (e2 = this.height), this.cache) {
      let { params: t3, data: e3 } = this.cache;
      for (let s3 in t3) if (t3[s3] !== arguments[s3]) {
        e3 = null;
        break;
      }
      if (e3) return e3;
    }
    const h2 = $t.image.resize(this.view, t2, e2, i2, n2, void 0, o2, s2, r2, a2);
    return this.cache = this.use > 1 ? { data: h2, params: arguments } : null, h2;
  }
  getPattern(t2, e2, s2, r2) {
    const i2 = $t.canvas.createPattern(t2, e2);
    return $t.image.setPatternTransform(i2, s2, r2), i2;
  }
  getLoadUrl(t2) {
    return this.url;
  }
  setThumbView(t2) {
  }
  getThumbSize(t2) {
  }
  getMinLevel() {
  }
  getLevelData(t2, e2, s2) {
  }
  clearLevels(t2) {
  }
  destroy() {
    this.clearLevels();
    const { view: t2 } = this;
    t2 && t2.close && t2.close(), this.config = { url: "" }, this.cache = this.view = null, this.waitComplete.length = 0;
  }
};
function an(t2, e2, s2, r2) {
  r2 || (s2.configurable = s2.enumerable = true), Object.defineProperty(t2, e2, s2);
}
function hn(t2, e2) {
  return Object.getOwnPropertyDescriptor(t2, e2);
}
function ln(t2, e2) {
  const s2 = "_" + t2;
  return { get() {
    const t3 = this[s2];
    return null == t3 ? e2 : t3;
  }, set(t3) {
    this[s2] = t3;
  } };
}
function dn(t2, e2) {
  return (s2, r2) => un(s2, r2, t2, e2 && e2(r2));
}
function cn(t2) {
  return t2;
}
function un(t2, e2, s2, r2) {
  const i2 = { get() {
    return this.__getAttr(e2);
  }, set(t3) {
    this.__setAttr(e2, t3);
  } };
  an(t2, e2, Object.assign(i2, r2 || {})), zn(t2, e2, s2);
}
function _n(t2) {
  return dn(t2);
}
function pn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2, e2) && (this.__layout.matrixChanged || this.__layout.matrixChange());
  } }));
}
function fn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2, e2) && (this.__layout.matrixChanged || this.__layout.matrixChange(), this.__scrollWorld || (this.__scrollWorld = {}));
  } }));
}
function gn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__hasAutoLayout = !!(this.origin || this.around || this.flow), this.__local || this.__layout.createLocal(), bn(this));
  } }));
}
function yn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2, e2) && (this.__layout.scaleChanged || this.__layout.scaleChange());
  } }));
}
function mn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2, e2) && (this.__layout.rotationChanged || this.__layout.rotationChange());
  } }));
}
function xn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2, e2) && bn(this);
  } }));
}
function wn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (bn(this), this.__.__removeNaturalSize());
  } }));
}
function bn(t2) {
  t2.__layout.boxChanged || t2.__layout.boxChange(), t2.__hasAutoLayout && (t2.__layout.matrixChanged || t2.__layout.matrixChange());
}
function Bn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    const s2 = this.__;
    2 !== s2.__pathInputed && (s2.__pathInputed = e2 ? 1 : 0), e2 || (s2.__pathForRender = void 0), this.__setAttr(t3, e2), bn(this);
  } }));
}
var vn = xn;
function kn(t2, e2) {
  return dn(t2, (t3) => ({ set(s2) {
    this.__setAttr(t3, s2) && (Cn(this), e2 && (this.__.__useStroke = true));
  } }));
}
function Cn(t2) {
  t2.__layout.strokeChanged || t2.__layout.strokeChange(), t2.__.__useArrow && bn(t2);
}
var On = kn;
function Tn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2), this.__layout.renderChanged || this.__layout.renderChange();
  } }));
}
function Pn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__layout.surfaceChanged || this.__layout.surfaceChange());
  } }));
}
function Sn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    if (this.__setAttr(t3, e2)) {
      const t4 = this.__;
      _.stintSet(t4, "__useDim", t4.dim || t4.bright || t4.dimskip), this.__layout.surfaceChange();
    }
  } }));
}
function Ln(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__layout.opacityChanged || this.__layout.opacityChange()), this.mask && En(this);
  } }));
}
function Rn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    const s2 = this.visible;
    if (true === s2 && 0 === e2) {
      if (this.animationOut) return this.__runAnimation("out", () => In(this, t3, e2, s2));
    } else 0 === s2 && true === e2 && this.animation && this.__runAnimation("in");
    In(this, t3, e2, s2), this.mask && En(this);
  } }));
}
function En(t2) {
  const { parent: e2 } = t2;
  if (e2) {
    const { __hasMask: t3 } = e2;
    e2.__updateMask(), t3 !== e2.__hasMask && e2.forceUpdate();
  }
}
function In(t2, e2, s2, r2) {
  t2.__setAttr(e2, s2) && (t2.__layout.opacityChanged || t2.__layout.opacityChange(), 0 !== r2 && 0 !== s2 || bn(t2));
}
function Mn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__layout.surfaceChange(), this.waitParent(() => {
      this.parent.__layout.childrenSortChange();
    }));
  } }));
}
function An(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__layout.boxChanged || this.__layout.boxChange(), this.waitParent(() => {
      this.parent.__updateMask(e2);
    }));
  } }));
}
function Wn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && this.waitParent(() => {
      this.parent.__updateEraser(e2);
    });
  } }));
}
function Nn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2) && (this.__layout.hitCanvasChanged = true, "hit" === ee.showBounds && this.__layout.surfaceChange(), this.leafer && this.leafer.updateCursor());
  } }));
}
function Yn(t2) {
  return dn(t2, (t3) => ({ set(e2) {
    this.__setAttr(t3, e2), this.leafer && this.leafer.updateCursor();
  } }));
}
function Dn(t2) {
  return (e2, s2) => {
    an(e2, "__DataProcessor", { get: () => t2 });
  };
}
function Xn(t2) {
  return (e2, s2) => {
    an(e2, "__LayoutProcessor", { get: () => t2 });
  };
}
function zn(t2, e2, r2) {
  const i2 = t2.__DataProcessor.prototype, n2 = "_" + e2, o2 = (function(t3) {
    return "set" + t3.charAt(0).toUpperCase() + t3.slice(1);
  })(e2), a2 = ln(e2, r2);
  if (s(r2)) a2.get = function() {
    return this[n2];
  };
  else if ("function" == typeof r2) a2.get = function() {
    const t3 = this[n2];
    return null == t3 ? r2(this.__leaf) : t3;
  };
  else if (d(r2)) {
    const t3 = u(r2);
    a2.get = function() {
      const e3 = this[n2];
      return null == e3 ? this[n2] = t3 ? {} : _.clone(r2) : e3;
    };
  }
  const h2 = t2.isBranchLeaf;
  "width" === e2 ? a2.get = function() {
    const t3 = this[n2];
    if (null == t3) {
      const t4 = this, e3 = t4.__naturalWidth, s2 = t4.__leaf;
      return !r2 || s2.pathInputed ? s2.boxBounds.width : e3 ? t4._height && t4.__useNaturalRatio ? t4._height * e3 / t4.__naturalHeight : e3 : h2 && s2.children.length ? s2.boxBounds.width : r2;
    }
    return t3;
  } : "height" === e2 && (a2.get = function() {
    const t3 = this[n2];
    if (null == t3) {
      const t4 = this, e3 = t4.__naturalHeight, s2 = t4.__leaf;
      return !r2 || s2.pathInputed ? s2.boxBounds.height : e3 ? t4._width && t4.__useNaturalRatio ? t4._width * e3 / t4.__naturalWidth : e3 : h2 && s2.children.length ? s2.boxBounds.height : r2;
    }
    return t3;
  });
  let l2, c2 = i2;
  for (; !l2 && c2; ) l2 = hn(c2, e2), c2 = c2.__proto__;
  l2 && l2.set && (a2.set = l2.set), i2[o2] && (a2.set = i2[o2], delete i2[o2]), an(i2, e2, a2);
}
var Fn = new ee("rewrite");
var Un = [];
var jn = ["destroy", "constructor"];
function Hn(t2) {
  return (e2, s2) => {
    Un.push({ name: e2.constructor.name + "." + s2, run: () => {
      e2[s2] = t2;
    } });
  };
}
function Vn() {
  return (t2) => {
    Gn();
  };
}
function Gn(t2) {
  Un.length && (Un.forEach((e2) => {
    t2 && Fn.error(e2.name, "Class@rewriteAble()"), e2.run();
  }), Un.length = 0);
}
function qn(t2, e2) {
  return (s2) => {
    var r2;
    (t2.prototype ? (r2 = t2.prototype, Object.getOwnPropertyNames(r2)) : Object.keys(t2)).forEach((r3) => {
      if (!(jn.includes(r3) || e2 && e2.includes(r3))) if (t2.prototype) {
        hn(t2.prototype, r3).writable && (s2.prototype[r3] = t2.prototype[r3]);
      } else s2.prototype[r3] = t2[r3];
    });
  };
}
function Qn() {
  return (t2) => {
    ce.register(t2);
  };
}
function Jn() {
  return (t2) => {
    pe.register(t2);
  };
}
setTimeout(() => Gn(true));
var { copy: Zn, toInnerPoint: $n, toOuterPoint: Kn, scaleOfOuter: to, rotateOfOuter: eo, skewOfOuter: so, multiplyParent: ro, divideParent: io, getLayout: no } = q;
var oo = {};
var { round: ao } = Math;
var ho = { updateAllMatrix(t2, e2, s2) {
  if (e2 && t2.__hasAutoLayout && t2.__layout.matrixChanged && (s2 = true), uo(t2, e2, s2), t2.isBranch) {
    const { children: r2 } = t2;
    for (let t3 = 0, i2 = r2.length; t3 < i2; t3++) co(r2[t3], e2, s2);
  }
}, updateMatrix(t2, e2, s2) {
  const r2 = t2.__layout;
  e2 ? s2 && (r2.waitAutoLayout = true, t2.__hasAutoLayout && (r2.matrixChanged = false)) : r2.waitAutoLayout && (r2.waitAutoLayout = false), r2.matrixChanged && t2.__updateLocalMatrix(), r2.waitAutoLayout || t2.__updateWorldMatrix();
}, updateBounds(t2) {
  const e2 = t2.__layout;
  e2.boundsChanged && t2.__updateLocalBounds(), e2.waitAutoLayout || t2.__updateWorldBounds();
}, updateAllWorldOpacity(t2) {
  if (t2.__updateWorldOpacity(), t2.isBranch) {
    const { children: e2 } = t2;
    for (let t3 = 0, s2 = e2.length; t3 < s2; t3++) _o(e2[t3]);
  }
}, updateChange(t2) {
  const e2 = t2.__layout;
  e2.stateStyleChanged && t2.updateState(), e2.opacityChanged && _o(t2), t2.__updateChange();
}, updateAllChange(t2) {
  if (fo(t2), t2.isBranch) {
    const { children: e2 } = t2;
    for (let t3 = 0, s2 = e2.length; t3 < s2; t3++) po(e2[t3]);
  }
}, worldHittable(t2) {
  for (; t2; ) {
    if (!t2.__.hittable) return false;
    t2 = t2.parent;
  }
  return true;
}, draggable: (t2) => (t2.draggable || t2.editable) && t2.hitSelf && !t2.locked, copyCanvasByWorld(t2, e2, s2, r2, i2, n2) {
  r2 || (r2 = t2.__nowWorld), t2.__worldFlipped || $t.fullImageShadow ? e2.copyWorldByReset(s2, r2, t2.__nowWorld, i2, n2) : e2.copyWorldToInner(s2, r2, t2.__layout.renderBounds, i2);
}, moveWorld(t2, e2, s2 = 0, r2, i2) {
  const n2 = d(e2) ? Object.assign({}, e2) : { x: e2, y: s2 };
  r2 ? Kn(t2.localTransform, n2, n2, true) : t2.parent && $n(t2.parent.scrollWorldTransform, n2, n2, true), lo.moveLocal(t2, n2.x, n2.y, i2);
}, moveLocal(t2, e2, s2 = 0, r2) {
  d(e2) && (s2 = e2.y, e2 = e2.x), e2 += t2.x, s2 += t2.y, t2.leafer && t2.leafer.config.pointSnap && (e2 = ao(e2), s2 = ao(s2)), r2 ? t2.animate({ x: e2, y: s2 }, r2) : (t2.x = e2, t2.y = s2);
}, zoomOfWorld(t2, e2, s2, r2, i2, n2) {
  lo.zoomOfLocal(t2, go(t2, e2), s2, r2, i2, n2);
}, zoomOfLocal(t2, e2, s2, r2 = s2, i2, n2) {
  const a2 = t2.__localMatrix;
  if (o(r2) || (r2 && (n2 = r2), r2 = s2), Zn(oo, a2), to(oo, e2, s2, r2), lo.hasHighPosition(t2)) lo.setTransform(t2, oo, i2, n2);
  else {
    const e3 = t2.x + oo.e - a2.e, o2 = t2.y + oo.f - a2.f;
    n2 && !i2 ? t2.animate({ x: e3, y: o2, scaleX: t2.scaleX * s2, scaleY: t2.scaleY * r2 }, n2) : (t2.x = e3, t2.y = o2, t2.scaleResize(s2, r2, true !== i2));
  }
}, rotateOfWorld(t2, e2, s2, r2) {
  lo.rotateOfLocal(t2, go(t2, e2), s2, r2);
}, rotateOfLocal(t2, e2, s2, r2) {
  const i2 = t2.__localMatrix;
  Zn(oo, i2), eo(oo, e2, s2), lo.hasHighPosition(t2) ? lo.setTransform(t2, oo, false, r2) : t2.set({ x: t2.x + oo.e - i2.e, y: t2.y + oo.f - i2.f, rotation: I.formatRotation(t2.rotation + s2) }, r2);
}, skewOfWorld(t2, e2, s2, r2, i2, n2) {
  lo.skewOfLocal(t2, go(t2, e2), s2, r2, i2, n2);
}, skewOfLocal(t2, e2, s2, r2 = 0, i2, n2) {
  Zn(oo, t2.__localMatrix), so(oo, e2, s2, r2), lo.setTransform(t2, oo, i2, n2);
}, transformWorld(t2, e2, s2, r2) {
  Zn(oo, t2.worldTransform), ro(oo, e2), t2.parent && io(oo, t2.parent.scrollWorldTransform), lo.setTransform(t2, oo, s2, r2);
}, transform(t2, e2, s2, r2) {
  Zn(oo, t2.localTransform), ro(oo, e2), lo.setTransform(t2, oo, s2, r2);
}, setTransform(t2, e2, s2, r2) {
  const i2 = t2.__, n2 = i2.origin && lo.getInnerOrigin(t2, i2.origin), o2 = no(e2, n2, i2.around && lo.getInnerOrigin(t2, i2.around));
  if (lo.hasOffset(t2) && (o2.x -= i2.offsetX, o2.y -= i2.offsetY), s2) {
    const e3 = o2.scaleX / t2.scaleX, s3 = o2.scaleY / t2.scaleY;
    if (delete o2.scaleX, delete o2.scaleY, n2) {
      zt.scale(t2.boxBounds, Math.abs(e3), Math.abs(s3));
      const r3 = lo.getInnerOrigin(t2, i2.origin);
      ot.move(o2, n2.x - r3.x, n2.y - r3.y);
    }
    t2.set(o2), t2.scaleResize(e3, s3, false);
  } else t2.set(o2, r2);
}, getFlipTransform(t2, e2) {
  const s2 = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }, r2 = "x" === e2 ? 1 : -1;
  return to(s2, lo.getLocalOrigin(t2, "center"), -1 * r2, 1 * r2), s2;
}, getLocalOrigin: (t2, e2) => ot.tempToOuterOf(lo.getInnerOrigin(t2, e2), t2.localTransform), getInnerOrigin(t2, e2) {
  const s2 = {};
  return bt.toPoint(e2, t2.boxBounds, s2), s2;
}, getRelativeWorld: (t2, e2, s2) => (Zn(oo, t2.worldTransform), io(oo, e2.scrollWorldTransform), s2 ? oo : Object.assign({}, oo)), drop(t2, e2, s2, r2) {
  t2.setTransform(lo.getRelativeWorld(t2, e2, true), r2), e2.add(t2, s2);
}, hasHighPosition: (t2) => t2.origin || t2.around || lo.hasOffset(t2), hasOffset: (t2) => t2.offsetX || t2.offsetY, hasParent(t2, e2) {
  if (!e2) return false;
  for (; t2; ) {
    if (e2 === t2) return true;
    t2 = t2.parent;
  }
}, animateMove(t2, e2, s2 = 0.3) {
  if (e2.x || e2.y) if (Math.abs(e2.x) < 1 && Math.abs(e2.y) < 1) t2.move(e2);
  else {
    const r2 = e2.x * s2, i2 = e2.y * s2;
    e2.x -= r2, e2.y -= i2, t2.move(r2, i2), $t.requestRender(() => lo.animateMove(t2, e2, s2));
  }
} };
var lo = ho;
var { updateAllMatrix: co, updateMatrix: uo, updateAllWorldOpacity: _o, updateAllChange: po, updateChange: fo } = lo;
function go(t2, e2) {
  return t2.updateLayout(), t2.parent ? ot.tempToInnerOf(e2, t2.parent.scrollWorldTransform) : e2;
}
var yo = { worldBounds: (t2) => t2.__world, localBoxBounds: (t2) => t2.__.eraser || 0 === t2.__.visible ? null : t2.__local || t2.__layout, localStrokeBounds: (t2) => t2.__.eraser || 0 === t2.__.visible ? null : t2.__layout.localStrokeBounds, localRenderBounds: (t2) => t2.__.eraser || 0 === t2.__.visible ? null : t2.__layout.localRenderBounds, maskLocalBoxBounds: (t2, e2) => xo(t2, e2) && t2.__localBoxBounds, maskLocalStrokeBounds: (t2, e2) => xo(t2, e2) && t2.__layout.localStrokeBounds, maskLocalRenderBounds: (t2, e2) => xo(t2, e2) && t2.__layout.localRenderBounds, excludeRenderBounds: (t2, e2) => !(!e2.bounds || e2.bounds.hit(t2.__world, e2.matrix)) || !(!e2.hideBounds || !e2.hideBounds.includes(t2.__world, e2.matrix)) };
var mo;
function xo(t2, e2) {
  return e2 || (mo = 0), t2.__.mask && (mo = 1), mo < 0 ? null : (mo && (mo = -1), true);
}
var { updateBounds: wo } = ho;
var bo = { sort: (t2, e2) => t2.__.zIndex === e2.__.zIndex ? t2.__tempNumber - e2.__tempNumber : t2.__.zIndex - e2.__.zIndex, pushAllChildBranch(t2, e2) {
  if (t2.__tempNumber = 1, t2.__.__childBranchNumber) {
    const { children: s2 } = t2;
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) (t2 = s2[r2]).isBranch && (t2.__tempNumber = 1, e2.add(t2), Bo(t2, e2));
  }
}, pushAllParent(t2, e2) {
  const { keys: r2 } = e2;
  if (r2) for (; t2.parent && s(r2[t2.parent.innerId]); ) e2.add(t2.parent), t2 = t2.parent;
  else for (; t2.parent; ) e2.add(t2.parent), t2 = t2.parent;
}, pushAllBranchStack(t2, e2) {
  let s2 = e2.length;
  const { children: r2 } = t2;
  for (let t3 = 0, s3 = r2.length; t3 < s3; t3++) r2[t3].isBranch && e2.push(r2[t3]);
  for (let t3 = s2, r3 = e2.length; t3 < r3; t3++) vo(e2[t3], e2);
}, updateBounds(t2, e2) {
  const s2 = [t2];
  vo(t2, s2), ko(s2, e2);
}, updateBoundsByBranchStack(t2, e2) {
  let s2, r2;
  for (let i2 = t2.length - 1; i2 > -1; i2--) {
    s2 = t2[i2], r2 = s2.children;
    for (let t3 = 0, e3 = r2.length; t3 < e3; t3++) wo(r2[t3]);
    e2 && e2 === s2 || wo(s2);
  }
}, move(t2, e2, s2) {
  let r2;
  const { children: i2 } = t2;
  for (let n2 = 0, o2 = i2.length; n2 < o2; n2++) r2 = (t2 = i2[n2]).__world, r2.e += e2, r2.f += s2, r2.x += e2, r2.y += s2, t2.isBranch && Co(t2, e2, s2);
}, scale(t2, e2, s2, r2, i2, n2, o2) {
  let a2;
  const { children: h2 } = t2, l2 = r2 - 1, d2 = i2 - 1;
  for (let c2 = 0, u2 = h2.length; c2 < u2; c2++) a2 = (t2 = h2[c2]).__world, a2.a *= r2, a2.d *= i2, (a2.b || a2.c) && (a2.b *= r2, a2.c *= i2), a2.e === a2.x && a2.f === a2.y ? (a2.x = a2.e += (a2.e - n2) * l2 + e2, a2.y = a2.f += (a2.f - o2) * d2 + s2) : (a2.e += (a2.e - n2) * l2 + e2, a2.f += (a2.f - o2) * d2 + s2, a2.x += (a2.x - n2) * l2 + e2, a2.y += (a2.y - o2) * d2 + s2), a2.width *= r2, a2.height *= i2, a2.scaleX *= r2, a2.scaleY *= i2, t2.isBranch && Oo(t2, e2, s2, r2, i2, n2, o2);
} };
var { pushAllChildBranch: Bo, pushAllBranchStack: vo, updateBoundsByBranchStack: ko, move: Co, scale: Oo } = bo;
var To = { run(t2) {
  if (t2 && t2.length) {
    const e2 = t2.length;
    for (let s2 = 0; s2 < e2; s2++) t2[s2]();
    t2.length === e2 ? t2.length = 0 : t2.splice(0, e2);
  }
} };
var { getRelativeWorld: Po, updateBounds: So } = ho;
var { toOuterOf: Lo, getPoints: Ro, copy: Eo } = zt;
var Io = "_localContentBounds";
var Mo = "_worldContentBounds";
var Ao = "_worldBoxBounds";
var Wo = "_worldStrokeBounds";
var No = class {
  get contentBounds() {
    return this._contentBounds || this.boxBounds;
  }
  set contentBounds(t2) {
    this._contentBounds = t2;
  }
  get strokeBounds() {
    return this._strokeBounds || this.boxBounds;
  }
  get renderBounds() {
    return this._renderBounds || this.boxBounds;
  }
  set renderBounds(t2) {
    this._renderBounds = t2;
  }
  get localContentBounds() {
    return Lo(this.contentBounds, this.leaf.__localMatrix, this[Io] || (this[Io] = {})), this[Io];
  }
  get localStrokeBounds() {
    return this._localStrokeBounds || this;
  }
  get localRenderBounds() {
    return this._localRenderBounds || this;
  }
  get worldContentBounds() {
    return Lo(this.contentBounds, this.leaf.__world, this[Mo] || (this[Mo] = {})), this[Mo];
  }
  get worldBoxBounds() {
    return Lo(this.boxBounds, this.leaf.__world, this[Ao] || (this[Ao] = {})), this[Ao];
  }
  get worldStrokeBounds() {
    return Lo(this.strokeBounds, this.leaf.__world, this[Wo] || (this[Wo] = {})), this[Wo];
  }
  get a() {
    return 1;
  }
  get b() {
    return 0;
  }
  get c() {
    return 0;
  }
  get d() {
    return 1;
  }
  get e() {
    return this.leaf.__.x;
  }
  get f() {
    return this.leaf.__.y;
  }
  get x() {
    return this.e + this.boxBounds.x;
  }
  get y() {
    return this.f + this.boxBounds.y;
  }
  get width() {
    return this.boxBounds.width;
  }
  get height() {
    return this.boxBounds.height;
  }
  constructor(t2) {
    this.leaf = t2, this.leaf.__local && (this._localRenderBounds = this._localStrokeBounds = this.leaf.__local), t2.__world && (this.boxBounds = { x: 0, y: 0, width: 0, height: 0 }, this.boxChange(), this.matrixChange());
  }
  createLocal() {
    const t2 = this.leaf.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
    this._localStrokeBounds || (this._localStrokeBounds = t2), this._localRenderBounds || (this._localRenderBounds = t2);
  }
  update() {
    const { leaf: t2 } = this, { leafer: e2 } = t2;
    if (t2.isApp) return So(t2);
    if (e2) e2.ready ? e2.watcher.changed && e2.layouter.layout() : e2.start();
    else {
      let e3 = t2;
      for (; e3.parent && !e3.parent.leafer; ) e3 = e3.parent;
      const s2 = e3;
      if (s2.__fullLayouting) return;
      s2.__fullLayouting = true, $t.layout(s2), delete s2.__fullLayouting;
    }
  }
  getTransform(t2 = "world") {
    this.update();
    const { leaf: e2 } = this;
    switch (t2) {
      case "world":
        return e2.__world;
      case "local":
        return e2.__localMatrix;
      case "inner":
        return q.defaultMatrix;
      case "page":
        t2 = e2.zoomLayer;
      default:
        return Po(e2, t2);
    }
  }
  getBounds(t2, e2 = "world") {
    switch (this.update(), e2) {
      case "world":
        return this.getWorldBounds(t2);
      case "local":
        return this.getLocalBounds(t2);
      case "inner":
        return this.getInnerBounds(t2);
      case "page":
        e2 = this.leaf.zoomLayer;
      default:
        return new Ht(this.getInnerBounds(t2)).toOuterOf(this.getTransform(e2));
    }
  }
  getInnerBounds(t2 = "box") {
    switch (t2) {
      case "render":
        return this.renderBounds;
      case "content":
        if (this.contentBounds) return this.contentBounds;
      case "box":
        return this.boxBounds;
      case "stroke":
        return this.strokeBounds;
    }
  }
  getLocalBounds(t2 = "box") {
    switch (t2) {
      case "render":
        return this.localRenderBounds;
      case "stroke":
        return this.localStrokeBounds;
      case "content":
        if (this.contentBounds) return this.localContentBounds;
      case "box":
        return this.leaf.__localBoxBounds;
    }
  }
  getWorldBounds(t2 = "box") {
    switch (t2) {
      case "render":
        return this.leaf.__world;
      case "stroke":
        return this.worldStrokeBounds;
      case "content":
        if (this.contentBounds) return this.worldContentBounds;
      case "box":
        return this.worldBoxBounds;
    }
  }
  getLayoutBounds(t2, e2 = "world", s2) {
    const { leaf: r2 } = this;
    let i2, n2, o2, a2 = this.getInnerBounds(t2);
    switch (e2) {
      case "world":
        i2 = r2.getWorldPoint(a2), n2 = r2.__world;
        break;
      case "local":
        const { scaleX: t3, scaleY: s3, rotation: h2, skewX: l2, skewY: d2 } = r2.__;
        o2 = { scaleX: t3, scaleY: s3, rotation: h2, skewX: l2, skewY: d2 }, i2 = r2.getLocalPointByInner(a2);
        break;
      case "inner":
        i2 = a2, n2 = q.defaultMatrix;
        break;
      case "page":
        e2 = r2.zoomLayer;
      default:
        i2 = r2.getWorldPoint(a2, e2), n2 = Po(r2, e2, true);
    }
    if (o2 || (o2 = q.getLayout(n2)), Eo(o2, a2), ot.copy(o2, i2), s2) {
      const { scaleX: t3, scaleY: e3 } = o2, s3 = Math.abs(t3), r3 = Math.abs(e3);
      1 === s3 && 1 === r3 || (o2.scaleX /= s3, o2.scaleY /= r3, o2.width *= s3, o2.height *= r3);
    }
    return o2;
  }
  getLayoutPoints(t2, e2 = "world") {
    const { leaf: r2 } = this, i2 = Ro(this.getInnerBounds(t2));
    let n2;
    switch (e2) {
      case "world":
        n2 = null;
        break;
      case "local":
        n2 = r2.parent;
        break;
      case "inner":
        break;
      case "page":
        e2 = r2.zoomLayer;
      default:
        n2 = e2;
    }
    return s(n2) || i2.forEach((t3) => r2.innerToWorld(t3, null, false, n2)), i2;
  }
  shrinkContent() {
    const { x: t2, y: e2, width: s2, height: r2 } = this.boxBounds;
    this._contentBounds = { x: t2, y: e2, width: s2, height: r2 };
  }
  spreadStroke() {
    const { x: t2, y: e2, width: s2, height: r2 } = this.strokeBounds;
    this._strokeBounds = { x: t2, y: e2, width: s2, height: r2 }, this._localStrokeBounds = { x: t2, y: e2, width: s2, height: r2 }, this.renderSpread || this.spreadRenderCancel();
  }
  spreadRender() {
    const { x: t2, y: e2, width: s2, height: r2 } = this.renderBounds;
    this._renderBounds = { x: t2, y: e2, width: s2, height: r2 }, this._localRenderBounds = { x: t2, y: e2, width: s2, height: r2 };
  }
  shrinkContentCancel() {
    this._contentBounds = void 0;
  }
  spreadStrokeCancel() {
    const t2 = this.renderBounds === this.strokeBounds;
    this._strokeBounds = this.boxBounds, this._localStrokeBounds = this.leaf.__localBoxBounds, t2 && this.spreadRenderCancel();
  }
  spreadRenderCancel() {
    this._renderBounds = this._strokeBounds, this._localRenderBounds = this._localStrokeBounds;
  }
  boxChange() {
    this.boxChanged = true, this.localBoxChanged ? this.boundsChanged || (this.boundsChanged = true) : this.localBoxChange(), this.hitCanvasChanged = true;
  }
  localBoxChange() {
    this.localBoxChanged = true, this.boundsChanged = true;
  }
  strokeChange() {
    this.strokeChanged = true, this.strokeSpread || (this.strokeSpread = 1), this.boundsChanged = true, this.hitCanvasChanged = true;
  }
  renderChange() {
    this.renderChanged = true, this.renderSpread || (this.renderSpread = 1), this.boundsChanged = true;
  }
  scaleChange() {
    this.scaleChanged = true, this._scaleOrRotationChange();
  }
  rotationChange() {
    this.rotationChanged = true, this.affectRotation = true, this._scaleOrRotationChange();
  }
  _scaleOrRotationChange() {
    this.affectScaleOrRotation = true, this.matrixChange(), this.leaf.__local || this.createLocal();
  }
  matrixChange() {
    this.matrixChanged = true, this.localBoxChanged ? this.boundsChanged || (this.boundsChanged = true) : this.localBoxChange();
  }
  surfaceChange() {
    this.surfaceChanged = true;
  }
  opacityChange() {
    this.opacityChanged = true, this.surfaceChanged || this.surfaceChange();
  }
  childrenSortChange() {
    this.childrenSortChanged || (this.childrenSortChanged = this.affectChildrenSort = true, this.leaf.forceUpdate("surface"));
  }
  destroy() {
  }
};
var Yo = class {
  constructor(t2, e2) {
    this.bubbles = false, this.type = t2, e2 && (this.target = e2);
  }
  stopDefault() {
    this.isStopDefault = true, this.origin && $t.event.stopDefault(this.origin);
  }
  stopNow() {
    this.isStopNow = true, this.isStop = true, this.origin && $t.event.stopNow(this.origin);
  }
  stop() {
    this.isStop = true, this.origin && $t.event.stop(this.origin);
  }
};
var Do = class extends Yo {
  constructor(t2, e2, s2) {
    super(t2, e2), this.parent = s2, this.child = e2;
  }
};
Do.ADD = "child.add", Do.REMOVE = "child.remove", Do.CREATED = "created", Do.MOUNTED = "mounted", Do.UNMOUNTED = "unmounted", Do.DESTROY = "destroy";
var Xo = "property.scroll";
var zo = class extends Yo {
  constructor(t2, e2, s2, r2, i2) {
    super(t2, e2), this.attrName = s2, this.oldValue = r2, this.newValue = i2;
  }
};
zo.CHANGE = "property.change", zo.LEAFER_CHANGE = "property.leafer_change", zo.SCROLL = Xo;
var Fo = { scrollX: Xo, scrollY: Xo };
var Uo = class extends Yo {
  constructor(t2, e2) {
    super(t2), Object.assign(this, e2);
  }
};
Uo.LOAD = "image.load", Uo.LOADED = "image.loaded", Uo.ERROR = "image.error";
var jo = class extends Yo {
  static checkHas(t2, e2, s2) {
    "on" === s2 ? e2 === qo ? t2.__hasWorldEvent = true : t2.__hasLocalEvent = true : (t2.__hasLocalEvent = t2.hasEvent(Ho) || t2.hasEvent(Vo) || t2.hasEvent(Go), t2.__hasWorldEvent = t2.hasEvent(qo));
  }
  static emitLocal(t2) {
    if (t2.leaferIsReady) {
      const { resized: e2 } = t2.__layout;
      "local" !== e2 && (t2.emit(Ho, t2), "inner" === e2 && t2.emit(Vo, t2)), t2.emit(Go, t2);
    }
  }
  static emitWorld(t2) {
    t2.leaferIsReady && t2.emit(qo, this);
  }
};
jo.RESIZE = "bounds.resize", jo.INNER = "bounds.inner", jo.LOCAL = "bounds.local", jo.WORLD = "bounds.world";
var { RESIZE: Ho, INNER: Vo, LOCAL: Go, WORLD: qo } = jo;
var Qo = {};
[Ho, Vo, Go, qo].forEach((t2) => Qo[t2] = 1);
var Jo = class _Jo extends Yo {
  get bigger() {
    if (!this.old) return true;
    const { width: t2, height: e2 } = this.old;
    return this.width >= t2 && this.height >= e2;
  }
  get smaller() {
    return !this.bigger;
  }
  get samePixelRatio() {
    return !this.old || this.pixelRatio === this.old.pixelRatio;
  }
  constructor(t2, e2) {
    d(t2) ? (super(_Jo.RESIZE), Object.assign(this, t2)) : super(t2), this.old = e2;
  }
  static isResizing(t2) {
    return this.resizingKeys && !s(this.resizingKeys[t2.innerId]);
  }
};
Jo.RESIZE = "resize";
var Zo = class extends Yo {
  constructor(t2, e2) {
    super(t2), this.data = e2;
  }
};
Zo.REQUEST = "watch.request", Zo.DATA = "watch.data";
var $o = class extends Yo {
  constructor(t2, e2, s2) {
    super(t2), e2 && (this.data = e2, this.times = s2);
  }
};
$o.REQUEST = "layout.request", $o.START = "layout.start", $o.BEFORE = "layout.before", $o.LAYOUT = "layout", $o.AFTER = "layout.after", $o.AGAIN = "layout.again", $o.END = "layout.end";
var Ko = class extends Yo {
  constructor(t2, e2, s2, r2) {
    super(t2), e2 && (this.times = e2), s2 && (this.renderBounds = s2, this.renderOptions = r2);
  }
};
Ko.REQUEST = "render.request", Ko.CHILD_START = "render.child_start", Ko.CHILD_END = "render.child_end", Ko.START = "render.start", Ko.BEFORE = "render.before", Ko.RENDER = "render", Ko.AFTER = "render.after", Ko.AGAIN = "render.again", Ko.END = "render.end", Ko.NEXT = "render.next";
var ta = class extends Yo {
};
ta.START = "leafer.start", ta.BEFORE_READY = "leafer.before_ready", ta.READY = "leafer.ready", ta.AFTER_READY = "leafer.after_ready", ta.VIEW_READY = "leafer.view_ready", ta.VIEW_COMPLETED = "leafer.view_completed", ta.STOP = "leafer.stop", ta.RESTART = "leafer.restart", ta.END = "leafer.end", ta.UPDATE_MODE = "leafer.update_mode", ta.TRANSFORM = "leafer.transform", ta.MOVE = "leafer.move", ta.SCALE = "leafer.scale", ta.ROTATE = "leafer.rotate", ta.SKEW = "leafer.skew";
var { MOVE: ea, SCALE: sa, ROTATE: ra, SKEW: ia } = ta;
var na = { x: ea, y: ea, scaleX: sa, scaleY: sa, rotation: ra, skewX: ia, skewY: ia };
var oa = {};
var aa = class {
  set event(t2) {
    this.on(t2);
  }
  on(t2, e2, s2) {
    if (!e2) {
      let e3;
      if (l(t2)) t2.forEach((t3) => this.on(t3[0], t3[1], t3[2]));
      else for (let s3 in t2) l(e3 = t2[s3]) ? this.on(s3, e3[0], e3[1]) : this.on(s3, e3);
      return;
    }
    let r2, n2, o2;
    s2 && ("once" === s2 ? n2 = true : "boolean" == typeof s2 ? r2 = s2 : (r2 = s2.capture, n2 = s2.once));
    const a2 = ha(this, r2, true), h2 = i(t2) ? t2.split(" ") : t2, d2 = n2 ? { listener: e2, once: n2 } : { listener: e2 };
    h2.forEach((t3) => {
      t3 && (o2 = a2[t3], o2 ? -1 === o2.findIndex((t4) => t4.listener === e2) && o2.push(d2) : a2[t3] = [d2], Qo[t3] && jo.checkHas(this, t3, "on"));
    });
  }
  off(t2, e2, s2) {
    if (t2) {
      const r2 = i(t2) ? t2.split(" ") : t2;
      if (e2) {
        let t3, i2, n2;
        s2 && (t3 = "boolean" == typeof s2 ? s2 : "once" !== s2 && s2.capture);
        const o2 = ha(this, t3);
        r2.forEach((t4) => {
          t4 && (i2 = o2[t4], i2 && (n2 = i2.findIndex((t5) => t5.listener === e2), n2 > -1 && i2.splice(n2, 1), i2.length || delete o2[t4], Qo[t4] && jo.checkHas(this, t4, "off")));
        });
      } else {
        const { __bubbleMap: t3, __captureMap: e3 } = this;
        r2.forEach((s3) => {
          t3 && delete t3[s3], e3 && delete e3[s3];
        });
      }
    } else this.__bubbleMap = this.__captureMap = void 0;
  }
  on_(t2, e2, s2, r2) {
    return e2 ? this.on(t2, s2 ? e2 = e2.bind(s2) : e2, r2) : l(t2) && t2.forEach((t3) => this.on(t3[0], t3[2] ? t3[1] = t3[1].bind(t3[2]) : t3[1], t3[3])), { type: t2, current: this, listener: e2, options: r2 };
  }
  off_(t2) {
    if (!t2) return;
    const e2 = l(t2) ? t2 : [t2];
    e2.forEach((t3) => {
      t3 && (t3.listener ? t3.current.off(t3.type, t3.listener, t3.options) : l(t3.type) && t3.type.forEach((e3) => t3.current.off(e3[0], e3[1], e3[3])));
    }), e2.length = 0;
  }
  once(t2, e2, s2, r2) {
    if (!e2) return l(t2) && t2.forEach((t3) => this.once(t3[0], t3[1], t3[2], t3[3]));
    d(s2) ? e2 = e2.bind(s2) : r2 = s2, this.on(t2, e2, { once: true, capture: r2 });
  }
  emit(t2, e2, s2) {
    !e2 && pe.has(t2) && (e2 = pe.get(t2, { type: t2, target: this, current: this }));
    const r2 = ha(this, s2)[t2];
    if (r2) {
      let i2;
      for (let n2 = 0, o2 = r2.length; n2 < o2 && !((i2 = r2[n2]) && (i2.listener(e2), i2.once && (this.off(t2, i2.listener, s2), n2--, o2--), e2 && e2.isStopNow)); n2++) ;
    }
    this.syncEventer && this.syncEventer.emitEvent(e2, s2);
  }
  emitEvent(t2, e2) {
    t2.current = this, this.emit(t2.type, t2, e2);
  }
  hasEvent(t2, e2) {
    if (this.syncEventer && this.syncEventer.hasEvent(t2, e2)) return true;
    const { __bubbleMap: r2, __captureMap: i2 } = this, n2 = r2 && r2[t2], o2 = i2 && i2[t2];
    return !!(s(e2) ? n2 || o2 : e2 ? o2 : n2);
  }
  destroy() {
    this.__captureMap = this.__bubbleMap = this.syncEventer = null;
  }
};
function ha(t2, e2, s2) {
  if (e2) {
    const { __captureMap: e3 } = t2;
    return e3 || (s2 ? t2.__captureMap = {} : oa);
  }
  {
    const { __bubbleMap: e3 } = t2;
    return e3 || (s2 ? t2.__bubbleMap = {} : oa);
  }
}
var { on: la, on_: da, off: ca, off_: ua, once: _a, emit: pa, emitEvent: fa, hasEvent: ga, destroy: ya } = aa.prototype;
var ma = { on: la, on_: da, off: ca, off_: ua, once: _a, emit: pa, emitEvent: fa, hasEvent: ga, destroyEventer: ya };
var xa = ee.get("setAttr");
var wa = { __setAttr(t2, e2, r2) {
  if (this.leaferIsCreated) {
    const i2 = this.__.__getInput(t2);
    if (!r2 || n(e2) || s(e2) || (xa.warn(this.innerName, t2, e2), e2 = void 0), d(e2) || i2 !== e2) {
      if (this.__realSetAttr(t2, e2), this.isLeafer) {
        this.emitEvent(new zo(zo.LEAFER_CHANGE, this, t2, i2, e2));
        const s3 = na[t2];
        s3 && (this.emitEvent(new ta(s3, this)), this.emitEvent(new ta(ta.TRANSFORM, this)));
      }
      this.emitPropertyEvent(zo.CHANGE, t2, i2, e2);
      const s2 = Fo[t2];
      return s2 && this.emitPropertyEvent(s2, t2, i2, e2), true;
    }
    return false;
  }
  return this.__realSetAttr(t2, e2), true;
}, emitPropertyEvent(t2, e2, s2, r2) {
  const i2 = new zo(t2, this, e2, s2, r2);
  this.isLeafer || this.hasEvent(t2) && this.emitEvent(i2), this.leafer.emitEvent(i2);
}, __realSetAttr(t2, e2) {
  const r2 = this.__;
  r2[t2] = e2, this.__proxyData && this.setProxyAttr(t2, e2), r2.normalStyle && (this.lockNormalStyle || s(r2.normalStyle[t2]) || (r2.normalStyle[t2] = e2));
}, __getAttr(t2) {
  return this.__proxyData ? this.getProxyAttr(t2) : this.__.__get(t2);
} };
var { setLayout: ba, multiplyParent: Ba, translateInner: va, defaultWorld: ka } = q;
var { toPoint: Ca, tempPoint: Oa } = bt;
var Ta = { __updateWorldMatrix() {
  const { parent: t2, __layout: e2, __world: s2, __scrollWorld: r2, __: i2 } = this;
  Ba(this.__local || e2, t2 ? t2.__scrollWorld || t2.__world : ka, s2, !!e2.affectScaleOrRotation, i2), r2 && va(Object.assign(r2, s2), i2.scrollX, i2.scrollY);
}, __updateLocalMatrix() {
  if (this.__local) {
    const t2 = this.__layout, e2 = this.__local, s2 = this.__;
    t2.affectScaleOrRotation && (t2.scaleChanged && (t2.resized || (t2.resized = "scale")) || t2.rotationChanged) && (ba(e2, s2, null, null, t2.affectRotation), t2.scaleChanged = t2.rotationChanged = void 0), e2.e = s2.x + s2.offsetX, e2.f = s2.y + s2.offsetY, (s2.around || s2.origin) && (Ca(s2.around || s2.origin, t2.boxBounds, Oa), va(e2, -Oa.x, -Oa.y, !s2.around));
  }
  this.__layout.matrixChanged = void 0;
} };
var { updateMatrix: Pa, updateAllMatrix: Sa } = ho;
var { updateBounds: La } = bo;
var { toOuterOf: Ra, copyAndSpread: Ea, copy: Ia } = zt;
var { toBounds: Ma } = Ai;
var Aa = { __updateWorldBounds() {
  const { __layout: t2, __world: e2 } = this;
  Ra(t2.renderBounds, e2, e2), t2.resized && ("inner" === t2.resized && this.__onUpdateSize(), this.__hasLocalEvent && jo.emitLocal(this), t2.resized = void 0), this.__hasWorldEvent && jo.emitWorld(this);
}, __updateLocalBounds() {
  const t2 = this.__layout;
  t2.boxChanged && (this.__.__pathInputed || this.__updatePath(), this.__updateRenderPath(), this.__updateBoxBounds(), t2.resized = "inner"), t2.localBoxChanged && (this.__local && this.__updateLocalBoxBounds(), t2.localBoxChanged = void 0, t2.strokeSpread && (t2.strokeChanged = true), t2.renderSpread && (t2.renderChanged = true), this.parent && this.parent.__layout.boxChange()), t2.boxChanged = void 0, t2.strokeChanged && (t2.strokeSpread = this.__updateStrokeSpread(), t2.strokeSpread ? (t2.strokeBounds === t2.boxBounds && t2.spreadStroke(), this.__updateStrokeBounds(), this.__updateLocalStrokeBounds()) : t2.spreadStrokeCancel(), t2.strokeChanged = void 0, (t2.renderSpread || t2.strokeSpread !== t2.strokeBoxSpread) && (t2.renderChanged = true), this.parent && this.parent.__layout.strokeChange(), t2.resized = "inner"), t2.renderChanged && (t2.renderSpread = this.__updateRenderSpread(), t2.renderSpread ? (t2.renderBounds !== t2.boxBounds && t2.renderBounds !== t2.strokeBounds || t2.spreadRender(), this.__updateRenderBounds(), this.__updateLocalRenderBounds()) : t2.spreadRenderCancel(), t2.renderChanged = void 0, this.parent && this.parent.__layout.renderChange()), t2.resized || (t2.resized = "local"), t2.boundsChanged = void 0;
}, __updateLocalBoxBounds() {
  this.__hasMotionPath && this.__updateMotionPath(), this.__hasAutoLayout && this.__updateAutoLayout(), Ra(this.__layout.boxBounds, this.__local, this.__local);
}, __updateLocalStrokeBounds() {
  Ra(this.__layout.strokeBounds, this.__localMatrix, this.__layout.localStrokeBounds);
}, __updateLocalRenderBounds() {
  Ra(this.__layout.renderBounds, this.__localMatrix, this.__layout.localRenderBounds);
}, __updateBoxBounds(t2, e2) {
  const s2 = this.__layout.boxBounds, r2 = this.__;
  r2.__usePathBox ? Ma(r2.path, s2) : (s2.x = 0, s2.y = 0, s2.width = r2.width, s2.height = r2.height);
}, __updateAutoLayout() {
  this.__layout.matrixChanged = true, this.isBranch ? (this.__extraUpdate(), this.__.flow ? (this.__layout.boxChanged && this.__updateFlowLayout(), Sa(this), La(this, this), this.__.__autoSide && this.__updateBoxBounds(true)) : (Sa(this), La(this, this))) : Pa(this);
}, __updateNaturalSize() {
  const { __: t2, __layout: e2 } = this;
  t2.__naturalWidth = e2.boxBounds.width, t2.__naturalHeight = e2.boxBounds.height;
}, __updateStrokeBounds(t2) {
  const e2 = this.__layout;
  Ea(e2.strokeBounds, e2.boxBounds, e2.strokeBoxSpread);
}, __updateRenderBounds(t2) {
  const e2 = this.__layout, { renderSpread: s2 } = e2;
  o(s2) && s2 <= 0 ? Ia(e2.renderBounds, e2.strokeBounds) : Ea(e2.renderBounds, e2.boxBounds, s2);
} };
var Wa = { __render(t2, e2) {
  if (e2.shape) return this.__renderShape(t2, e2);
  if ((!e2.cellList || e2.cellList.has(this)) && this.__worldOpacity) {
    const s2 = this.__;
    if (s2.bright && !e2.topRendering) return e2.topList.add(this);
    if (t2.setWorld(this.__nowWorld = this.__getNowWorld(e2)), t2.opacity = e2.dimOpacity && !s2.dimskip ? s2.opacity * e2.dimOpacity : s2.opacity, this.__.__single) {
      if ("path" === s2.eraser) return this.__renderEraser(t2, e2);
      const r2 = t2.getSameCanvas(true, true);
      this.__draw(r2, e2, t2), ho.copyCanvasByWorld(this, t2, r2, this.__nowWorld, s2.__blendMode, true), r2.recycle(this.__nowWorld);
    } else this.__draw(t2, e2);
    ee.showBounds && ee.drawBounds(this, t2, e2);
  }
}, __renderShape(t2, e2) {
  this.__worldOpacity && (t2.setWorld(this.__nowWorld = this.__getNowWorld(e2)), this.__drawShape(t2, e2));
}, __clip(t2, e2) {
  this.__worldOpacity && (t2.setWorld(this.__nowWorld = this.__getNowWorld(e2)), this.__drawRenderPath(t2), t2.clipUI(this));
}, __updateWorldOpacity() {
  this.__worldOpacity = this.__.visible ? this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity : 0, this.__layout.opacityChanged && (this.__layout.opacityChanged = false);
} };
var { excludeRenderBounds: Na } = yo;
var { hasSize: Ya } = zt;
var Da = { __updateChange() {
  const { __layout: t2 } = this;
  t2.childrenSortChanged && (this.__updateSortChildren(), t2.childrenSortChanged = false), this.__.__checkSingle();
}, __render(t2, e2) {
  const s2 = this.__nowWorld = this.__getNowWorld(e2);
  if (this.__worldOpacity && Ya(s2)) {
    const r2 = this.__;
    if (r2.__useDim) if (r2.dim) e2.dimOpacity = true === r2.dim ? 0.2 : r2.dim;
    else {
      if (r2.bright && !e2.topRendering) return e2.topList.add(this);
      r2.dimskip && e2.dimOpacity && (e2.dimOpacity = 0);
    }
    if (r2.__single && !this.isBranchLeaf) {
      if ("path" === r2.eraser) return this.__renderEraser(t2, e2);
      const i2 = t2.getSameCanvas(false, true);
      this.__renderBranch(i2, e2), t2.opacity = e2.dimOpacity ? r2.opacity * e2.dimOpacity : r2.opacity, t2.copyWorldByReset(i2, s2, s2, r2.__blendMode, true), i2.recycle(s2);
    } else this.__renderBranch(t2, e2);
  }
}, __renderBranch(t2, e2) {
  if (this.__hasMask) this.__renderMask(t2, e2);
  else {
    const { children: s2 } = this;
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) Na(s2[r2], e2) || s2[r2].__render(t2, e2);
  }
}, __clip(t2, e2) {
  if (this.__worldOpacity) {
    const { children: s2 } = this;
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) Na(s2[r2], e2) || s2[r2].__clip(t2, e2);
  }
} };
var Xa = {};
var { LEAF: za, create: Fa } = g;
var { stintSet: Ua } = _;
var { toInnerPoint: ja, toOuterPoint: Ha, multiplyParent: Va } = q;
var { toOuterOf: Ga } = zt;
var { copy: qa, move: Qa } = ot;
var { moveLocal: Ja, zoomOfLocal: Za, rotateOfLocal: $a, skewOfLocal: Ka, moveWorld: th, zoomOfWorld: eh, rotateOfWorld: sh, skewOfWorld: rh, transform: ih, transformWorld: nh, setTransform: oh, getFlipTransform: ah, getLocalOrigin: hh, getRelativeWorld: lh, drop: dh } = ho;
var ch = class {
  get tag() {
    return this.__tag;
  }
  set tag(t2) {
  }
  get __tag() {
    return "Leaf";
  }
  get innerName() {
    return this.__.name || this.tag + this.innerId;
  }
  get __DataProcessor() {
    return f;
  }
  get __LayoutProcessor() {
    return No;
  }
  get leaferIsCreated() {
    return this.leafer && this.leafer.created;
  }
  get leaferIsReady() {
    return this.leafer && this.leafer.ready;
  }
  get isLeafer() {
    return false;
  }
  get isBranch() {
    return false;
  }
  get isBranchLeaf() {
    return false;
  }
  get __localMatrix() {
    return this.__local || this.__layout;
  }
  get __localBoxBounds() {
    return this.__local || this.__layout;
  }
  get worldTransform() {
    return this.__layout.getTransform("world");
  }
  get localTransform() {
    return this.__layout.getTransform("local");
  }
  get scrollWorldTransform() {
    return this.updateLayout(), this.__scrollWorld || this.__world;
  }
  get boxBounds() {
    return this.getBounds("box", "inner");
  }
  get renderBounds() {
    return this.getBounds("render", "inner");
  }
  get worldBoxBounds() {
    return this.getBounds("box");
  }
  get worldStrokeBounds() {
    return this.getBounds("stroke");
  }
  get worldRenderBounds() {
    return this.getBounds("render");
  }
  get worldOpacity() {
    return this.updateLayout(), this.__worldOpacity;
  }
  get __worldFlipped() {
    return this.__world.scaleX < 0 || this.__world.scaleY < 0;
  }
  get __onlyHitMask() {
    return this.__hasMask && !this.__.hitChildren;
  }
  get __ignoreHitWorld() {
    return (this.__hasMask || this.__hasEraser) && this.__.hitChildren;
  }
  get __inLazyBounds() {
    return this.leaferIsCreated && this.leafer.lazyBounds.hit(this.__world);
  }
  get pathInputed() {
    return this.__.__pathInputed;
  }
  set event(t2) {
    this.on(t2);
  }
  constructor(t2) {
    this.innerId = Fa(za), this.reset(t2), this.__bubbleMap && this.__emitLifeEvent(Do.CREATED);
  }
  reset(t2) {
    this.leafer && this.leafer.forceRender(this.__world), 0 !== t2 && (this.__world = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0, scaleX: 1, scaleY: 1 }, null !== t2 && (this.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 })), this.__worldOpacity = 1, this.__ = new this.__DataProcessor(this), this.__layout = new this.__LayoutProcessor(this), this.__level && this.resetCustom(), t2 && (t2.__ && (t2 = t2.toJSON()), t2.children ? this.set(t2) : Object.assign(this, t2));
  }
  resetCustom() {
    this.__hasMask = this.__hasEraser = null, this.forceUpdate();
  }
  waitParent(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.parent ? t2() : this.on(Do.ADD, t2, "once");
  }
  waitLeafer(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.leafer ? t2() : this.on(Do.MOUNTED, t2, "once");
  }
  nextRender(t2, e2, s2) {
    this.leafer ? this.leafer.nextRender(t2, e2, s2) : this.waitLeafer(() => this.leafer.nextRender(t2, e2, s2));
  }
  removeNextRender(t2) {
    this.nextRender(t2, null, "off");
  }
  __bindLeafer(t2) {
    if (this.isLeafer && null !== t2 && (t2 = this), this.leafer && !t2 && this.leafer.leafs--, this.leafer = t2, t2 ? (t2.leafs++, this.__level = this.parent ? this.parent.__level + 1 : 1, this.animation && this.__runAnimation("in"), this.__bubbleMap && this.__emitLifeEvent(Do.MOUNTED)) : this.__emitLifeEvent(Do.UNMOUNTED), this.isBranch) {
      const { children: e2 } = this;
      for (let s2 = 0, r2 = e2.length; s2 < r2; s2++) e2[s2].__bindLeafer(t2);
    }
  }
  set(t2, e2) {
  }
  get(t2) {
  }
  setAttr(t2, e2) {
    this[t2] = e2;
  }
  getAttr(t2) {
    return this[t2];
  }
  getComputedAttr(t2) {
    return this.__[t2];
  }
  toJSON(t2) {
    return t2 && this.__layout.update(), this.__.__getInputData(null, t2);
  }
  toString(t2) {
    return JSON.stringify(this.toJSON(t2));
  }
  toSVG() {
  }
  __SVG(t2) {
  }
  toHTML() {
  }
  __setAttr(t2, e2) {
    return true;
  }
  __getAttr(t2) {
  }
  setProxyAttr(t2, e2) {
  }
  getProxyAttr(t2) {
  }
  find(t2, e2) {
  }
  findTag(t2) {
  }
  findOne(t2, e2) {
  }
  findId(t2) {
  }
  focus(t2) {
  }
  updateState() {
  }
  updateLayout() {
    this.__layout.update();
  }
  forceUpdate(t2) {
    s(t2) ? t2 = "width" : "surface" === t2 && (t2 = "blendMode");
    const e2 = this.__.__getInput(t2);
    this.__[t2] = s(e2) ? null : void 0, this[t2] = e2;
  }
  forceRender(t2, e2) {
    this.forceUpdate("surface");
  }
  __extraUpdate() {
    this.leaferIsReady && this.leafer.layouter.addExtra(this);
  }
  __updateWorldMatrix() {
  }
  __updateLocalMatrix() {
  }
  __updateWorldBounds() {
  }
  __updateLocalBounds() {
  }
  __updateLocalBoxBounds() {
  }
  __updateLocalStrokeBounds() {
  }
  __updateLocalRenderBounds() {
  }
  __updateBoxBounds(t2, e2) {
  }
  __updateContentBounds() {
  }
  __updateStrokeBounds(t2) {
  }
  __updateRenderBounds(t2) {
  }
  __updateAutoLayout() {
  }
  __updateFlowLayout() {
  }
  __updateNaturalSize() {
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return 0;
  }
  __onUpdateSize() {
  }
  __updateEraser(t2) {
    this.__hasEraser = !!t2 || this.children.some((t3) => t3.__.eraser);
  }
  __renderEraser(t2, e2) {
    t2.save(), this.__clip(t2, e2);
    const { renderBounds: s2 } = this.__layout;
    t2.clearRect(s2.x, s2.y, s2.width, s2.height), t2.restore();
  }
  __updateMask(t2) {
    this.__hasMask = this.children.some((t3) => t3.__.mask && t3.__.visible && t3.__.opacity);
  }
  __renderMask(t2, e2) {
  }
  __getNowWorld(t2) {
    if (t2.matrix) {
      this.__cameraWorld || (this.__cameraWorld = {});
      const e2 = this.__cameraWorld, s2 = this.__world;
      return Va(s2, t2.matrix, e2, void 0, s2), Ga(this.__layout.renderBounds, e2, e2), Ua(e2, "half", s2.half), Ua(e2, "ignorePixelSnap", s2.ignorePixelSnap), e2;
    }
    return this.__world;
  }
  getClampRenderScale() {
    let { scaleX: t2 } = this.__nowWorld || this.__world;
    return t2 < 0 && (t2 = -t2), t2 > 1 ? t2 : 1;
  }
  getRenderScaleData(t2, e2) {
    let { scaleX: s2, scaleY: r2 } = en.patternLocked ? this.__world : this.__nowWorld;
    return t2 && (s2 < 0 && (s2 = -s2), r2 < 0 && (r2 = -r2)), (true === e2 || "zoom-in" === e2 && s2 > 1 && r2 > 1) && (s2 = r2 = 1), Xa.scaleX = s2, Xa.scaleY = r2, Xa;
  }
  getTransform(t2) {
    return this.__layout.getTransform(t2 || "local");
  }
  getBounds(t2, e2) {
    return this.__layout.getBounds(t2, e2);
  }
  getLayoutBounds(t2, e2, s2) {
    return this.__layout.getLayoutBounds(t2, e2, s2);
  }
  getLayoutPoints(t2, e2) {
    return this.__layout.getLayoutPoints(t2, e2);
  }
  getWorldBounds(t2, e2, s2) {
    const r2 = e2 ? lh(this, e2) : this.worldTransform, i2 = s2 ? t2 : {};
    return Ga(t2, r2, i2), i2;
  }
  worldToLocal(t2, e2, s2, r2) {
    this.parent ? this.parent.worldToInner(t2, e2, s2, r2) : e2 && qa(e2, t2);
  }
  localToWorld(t2, e2, s2, r2) {
    this.parent ? this.parent.innerToWorld(t2, e2, s2, r2) : e2 && qa(e2, t2);
  }
  worldToInner(t2, e2, s2, r2) {
    r2 && (r2.innerToWorld(t2, e2, s2), t2 = e2 || t2), ja(this.scrollWorldTransform, t2, e2, s2);
  }
  innerToWorld(t2, e2, s2, r2) {
    Ha(this.scrollWorldTransform, t2, e2, s2), r2 && r2.worldToInner(e2 || t2, null, s2);
  }
  getBoxPoint(t2, e2, s2, r2) {
    return this.getBoxPointByInner(this.getInnerPoint(t2, e2, s2, r2), null, null, true);
  }
  getBoxPointByInner(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : Object.assign({}, t2), { x: n2, y: o2 } = this.boxBounds;
    return Qa(i2, -n2, -o2), i2;
  }
  getInnerPoint(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : {};
    return this.worldToInner(t2, i2, s2, e2), i2;
  }
  getInnerPointByBox(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : Object.assign({}, t2), { x: n2, y: o2 } = this.boxBounds;
    return Qa(i2, n2, o2), i2;
  }
  getInnerPointByLocal(t2, e2, s2, r2) {
    return this.getInnerPoint(t2, this.parent, s2, r2);
  }
  getLocalPoint(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : {};
    return this.worldToLocal(t2, i2, s2, e2), i2;
  }
  getLocalPointByInner(t2, e2, s2, r2) {
    return this.getWorldPoint(t2, this.parent, s2, r2);
  }
  getPagePoint(t2, e2, s2, r2) {
    return (this.leafer ? this.leafer.zoomLayer : this).getInnerPoint(t2, e2, s2, r2);
  }
  getWorldPoint(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : {};
    return this.innerToWorld(t2, i2, s2, e2), i2;
  }
  getWorldPointByBox(t2, e2, s2, r2) {
    return this.getWorldPoint(this.getInnerPointByBox(t2, null, null, r2), e2, s2, true);
  }
  getWorldPointByLocal(t2, e2, s2, r2) {
    const i2 = r2 ? t2 : {};
    return this.localToWorld(t2, i2, s2, e2), i2;
  }
  getWorldPointByPage(t2, e2, s2, r2) {
    return (this.leafer ? this.leafer.zoomLayer : this).getWorldPoint(t2, e2, s2, r2);
  }
  setTransform(t2, e2, s2) {
    oh(this, t2, e2, s2);
  }
  transform(t2, e2, s2) {
    ih(this, t2, e2, s2);
  }
  move(t2, e2, s2) {
    Ja(this, t2, e2, s2);
  }
  moveInner(t2, e2, s2) {
    th(this, t2, e2, true, s2);
  }
  scaleOf(t2, e2, s2, r2, i2) {
    Za(this, hh(this, t2), e2, s2, r2, i2);
  }
  rotateOf(t2, e2, s2) {
    $a(this, hh(this, t2), e2, s2);
  }
  skewOf(t2, e2, s2, r2, i2) {
    Ka(this, hh(this, t2), e2, s2, r2, i2);
  }
  transformWorld(t2, e2, s2) {
    nh(this, t2, e2, s2);
  }
  moveWorld(t2, e2, s2) {
    th(this, t2, e2, false, s2);
  }
  scaleOfWorld(t2, e2, s2, r2, i2) {
    eh(this, t2, e2, s2, r2, i2);
  }
  rotateOfWorld(t2, e2) {
    sh(this, t2, e2);
  }
  skewOfWorld(t2, e2, s2, r2, i2) {
    rh(this, t2, e2, s2, r2, i2);
  }
  flip(t2, e2) {
    ih(this, ah(this, t2), false, e2);
  }
  scaleResize(t2, e2 = t2, s2) {
    this.scaleX *= t2, this.scaleY *= e2;
  }
  __scaleResize(t2, e2) {
  }
  resizeWidth(t2) {
  }
  resizeHeight(t2) {
  }
  hit(t2, e2) {
    return true;
  }
  __hitWorld(t2, e2) {
    return true;
  }
  __hit(t2, e2) {
    return true;
  }
  __hitFill(t2) {
    return true;
  }
  __hitStroke(t2, e2) {
    return true;
  }
  __hitPixel(t2) {
    return true;
  }
  __drawHitPath(t2) {
  }
  __updateHitCanvas() {
  }
  __render(t2, e2) {
  }
  __drawFast(t2, e2) {
  }
  __draw(t2, e2, s2) {
  }
  __clip(t2, e2) {
  }
  __renderShape(t2, e2) {
  }
  __drawShape(t2, e2) {
  }
  __updateWorldOpacity() {
  }
  __updateChange() {
  }
  __drawPath(t2) {
  }
  __drawRenderPath(t2) {
  }
  __updatePath() {
  }
  __updateRenderPath() {
  }
  getMotionPathData() {
    return he.need("path");
  }
  getMotionPoint(t2) {
    return he.need("path");
  }
  getMotionTotal() {
    return 0;
  }
  __updateMotionPath() {
  }
  __runAnimation(t2, e2) {
  }
  __updateSortChildren() {
  }
  add(t2, e2) {
  }
  remove(t2, e2) {
    this.parent && this.parent.remove(this, e2);
  }
  dropTo(t2, e2, s2) {
    dh(this, t2, e2, s2);
  }
  on(t2, e2, s2) {
  }
  off(t2, e2, s2) {
  }
  on_(t2, e2, s2, r2) {
  }
  off_(t2) {
  }
  once(t2, e2, s2, r2) {
  }
  emit(t2, e2, s2) {
  }
  emitEvent(t2, e2) {
  }
  hasEvent(t2, e2) {
    return false;
  }
  static changeAttr(t2, e2, s2) {
    s2 ? this.addAttr(t2, e2, s2) : zn(this.prototype, t2, e2);
  }
  static addAttr(t2, e2, s2, r2) {
    s2 || (s2 = xn), s2(e2, r2)(this.prototype, t2);
  }
  __emitLifeEvent(t2) {
    this.hasEvent(t2) && this.emitEvent(new Do(t2, this, this.parent));
  }
  destroy() {
    this.destroyed || (this.parent && this.remove(), this.children && this.clear(), this.__emitLifeEvent(Do.DESTROY), this.__.destroy(), this.__layout.destroy(), this.destroyEventer(), this.destroyed = true);
  }
};
ch = ye([qn(wa), qn(Ta), qn(Aa), qn(ma), qn(Wa)], ch);
var { setListWithFn: uh } = zt;
var { sort: _h } = bo;
var { localBoxBounds: ph, localStrokeBounds: fh, localRenderBounds: gh, maskLocalBoxBounds: yh, maskLocalStrokeBounds: mh, maskLocalRenderBounds: xh } = yo;
var wh = new ee("Branch");
var bh = class extends ch {
  __updateStrokeSpread() {
    const { children: t2 } = this;
    for (let e2 = 0, s2 = t2.length; e2 < s2; e2++) if (t2[e2].__layout.strokeSpread) return 1;
    return 0;
  }
  __updateRenderSpread() {
    const { children: t2 } = this;
    for (let e2 = 0, s2 = t2.length; e2 < s2; e2++) if (t2[e2].__layout.renderSpread) return 1;
    return 0;
  }
  __updateBoxBounds(t2, e2) {
    uh(e2 || this.__layout.boxBounds, this.children, this.__hasMask ? yh : ph);
  }
  __updateStrokeBounds(t2) {
    uh(t2 || this.__layout.strokeBounds, this.children, this.__hasMask ? mh : fh);
  }
  __updateRenderBounds(t2) {
    uh(t2 || this.__layout.renderBounds, this.children, this.__hasMask ? xh : gh);
  }
  __updateSortChildren() {
    let t2;
    const { children: e2 } = this;
    if (e2.length > 1) {
      for (let s2 = 0, r2 = e2.length; s2 < r2; s2++) e2[s2].__tempNumber = s2, e2[s2].__.zIndex && (t2 = true);
      e2.sort(_h), this.__layout.affectChildrenSort = t2;
    }
  }
  add(t2, e2) {
    if (t2 === this || t2.destroyed) return wh.warn("add self or destroyed");
    const r2 = s(e2);
    if (!t2.__) {
      if (l(t2)) return t2.forEach((t3) => {
        this.add(t3, e2), r2 || e2++;
      });
      t2 = ce.get(t2.tag, t2);
    }
    t2.parent && t2.parent.remove(t2), t2.parent = this, r2 ? this.children.push(t2) : this.children.splice(e2, 0, t2), t2.isBranch && (this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1);
    const i2 = t2.__layout;
    i2.boxChanged || i2.boxChange(), i2.matrixChanged || i2.matrixChange(), t2.__bubbleMap && t2.__emitLifeEvent(Do.ADD), this.leafer && (t2.__bindLeafer(this.leafer), this.leafer.created && this.__emitChildEvent(Do.ADD, t2)), this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  addMany(...t2) {
    this.add(t2);
  }
  remove(t2, e2) {
    t2 ? t2.__ ? t2.animationOut ? t2.__runAnimation("out", () => this.__remove(t2, e2)) : this.__remove(t2, e2) : this.find(t2).forEach((t3) => this.remove(t3, e2)) : s(t2) && super.remove(null, e2);
  }
  removeAll(t2) {
    const { children: e2 } = this;
    e2.length && (this.children = [], this.__preRemove(), this.__.__childBranchNumber = 0, e2.forEach((e3) => {
      this.__realRemoveChild(e3), t2 && e3.destroy();
    }));
  }
  clear() {
    this.removeAll(true);
  }
  __remove(t2, e2) {
    const s2 = this.children.indexOf(t2);
    s2 > -1 && (this.children.splice(s2, 1), t2.isBranch && (this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1), this.__preRemove(), this.__realRemoveChild(t2), e2 && t2.destroy());
  }
  __preRemove() {
    this.__hasMask && this.__updateMask(), this.__hasEraser && this.__updateEraser(), this.__layout.boxChange(), this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  __realRemoveChild(t2) {
    t2.__emitLifeEvent(Do.REMOVE), t2.parent = null, this.leafer && (t2.__bindLeafer(null), this.leafer.created && (this.__emitChildEvent(Do.REMOVE, t2), this.leafer.hitCanvasManager && this.leafer.hitCanvasManager.clear()));
  }
  __emitChildEvent(t2, e2) {
    const s2 = new Do(t2, e2, this);
    this.hasEvent(t2) && !this.isLeafer && this.emitEvent(s2), this.leafer.emitEvent(s2);
  }
};
bh = ye([qn(Da)], bh);
var Bh = class _Bh {
  get length() {
    return this.list.length;
  }
  constructor(t2) {
    this.reset(), t2 && (l(t2) ? this.addList(t2) : this.add(t2));
  }
  has(t2) {
    return t2 && !s(this.keys[t2.innerId]);
  }
  indexAt(t2) {
    return this.list[t2];
  }
  indexOf(t2) {
    const e2 = this.keys[t2.innerId];
    return s(e2) ? -1 : e2;
  }
  add(t2) {
    const { list: e2, keys: r2 } = this;
    s(r2[t2.innerId]) && (e2.push(t2), r2[t2.innerId] = e2.length - 1);
  }
  addAt(t2, e2 = 0) {
    const { keys: r2 } = this;
    if (s(r2[t2.innerId])) {
      const { list: s2 } = this;
      for (let t3 = e2, i2 = s2.length; t3 < i2; t3++) r2[s2[t3].innerId]++;
      0 === e2 ? s2.unshift(t2) : (e2 > s2.length && (e2 = s2.length), s2.splice(e2, 0, t2)), r2[t2.innerId] = e2;
    }
  }
  addList(t2) {
    for (let e2 = 0; e2 < t2.length; e2++) this.add(t2[e2]);
  }
  remove(t2) {
    const { list: e2 } = this;
    let r2;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) s(r2) ? e2[i2].innerId === t2.innerId && (r2 = i2, delete this.keys[t2.innerId]) : this.keys[e2[i2].innerId] = i2 - 1;
    s(r2) || e2.splice(r2, 1);
  }
  sort(t2) {
    const { list: e2 } = this;
    t2 ? e2.sort((t3, e3) => e3.__level - t3.__level) : e2.sort((t3, e3) => t3.__level - e3.__level);
  }
  forEach(t2) {
    this.list.forEach(t2);
  }
  clone() {
    const t2 = new _Bh();
    return t2.list = [...this.list], t2.keys = Object.assign({}, this.keys), t2;
  }
  update() {
    this.keys = {};
    const { list: t2, keys: e2 } = this;
    for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) e2[t2[s2].innerId] = s2;
  }
  reset() {
    this.list = [], this.keys = {};
  }
  destroy() {
    this.reset();
  }
};
var vh = class {
  get length() {
    return this._length;
  }
  constructor(t2) {
    this._length = 0, this.reset(), t2 && (l(t2) ? this.addList(t2) : this.add(t2));
  }
  has(t2) {
    return !s(this.keys[t2.innerId]);
  }
  without(t2) {
    return s(this.keys[t2.innerId]);
  }
  sort(t2) {
    const { levels: e2 } = this;
    t2 ? e2.sort((t3, e3) => e3 - t3) : e2.sort((t3, e3) => t3 - e3);
  }
  addList(t2) {
    t2.forEach((t3) => {
      this.add(t3);
    });
  }
  add(t2) {
    const { keys: e2, levelMap: s2 } = this;
    e2[t2.innerId] || (e2[t2.innerId] = 1, s2[t2.__level] ? s2[t2.__level].push(t2) : (s2[t2.__level] = [t2], this.levels.push(t2.__level)), this._length++);
  }
  forEach(t2) {
    let e2;
    this.levels.forEach((s2) => {
      e2 = this.levelMap[s2];
      for (let s3 = 0, r2 = e2.length; s3 < r2; s3++) t2(e2[s3]);
    });
  }
  reset() {
    this.levelMap = {}, this.keys = {}, this.levels = [], this._length = 0;
  }
  destroy() {
    this.levelMap = null;
  }
};
var kh = "2.0.0";

// node_modules/@leafer-ui/draw/lib/draw.esm.min.js
function St2(t2, e2, i2, s2) {
  var o2, r2 = arguments.length, a2 = r2 < 3 ? e2 : null === s2 ? s2 = Object.getOwnPropertyDescriptor(e2, i2) : s2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a2 = Reflect.decorate(t2, e2, i2, s2);
  else for (var n2 = t2.length - 1; n2 >= 0; n2--) (o2 = t2[n2]) && (a2 = (r2 < 3 ? o2(a2) : r2 > 3 ? o2(e2, i2, a2) : o2(e2, i2)) || a2);
  return r2 > 3 && a2 && Object.defineProperty(e2, i2, a2), a2;
}
function mt2(t2) {
  return dn(t2, (t3) => cn({ set(e2) {
    this.__setAttr(t3, e2), e2 && (this.__.__useEffect = true), this.__layout.renderChanged || this.__layout.renderChange();
  } }));
}
function Rt2(t2) {
  return dn(t2, (t3) => cn({ set(e2) {
    this.__setAttr(t3, e2), this.__layout.boxChanged || this.__layout.boxChange(), this.__updateSize();
  } }));
}
function kt2() {
  return (e2, i2) => {
    const s2 = "_" + i2;
    an(e2, i2, { set(t2) {
      this.isLeafer && (this[s2] = t2);
    }, get() {
      return this.isApp ? this.tree.zoomLayer : this.isLeafer ? this[s2] || this : this.leafer && this.leafer.zoomLayer;
    } });
  };
}
function Bt2(e2) {
  return (i2, o2) => {
    an(i2, o2, ln(o2, e2));
  };
}
var At2 = {};
var Ct2 = { hasTransparent: function(t2) {
  if (!t2 || 7 === t2.length || 4 === t2.length) return false;
  if ("transparent" === t2) return true;
  const e2 = t2[0];
  if ("#" === e2) switch (t2.length) {
    case 5:
      return "f" !== t2[4] && "F" !== t2[4];
    case 9:
      return "f" !== t2[7] && "F" !== t2[7] || "f" !== t2[8] && "F" !== t2[8];
  }
  else if (("r" === e2 || "h" === e2) && "a" === t2[3]) {
    const e3 = t2.lastIndexOf(",");
    if (e3 > -1) return parseFloat(t2.slice(e3 + 1)) < 1;
  }
  return false;
} };
var bt2 = qt;
var Pt2 = {};
var Ft2 = {};
var Wt2 = {};
var Et2 = {};
var Dt2 = {};
var It2 = { apply() {
  he.need("filter");
} };
var Tt2 = {};
var Lt2 = { setStyleName: () => he.need("state"), set: () => he.need("state") };
var zt2 = { list: {}, register(t2, e2) {
  zt2.list[t2] = e2;
}, get: (t2) => zt2.list[t2] };
var { parse: Mt2, objectToCanvasData: Ot2 } = sr;
var { stintSet: Nt2 } = _;
var { hasTransparent: Vt2 } = Ct2;
var Ht2 = { originPaint: {} };
var Yt2 = ee.get("UIData");
var Ut2 = class extends f {
  get scale() {
    const { scaleX: t2, scaleY: e2 } = this;
    return t2 !== e2 ? { x: t2, y: e2 } : t2;
  }
  get __strokeWidth() {
    return this.__getRealStrokeWidth();
  }
  get __maxStrokeWidth() {
    const t2 = this;
    return t2.__hasMultiStrokeStyle ? Math.max(t2.__hasMultiStrokeStyle, t2.strokeWidth) : t2.strokeWidth;
  }
  get __hasMultiPaint() {
    const t2 = this;
    return t2.fill && this.__useStroke || t2.__isFills && t2.fill.length > 1 || t2.__isStrokes && t2.stroke.length > 1 || t2.__useEffect;
  }
  get __clipAfterFill() {
    const t2 = this;
    return t2.cornerRadius || t2.innerShadow || t2.__pathInputed;
  }
  get __hasSurface() {
    return this.fill || this.stroke;
  }
  get __autoWidth() {
    return !this._width;
  }
  get __autoHeight() {
    return !this._height;
  }
  get __autoSide() {
    return !this._width || !this._height;
  }
  get __autoSize() {
    return !this._width && !this._height;
  }
  setVisible(t2) {
    this._visible = t2;
    const { leafer: e2 } = this.__leaf;
    e2 && (e2.watcher.hasVisible = true);
  }
  setWidth(t2) {
    t2 < 0 ? (this._width = -t2, this.__leaf.scaleX *= -1, Yt2.warn("width < 0, instead -scaleX ", this)) : this._width = t2;
  }
  setHeight(t2) {
    t2 < 0 ? (this._height = -t2, this.__leaf.scaleY *= -1, Yt2.warn("height < 0, instead -scaleY", this)) : this._height = t2;
  }
  setFill(t2) {
    this.__naturalWidth && this.__removeNaturalSize(), i(t2) || !t2 ? (Nt2(this, "__isTransparentFill", Vt2(t2)), this.__isFills && this.__removePaint("fill", true), this._fill = t2) : d(t2) && this.__setPaint("fill", t2);
  }
  setStroke(t2) {
    i(t2) || !t2 ? (Nt2(this, "__isTransparentStroke", Vt2(t2)), this.__isStrokes && this.__removePaint("stroke", true), this._stroke = t2) : d(t2) && this.__setPaint("stroke", t2);
  }
  setPath(t2) {
    const e2 = i(t2);
    e2 || t2 && d(t2[0]) ? (this.__setInput("path", t2), this._path = e2 ? Mt2(t2) : Ot2(t2)) : (this.__input && this.__removeInput("path"), this._path = t2);
  }
  setShadow(t2) {
    Xt2(this, "shadow", t2);
  }
  setInnerShadow(t2) {
    Xt2(this, "innerShadow", t2);
  }
  setFilter(t2) {
    Xt2(this, "filter", t2);
  }
  __computePaint() {
    const { fill: t2, stroke: e2 } = this.__input;
    t2 && Ft2.compute("fill", this.__leaf), e2 && Ft2.compute("stroke", this.__leaf), this.__needComputePaint = void 0;
  }
  __getRealStrokeWidth(t2) {
    let { strokeWidth: e2, strokeWidthFixed: i2 } = this;
    if (t2 && (t2.strokeWidth && (e2 = t2.strokeWidth), s(t2.strokeWidthFixed) || (i2 = t2.strokeWidthFixed)), i2) {
      const t3 = this.__leaf.getClampRenderScale();
      return t3 > 1 ? e2 / t3 : e2;
    }
    return e2;
  }
  __setPaint(t2, e2) {
    this.__setInput(t2, e2);
    const i2 = this.__leaf.__layout;
    i2.boxChanged || i2.boxChange(), l(e2) && !e2.length ? this.__removePaint(t2) : "fill" === t2 ? (this.__isFills = true, this._fill || (this._fill = Ht2)) : (this.__isStrokes = true, this._stroke || (this._stroke = Ht2));
  }
  __removePaint(t2, e2) {
    e2 && this.__removeInput(t2), Wt2.recycleImage(t2, this), "fill" === t2 ? (Nt2(this, "__isAlphaPixelFill", void 0), this._fill = this.__isFills = void 0) : (Nt2(this, "__isAlphaPixelStroke", void 0), Nt2(this, "__hasMultiStrokeStyle", void 0), this._stroke = this.__isStrokes = void 0);
  }
};
function Xt2(t2, e2, i2) {
  t2.__setInput(e2, i2), l(i2) ? (i2.some((t3) => false === t3.visible) && (i2 = i2.filter((t3) => false !== t3.visible)), i2.length || (i2 = void 0)) : i2 = i2 && false !== i2.visible ? [i2] : void 0, t2["_" + e2] = i2;
}
var jt2 = class extends Ut2 {
};
var Jt2 = class extends jt2 {
  get __boxStroke() {
    return !this.__pathInputed;
  }
  get __drawAfterFill() {
    return this.__single || this.__clipAfterFill;
  }
  get __clipAfterFill() {
    const t2 = this;
    return "show" !== t2.overflow && t2.__leaf.children.length && (t2.__leaf.isOverflow || super.__clipAfterFill);
  }
};
var qt2 = class extends jt2 {
  __getInputData(t2, e2) {
    const i2 = super.__getInputData(t2, e2);
    return Re.forEach((t3) => delete i2[t3]), i2;
  }
};
var Gt2 = class extends Jt2 {
};
var $t2 = class extends Ut2 {
  get __usePathBox() {
    return this.points || this.__pathInputed;
  }
};
var Kt2 = class extends Ut2 {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var Qt2 = class extends Ut2 {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var Zt2 = class extends $t2 {
};
var te2 = class extends Ut2 {
};
var ee2 = class extends Ut2 {
  get __pathInputed() {
    return 2;
  }
};
var ie2 = class extends jt2 {
};
var se2 = { thin: 100, "extra-light": 200, light: 300, normal: 400, medium: 500, "semi-bold": 600, bold: 700, "extra-bold": 800, black: 900 };
var oe2 = class extends Ut2 {
  get __useNaturalRatio() {
    return false;
  }
  setFontWeight(t2) {
    i(t2) ? (this.__setInput("fontWeight", t2), t2 = se2[t2] || 400) : this.__input && this.__removeInput("fontWeight"), this._fontWeight = t2;
  }
  setBoxStyle(t2) {
    let e2 = this.__leaf, i2 = e2.__box;
    if (t2) {
      const { boxStyle: s2 } = this;
      if (i2) for (let t3 in s2) i2[t3] = void 0;
      else i2 = e2.__box = ce.get("Rect", 0);
      const o2 = e2.__layout, r2 = i2.__layout;
      s2 || (i2.parent = e2, i2.__world = e2.__world, r2.boxBounds = o2.boxBounds), i2.set(t2), r2.strokeChanged && o2.strokeChange();
    } else i2 && (e2.__box = i2.parent = null, i2.destroy());
    this._boxStyle = t2;
  }
  __getInputData(t2, e2) {
    const i2 = super.__getInputData(t2, e2);
    return i2.textEditing && delete i2.textEditing, i2;
  }
};
var re2 = class extends Kt2 {
  setUrl(t2) {
    this.__setImageFill(t2), this._url = t2;
  }
  __setImageFill(t2) {
    this.fill = t2 ? { type: "image", mode: "stretch", url: t2 } : void 0;
  }
  __getData() {
    const t2 = super.__getData();
    return t2.url && delete t2.fill, t2;
  }
  __getInputData(t2, e2) {
    const i2 = super.__getInputData(t2, e2);
    return i2.url && delete i2.fill, i2;
  }
};
var ae2 = class extends Kt2 {
  get __isCanvas() {
    return true;
  }
  get __drawAfterFill() {
    return true;
  }
  __getInputData(t2, e2) {
    const i2 = super.__getInputData(t2, e2);
    return i2.url = this.__leaf.canvas.toDataURL("image/png"), i2;
  }
};
var { max: ne2, add: _e2 } = v;
var he2 = { __updateStrokeSpread() {
  let t2 = 0, e2 = 0;
  const i2 = this.__, { strokeAlign: s2, __maxStrokeWidth: o2 } = i2, r2 = this.__box;
  if ((i2.stroke || "all" === i2.hitStroke) && o2 && "inside" !== s2 && (e2 = t2 = "center" === s2 ? o2 / 2 : o2, !i2.__boxStroke)) {
    const e3 = i2.__isLinePath ? 0 : 10 * t2, s3 = "none" === i2.strokeCap ? 0 : o2;
    t2 += Math.max(e3, s3);
  }
  return i2.__useArrow && (t2 += 5 * o2), r2 && (t2 = ne2(t2, r2.__layout.strokeSpread = r2.__updateStrokeSpread()), e2 = Math.max(e2, r2.__layout.strokeBoxSpread)), this.__layout.strokeBoxSpread = e2, t2;
}, __updateRenderSpread() {
  let t2 = 0;
  const { shadow: e2, innerShadow: i2, blur: s2, backgroundBlur: o2, filter: r2, renderSpread: a2 } = this.__, { strokeSpread: n2 } = this.__layout, _2 = this.__box;
  e2 && (t2 = Dt2.getShadowRenderSpread(this, e2)), s2 && (t2 = ne2(t2, s2)), r2 && (t2 = _e2(t2, It2.getSpread(r2))), a2 && (t2 = _e2(t2, a2)), n2 && (t2 = _e2(t2, n2));
  let h2 = t2;
  return i2 && (h2 = ne2(h2, Dt2.getInnerShadowSpread(this, i2))), o2 && (h2 = ne2(h2, o2)), this.__layout.renderShapeSpread = h2, _2 ? ne2(_2.__updateRenderSpread(), t2) : t2;
} };
var { stintSet: de2 } = _;
var le2 = { __updateChange() {
  const t2 = this.__;
  if (t2.__useStroke) {
    const e2 = t2.__useStroke = !(!t2.stroke || !t2.strokeWidth);
    de2(this.__world, "half", e2 && "center" === t2.strokeAlign && t2.strokeWidth % 2), de2(t2, "__fillAfterStroke", e2 && "outside" === t2.strokeAlign && t2.fill && !t2.__isTransparentFill);
  }
  if (t2.__useEffect) {
    const { shadow: e2, fill: i2, stroke: s2 } = t2, o2 = t2.innerShadow || t2.blur || t2.backgroundBlur || t2.filter;
    de2(t2, "__isFastShadow", e2 && !o2 && e2.length < 2 && !e2[0].spread && !Dt2.isTransformShadow(e2[0]) && i2 && !t2.__isTransparentFill && !(l(i2) && i2.length > 1) && (this.useFastShadow || !s2 || s2 && "inside" === t2.strokeAlign)), t2.__useEffect = !(!e2 && !o2);
  }
  t2.__checkSingle(), de2(t2, "__complex", t2.__isFills || t2.__isStrokes || t2.cornerRadius || t2.__useEffect);
}, __drawFast(t2, e2) {
  pe2(this, t2, e2);
}, __draw(t2, e2, i2) {
  const s2 = this.__;
  if (s2.__complex) {
    s2.__needComputePaint && s2.__computePaint();
    const { fill: o2, stroke: r2, __drawAfterFill: a2, __fillAfterStroke: n2, __isFastShadow: _2 } = s2;
    if (this.__drawRenderPath(t2), s2.__useEffect && !_2) {
      const _3 = Ft2.shape(this, t2, e2);
      this.__nowWorld = this.__getNowWorld(e2);
      const { shadow: h2, innerShadow: d2, filter: l2 } = s2;
      h2 && Dt2.shadow(this, t2, _3), n2 && (s2.__isStrokes ? Ft2.strokes(r2, this, t2, e2) : Ft2.stroke(r2, this, t2, e2)), o2 && (s2.__isFills ? Ft2.fills(o2, this, t2, e2) : Ft2.fill(o2, this, t2, e2)), a2 && this.__drawAfterFill(t2, e2), d2 && Dt2.innerShadow(this, t2, _3), r2 && !n2 && (s2.__isStrokes ? Ft2.strokes(r2, this, t2, e2) : Ft2.stroke(r2, this, t2, e2)), l2 && It2.apply(l2, this, this.__nowWorld, t2, i2, _3), _3.worldCanvas && _3.worldCanvas.recycle(), _3.canvas.recycle();
    } else {
      if (n2 && (s2.__isStrokes ? Ft2.strokes(r2, this, t2, e2) : Ft2.stroke(r2, this, t2, e2)), _2) {
        const e3 = s2.shadow[0], { scaleX: i3, scaleY: o3 } = this.getRenderScaleData(true, e3.scaleFixed);
        t2.save(), t2.setWorldShadow(e3.x * i3, e3.y * o3, e3.blur * i3, Ct2.string(e3.color));
      }
      o2 && (s2.__isFills ? Ft2.fills(o2, this, t2, e2) : Ft2.fill(o2, this, t2, e2)), _2 && t2.restore(), a2 && this.__drawAfterFill(t2, e2), r2 && !n2 && (s2.__isStrokes ? Ft2.strokes(r2, this, t2, e2) : Ft2.stroke(r2, this, t2, e2));
    }
  } else s2.__pathForRender ? pe2(this, t2, e2) : this.__drawFast(t2, e2);
}, __drawShape(t2, e2) {
  this.__drawRenderPath(t2);
  const i2 = this.__, { fill: s2, stroke: o2 } = i2;
  s2 && !e2.ignoreFill && (i2.__isAlphaPixelFill ? Ft2.fills(s2, this, t2, e2) : Ft2.fill("#000000", this, t2, e2)), i2.__isCanvas && this.__drawAfterFill(t2, e2), o2 && !e2.ignoreStroke && (i2.__isAlphaPixelStroke ? Ft2.strokes(o2, this, t2, e2) : Ft2.stroke("#000000", this, t2, e2));
}, __drawAfterFill(t2, e2) {
  this.__.__clipAfterFill ? (t2.save(), t2.clipUI(this), this.__drawContent(t2, e2), t2.restore()) : this.__drawContent(t2, e2);
} };
function pe2(t2, e2, i2) {
  const { fill: s2, stroke: o2, __drawAfterFill: r2, __fillAfterStroke: a2 } = t2.__;
  t2.__drawRenderPath(e2), a2 && Ft2.stroke(o2, t2, e2, i2), s2 && Ft2.fill(s2, t2, e2, i2), r2 && t2.__drawAfterFill(e2, i2), o2 && !a2 && Ft2.stroke(o2, t2, e2, i2);
}
var ue2 = { __drawFast(t2, e2) {
  let { x: i2, y: s2, width: o2, height: r2 } = this.__layout.boxBounds;
  const { fill: a2, stroke: n2, __drawAfterFill: _2 } = this.__;
  if (a2 && (t2.fillStyle = a2, t2.fillRect(i2, s2, o2, r2)), _2 && this.__drawAfterFill(t2, e2), n2) {
    const { strokeAlign: a3, __strokeWidth: _3 } = this.__;
    if (!_3) return;
    t2.setStroke(n2, _3, this.__);
    const h2 = _3 / 2;
    switch (a3) {
      case "center":
        t2.strokeRect(0, 0, o2, r2);
        break;
      case "inside":
        o2 -= _3, r2 -= _3, o2 < 0 || r2 < 0 ? (t2.save(), this.__clip(t2, e2), t2.strokeRect(i2 + h2, s2 + h2, o2, r2), t2.restore()) : t2.strokeRect(i2 + h2, s2 + h2, o2, r2);
        break;
      case "outside":
        t2.strokeRect(i2 - h2, s2 - h2, o2 + _3, r2 + _3);
    }
  }
} };
var ce2;
var ge2 = ce2 = class extends ch {
  get app() {
    return this.leafer && this.leafer.app;
  }
  get isFrame() {
    return false;
  }
  set scale(t2) {
    I.assignScale(this, t2);
  }
  get scale() {
    return this.__.scale;
  }
  get isAutoWidth() {
    const t2 = this.__;
    return t2.__autoWidth || t2.autoWidth;
  }
  get isAutoHeight() {
    const t2 = this.__;
    return t2.__autoHeight || t2.autoHeight;
  }
  get pen() {
    const { path: t2 } = this.__;
    return ji.set(this.path = t2 || []), t2 || this.__drawPathByBox(ji), ji;
  }
  reset(t2) {
  }
  set(t2, e2) {
    t2 && Object.assign(this, t2);
  }
  get(t2) {
    return i(t2) ? this.__.__getInput(t2) : this.__.__getInputData(t2);
  }
  createProxyData() {
  }
  find(t2, e2) {
    return he.need("find");
  }
  findTag(t2) {
    return this.find({ tag: t2 });
  }
  findOne(t2, e2) {
    return he.need("find");
  }
  findId(t2) {
    return this.findOne({ id: t2 });
  }
  getPath(t2, e2) {
    this.__layout.update();
    let i2 = e2 ? this.__.__pathForRender : this.__.path;
    return i2 || (ji.set(i2 = []), this.__drawPathByBox(ji, !e2)), t2 ? sr.toCanvasData(i2, true) : i2;
  }
  getPathString(t2, e2, i2) {
    return sr.stringify(this.getPath(t2, e2), i2);
  }
  load() {
    this.__.__computePaint();
  }
  __onUpdateSize() {
    if (this.__.__input) {
      const t2 = this.__;
      !t2.lazy || this.__inLazyBounds || Tt2.running ? t2.__computePaint() : t2.__needComputePaint = true;
    }
  }
  __updateRenderPath() {
    const t2 = this.__;
    t2.path ? (t2.__pathForRender = t2.cornerRadius ? Fi.smooth(t2.path, t2.cornerRadius, t2.cornerSmoothing) : t2.path, t2.__useArrow && Pt2.addArrows(this)) : t2.__pathForRender && (t2.__pathForRender = void 0);
  }
  __drawRenderPath(t2) {
    t2.beginPath(), this.__drawPathByData(t2, this.__.__pathForRender);
  }
  __drawPath(t2) {
    t2.beginPath(), this.__drawPathByData(t2, this.__.path, true);
  }
  __drawPathByData(t2, e2, i2) {
    e2 ? ri.drawPathByData(t2, e2) : this.__drawPathByBox(t2, i2);
  }
  __drawPathByBox(t2, e2) {
    const { x: i2, y: s2, width: o2, height: r2 } = this.__layout.boxBounds;
    if (this.__.cornerRadius && !e2) {
      const { cornerRadius: e3 } = this.__;
      t2.roundRect(i2, s2, o2, r2, o(e3) ? [e3] : e3);
    } else t2.rect(i2, s2, o2, r2);
    t2.closePath();
  }
  drawImagePlaceholder(t2, e2, i2) {
    Ft2.fill(this.__.placeholderColor, this, e2, i2);
  }
  animate(t2, e2, i2, s2) {
    return this.set(t2), he.need("animate");
  }
  killAnimate(t2, e2) {
  }
  export(t2, e2) {
    return he.need("export");
  }
  syncExport(t2, e2) {
    return he.need("export");
  }
  clone(t2) {
    const e2 = _.clone(this.toJSON());
    return t2 && Object.assign(e2, t2), ce2.one(e2);
  }
  static one(t2, e2, i2, s2, o2) {
    return ce.get(t2.tag || this.prototype.__tag, t2, e2, i2, s2, o2);
  }
  static registerUI() {
    Qn()(this);
  }
  static registerData(t2) {
    Dn(t2)(this.prototype);
  }
  static setEditConfig(t2) {
  }
  static setEditOuter(t2) {
  }
  static setEditInner(t2) {
  }
  destroy() {
    this.fill = this.stroke = null, this.__animate && this.killAnimate(), super.destroy();
  }
};
St2([Dn(Ut2)], ge2.prototype, "__", void 0), St2([kt2()], ge2.prototype, "zoomLayer", void 0), St2([_n("")], ge2.prototype, "id", void 0), St2([_n("")], ge2.prototype, "name", void 0), St2([_n("")], ge2.prototype, "className", void 0), St2([Pn("pass-through")], ge2.prototype, "blendMode", void 0), St2([Ln(1)], ge2.prototype, "opacity", void 0), St2([Rn(true)], ge2.prototype, "visible", void 0), St2([Pn(false)], ge2.prototype, "locked", void 0), St2([Sn(false)], ge2.prototype, "dim", void 0), St2([Sn(false)], ge2.prototype, "dimskip", void 0), St2([Mn(0)], ge2.prototype, "zIndex", void 0), St2([An(false)], ge2.prototype, "mask", void 0), St2([Wn(false)], ge2.prototype, "eraser", void 0), St2([pn(0, true)], ge2.prototype, "x", void 0), St2([pn(0, true)], ge2.prototype, "y", void 0), St2([xn(100, true)], ge2.prototype, "width", void 0), St2([xn(100, true)], ge2.prototype, "height", void 0), St2([yn(1, true)], ge2.prototype, "scaleX", void 0), St2([yn(1, true)], ge2.prototype, "scaleY", void 0), St2([mn(0, true)], ge2.prototype, "rotation", void 0), St2([mn(0, true)], ge2.prototype, "skewX", void 0), St2([mn(0, true)], ge2.prototype, "skewY", void 0), St2([pn(0, true)], ge2.prototype, "offsetX", void 0), St2([pn(0, true)], ge2.prototype, "offsetY", void 0), St2([fn(0, true)], ge2.prototype, "scrollX", void 0), St2([fn(0, true)], ge2.prototype, "scrollY", void 0), St2([gn()], ge2.prototype, "origin", void 0), St2([gn()], ge2.prototype, "around", void 0), St2([_n(false)], ge2.prototype, "lazy", void 0), St2([wn(1)], ge2.prototype, "pixelRatio", void 0), St2([Tn(0)], ge2.prototype, "renderSpread", void 0), St2([Bn()], ge2.prototype, "path", void 0), St2([vn()], ge2.prototype, "windingRule", void 0), St2([vn(true)], ge2.prototype, "closed", void 0), St2([xn(0)], ge2.prototype, "padding", void 0), St2([xn(false)], ge2.prototype, "lockRatio", void 0), St2([xn()], ge2.prototype, "widthRange", void 0), St2([xn()], ge2.prototype, "heightRange", void 0), St2([_n(false)], ge2.prototype, "draggable", void 0), St2([_n()], ge2.prototype, "dragBounds", void 0), St2([_n("auto")], ge2.prototype, "dragBoundsType", void 0), St2([_n(false)], ge2.prototype, "editable", void 0), St2([Nn(true)], ge2.prototype, "hittable", void 0), St2([Nn("path")], ge2.prototype, "hitFill", void 0), St2([On("path")], ge2.prototype, "hitStroke", void 0), St2([Nn(false)], ge2.prototype, "hitBox", void 0), St2([Nn(true)], ge2.prototype, "hitChildren", void 0), St2([Nn(true)], ge2.prototype, "hitSelf", void 0), St2([Nn()], ge2.prototype, "hitRadius", void 0), St2([Yn("")], ge2.prototype, "cursor", void 0), St2([Pn()], ge2.prototype, "fill", void 0), St2([On(void 0, true)], ge2.prototype, "stroke", void 0), St2([On("inside")], ge2.prototype, "strokeAlign", void 0), St2([On(1, true)], ge2.prototype, "strokeWidth", void 0), St2([On(false)], ge2.prototype, "strokeWidthFixed", void 0), St2([On("none")], ge2.prototype, "strokeCap", void 0), St2([On("miter")], ge2.prototype, "strokeJoin", void 0), St2([On()], ge2.prototype, "dashPattern", void 0), St2([On(0)], ge2.prototype, "dashOffset", void 0), St2([On(10)], ge2.prototype, "miterLimit", void 0), St2([vn(0)], ge2.prototype, "cornerRadius", void 0), St2([vn()], ge2.prototype, "cornerSmoothing", void 0), St2([mt2()], ge2.prototype, "shadow", void 0), St2([mt2()], ge2.prototype, "innerShadow", void 0), St2([mt2()], ge2.prototype, "blur", void 0), St2([mt2()], ge2.prototype, "backgroundBlur", void 0), St2([mt2()], ge2.prototype, "grayscale", void 0), St2([mt2()], ge2.prototype, "filter", void 0), St2([Pn()], ge2.prototype, "placeholderColor", void 0), St2([_n(100)], ge2.prototype, "placeholderDelay", void 0), St2([_n({})], ge2.prototype, "data", void 0), St2([Hn(ch.prototype.reset)], ge2.prototype, "reset", null), ge2 = ce2 = St2([qn(he2), qn(le2), Vn()], ge2);
var ye2 = class extends ge2 {
  get __tag() {
    return "Group";
  }
  get isBranch() {
    return true;
  }
  reset(t2) {
    this.__setBranch(), super.reset(t2);
  }
  __setBranch() {
    this.children || (this.children = []);
  }
  set(t2, e2) {
    if (t2) if (t2.children) {
      const { children: i2 } = t2;
      delete t2.children, this.children ? this.clear() : this.__setBranch(), super.set(t2, e2), i2.forEach((t3) => this.add(t3)), t2.children = i2;
    } else super.set(t2, e2);
  }
  toJSON(t2) {
    const e2 = super.toJSON(t2);
    return this.childlessJSON || (e2.children = this.children.map((e3) => e3.toJSON(t2))), e2;
  }
  pick(t2, e2) {
  }
  addAt(t2, e2) {
    this.add(t2, e2);
  }
  addAfter(t2, e2) {
    this.add(t2, this.children.indexOf(e2) + 1);
  }
  addBefore(t2, e2) {
    this.add(t2, this.children.indexOf(e2));
  }
  add(t2, e2) {
  }
  addMany(...t2) {
  }
  remove(t2, e2) {
  }
  removeAll(t2) {
  }
  clear() {
  }
};
var ve2;
St2([Dn(jt2)], ye2.prototype, "__", void 0), St2([xn(0)], ye2.prototype, "width", void 0), St2([xn(0)], ye2.prototype, "height", void 0), ye2 = St2([qn(bh), Qn()], ye2);
var fe2 = ee.get("Leafer");
var we2 = ve2 = class extends ye2 {
  get __tag() {
    return "Leafer";
  }
  get isApp() {
    return false;
  }
  get app() {
    return this.parent || this;
  }
  get isLeafer() {
    return true;
  }
  get imageReady() {
    return this.viewReady && Ki.isComplete;
  }
  get layoutLocked() {
    return !this.layouter.running;
  }
  get view() {
    return this.canvas && this.canvas.view;
  }
  get FPS() {
    return this.renderer ? this.renderer.FPS : 60;
  }
  get cursorPoint() {
    return this.interaction && this.interaction.hoverData || { x: this.width / 2, y: this.height / 2 };
  }
  get clientBounds() {
    return this.canvas && this.canvas.getClientBounds(true) || D();
  }
  constructor(t2, e2) {
    super(e2), this.config = { start: true, hittable: true, smooth: true, lazySpeard: 100 }, this.leafs = 0, this.__eventIds = [], this.__controllers = [], this.__readyWait = [], this.__viewReadyWait = [], this.__viewCompletedWait = [], this.__nextRenderWait = [], this.userConfig = t2, t2 && (t2.view || t2.width) && this.init(t2), ve2.list.add(this);
  }
  init(t2, e2) {
    if (this.canvas) return;
    let i2;
    const { config: s2 } = this;
    this.__setLeafer(this), e2 && (this.parentApp = e2, this.__bindApp(e2), i2 = e2.running), t2 && (this.parent = e2, this.initType(t2.type), this.parent = void 0, _.assign(s2, t2));
    const o2 = this.canvas = le.canvas(s2);
    this.__controllers.push(this.renderer = le.renderer(this, o2, s2), this.watcher = le.watcher(this, s2), this.layouter = le.layouter(this, s2)), this.isApp && this.__setApp(), this.__checkAutoLayout(), e2 || (this.selector = le.selector(this), this.interaction = le.interaction(this, o2, this.selector, s2), this.interaction && (this.__controllers.unshift(this.interaction), this.hitCanvasManager = le.hitCanvasManager()), this.canvasManager = new ge(), i2 = s2.start), this.hittable = s2.hittable, this.fill = s2.fill, this.canvasManager.add(o2), this.__listenEvents(), i2 && (this.__startTimer = setTimeout(this.start.bind(this))), To.run(this.__initWait), this.onInit();
  }
  onInit() {
  }
  initType(t2) {
  }
  set(t2, e2) {
    this.waitInit(() => {
      super.set(t2, e2);
    });
  }
  start() {
    clearTimeout(this.__startTimer), !this.running && this.canvas && (this.running = true, this.ready ? this.emitLeafer(ta.RESTART) : this.emitLeafer(ta.START), this.__controllers.forEach((t2) => t2.start()), this.isApp || this.renderer.render());
  }
  stop() {
    clearTimeout(this.__startTimer), this.running && this.canvas && (this.__controllers.forEach((t2) => t2.stop()), this.running = false, this.emitLeafer(ta.STOP));
  }
  unlockLayout() {
    this.layouter.start(), this.updateLayout();
  }
  lockLayout() {
    this.updateLayout(), this.layouter.stop();
  }
  resize(t2) {
    const e2 = _.copyAttrs({}, t2, Re);
    Object.keys(e2).forEach((t3) => this[t3] = e2[t3]);
  }
  forceRender(t2, e2) {
    const { renderer: i2 } = this;
    i2 && (i2.addBlock(t2 ? new Ht(t2) : this.canvas.bounds), this.viewReady && (e2 ? i2.render() : i2.update()));
  }
  requestRender(t2 = false) {
    this.renderer && this.renderer.update(t2);
  }
  updateCursor(t2) {
    const e2 = this.interaction;
    e2 && (t2 ? e2.setCursor(t2) : e2.updateCursor());
  }
  updateLazyBounds() {
    this.lazyBounds = this.canvas.bounds.clone().spread(this.config.lazySpeard);
  }
  __doResize(t2) {
    const { canvas: e2 } = this;
    if (!e2 || e2.isSameSize(t2)) return;
    const i2 = _.copyAttrs({}, this.canvas, Re);
    e2.resize(t2), this.updateLazyBounds(), this.__onResize(new Jo(t2, i2));
  }
  __onResize(t2) {
    this.emitEvent(t2), _.copyAttrs(this.__, t2, Re), setTimeout(() => {
      this.canvasManager && this.canvasManager.clearRecycled();
    }, 0);
  }
  __setApp() {
  }
  __bindApp(t2) {
    this.selector = t2.selector, this.interaction = t2.interaction, this.canvasManager = t2.canvasManager, this.hitCanvasManager = t2.hitCanvasManager;
  }
  __setLeafer(t2) {
    this.leafer = t2, this.__level = 1;
  }
  __checkAutoLayout() {
    const { config: t2, parentApp: e2 } = this;
    e2 || (t2.width && t2.height || (this.autoLayout = new Gt(t2)), this.canvas.startAutoLayout(this.autoLayout, this.__onResize.bind(this)));
  }
  __setAttr(t2, e2) {
    return this.canvas && (Re.includes(t2) ? this.__changeCanvasSize(t2, e2) : "fill" === t2 ? this.__changeFill(e2) : "hittable" === t2 ? this.parent || (this.canvas.hittable = e2) : "zIndex" === t2 ? (this.canvas.zIndex = e2, setTimeout(() => this.parent && this.parent.__updateSortChildren())) : "mode" === t2 && this.emit(ta.UPDATE_MODE, { mode: e2 })), super.__setAttr(t2, e2);
  }
  __getAttr(t2) {
    return this.canvas && Re.includes(t2) ? this.canvas[t2] : super.__getAttr(t2);
  }
  __changeCanvasSize(t2, e2) {
    const { config: i2, canvas: s2 } = this, o2 = _.copyAttrs({}, s2, Re);
    o2[t2] = i2[t2] = e2, i2.width && i2.height ? s2.stopAutoLayout() : this.__checkAutoLayout(), this.__doResize(o2);
  }
  __changeFill(t2) {
    this.config.fill = t2, this.canvas.allowBackgroundColor ? this.canvas.backgroundColor = t2 : this.forceRender();
  }
  __onCreated() {
    this.created = true;
  }
  __onReady() {
    this.ready = true, this.emitLeafer(ta.BEFORE_READY), this.emitLeafer(ta.READY), this.emitLeafer(ta.AFTER_READY), To.run(this.__readyWait);
  }
  __onViewReady() {
    this.viewReady || (this.viewReady = true, this.emitLeafer(ta.VIEW_READY), To.run(this.__viewReadyWait));
  }
  __onLayoutEnd() {
    const { grow: t2, width: e2, height: i2 } = this.config;
    if (t2) {
      let { width: s2, height: o2, pixelRatio: r2 } = this;
      const a2 = "box" === t2 ? this.worldBoxBounds : this.__world;
      e2 || (s2 = Math.max(1, a2.x + a2.width)), i2 || (o2 = Math.max(1, a2.y + a2.height)), this.__doResize({ width: s2, height: o2, pixelRatio: r2 });
    }
    this.ready || this.__onReady();
  }
  __onNextRender() {
    if (this.viewReady) {
      To.run(this.__nextRenderWait);
      const { imageReady: t2 } = this;
      t2 && !this.viewCompleted && this.__checkViewCompleted(), t2 || (this.viewCompleted = false, this.requestRender());
    } else this.requestRender();
  }
  __checkViewCompleted(t2 = true) {
    this.nextRender(() => {
      this.imageReady && (t2 && this.emitLeafer(ta.VIEW_COMPLETED), To.run(this.__viewCompletedWait), this.viewCompleted = true);
    });
  }
  __onWatchData() {
    this.watcher.childrenChanged && this.interaction && this.nextRender(() => this.interaction.updateCursor());
  }
  waitInit(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.__initWait || (this.__initWait = []), this.canvas ? t2() : this.__initWait.push(t2);
  }
  waitReady(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.ready ? t2() : this.__readyWait.push(t2);
  }
  waitViewReady(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.viewReady ? t2() : this.__viewReadyWait.push(t2);
  }
  waitViewCompleted(t2, e2) {
    e2 && (t2 = t2.bind(e2)), this.__viewCompletedWait.push(t2), this.viewCompleted ? this.__checkViewCompleted(false) : this.running || this.start();
  }
  nextRender(t2, e2, i2) {
    e2 && (t2 = t2.bind(e2));
    const s2 = this.__nextRenderWait;
    if (i2) {
      for (let e3 = 0; e3 < s2.length; e3++) if (s2[e3] === t2) {
        s2.splice(e3, 1);
        break;
      }
    } else s2.push(t2);
    this.requestRender();
  }
  zoom(t2, e2, i2, s2) {
    return he.need("view");
  }
  getValidMove(t2, e2, i2) {
    return { x: t2, y: e2 };
  }
  getValidScale(t2) {
    return t2;
  }
  getWorldPointByClient(t2, e2) {
    return this.interaction && this.interaction.getLocal(t2, e2);
  }
  getPagePointByClient(t2, e2) {
    return this.getPagePoint(this.getWorldPointByClient(t2, e2));
  }
  getClientPointByWorld(t2) {
    const { x: e2, y: i2 } = this.clientBounds;
    return { x: e2 + t2.x, y: i2 + t2.y };
  }
  updateClientBounds() {
    this.canvas && this.canvas.updateClientBounds();
  }
  receiveEvent(t2) {
  }
  emitLeafer(t2) {
    this.emitEvent(new ta(t2, this));
  }
  __listenEvents() {
    const t2 = ne.start("FirstCreate " + this.innerName);
    this.once([[ta.START, () => ne.end(t2)], [$o.START, this.updateLazyBounds, this], [Ko.START, this.__onCreated, this], [Ko.END, this.__onViewReady, this]]), this.__eventIds.push(this.on_([[Zo.DATA, this.__onWatchData, this], [$o.END, this.__onLayoutEnd, this], [Ko.NEXT, this.__onNextRender, this]]));
  }
  __removeListenEvents() {
    this.off_(this.__eventIds);
  }
  destroy(t2) {
    const e2 = () => {
      if (!this.destroyed) {
        ve2.list.remove(this);
        try {
          this.stop(), this.emitLeafer(ta.END), this.__removeListenEvents(), this.__controllers.forEach((t3) => !(this.parent && t3 === this.interaction) && t3.destroy()), this.__controllers.length = 0, this.parent || (this.selector && this.selector.destroy(), this.hitCanvasManager && this.hitCanvasManager.destroy(), this.canvasManager && this.canvasManager.destroy()), this.canvas && this.canvas.destroy(), this.config.view = this.parentApp = null, this.userConfig && (this.userConfig.view = null), super.destroy(), setTimeout(() => {
            en.clearRecycled();
          }, 100);
        } catch (t3) {
          fe2.error(t3);
        }
      }
    };
    t2 ? e2() : setTimeout(e2);
  }
};
we2.list = new Bh(), St2([Dn(qt2)], we2.prototype, "__", void 0), St2([xn()], we2.prototype, "pixelRatio", void 0), St2([_n("normal")], we2.prototype, "mode", void 0), we2 = ve2 = St2([Qn()], we2);
var xe2 = class extends ge2 {
  get __tag() {
    return "Rect";
  }
};
St2([Dn(Kt2)], xe2.prototype, "__", void 0), xe2 = St2([qn(ue2), Vn(), Qn()], xe2);
var { add: Se2, includes: me2, scroll: Re2 } = zt;
var ke2 = xe2.prototype;
var Be2 = ye2.prototype;
var Ae2 = class extends ye2 {
  get __tag() {
    return "Box";
  }
  get isBranchLeaf() {
    return true;
  }
  constructor(t2) {
    super(t2), this.__layout.renderChanged || this.__layout.renderChange();
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRectRenderSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return this.__updateRectRenderSpread() || -1;
  }
  __updateRectBoxBounds() {
  }
  __updateBoxBounds(t2) {
    if (this.children.length && !this.pathInputed) {
      const t3 = this.__;
      if (t3.__autoSide) {
        t3.__hasSurface && this.__extraUpdate(), super.__updateBoxBounds();
        const { boxBounds: e2 } = this.__layout;
        t3.__autoSize || (t3.__autoWidth ? (e2.width += e2.x, e2.x = 0, e2.height = t3.height, e2.y = 0) : (e2.height += e2.y, e2.y = 0, e2.width = t3.width, e2.x = 0)), this.__updateNaturalSize();
      } else this.__updateRectBoxBounds();
    } else this.__updateRectBoxBounds();
  }
  __updateStrokeBounds() {
  }
  __updateRenderBounds() {
    let t2, e2;
    if (this.children.length) {
      const i2 = this.__, s2 = this.__layout, { renderBounds: o2, boxBounds: r2 } = s2, { overflow: a2 } = i2, n2 = s2.childrenRenderBounds || (s2.childrenRenderBounds = D());
      super.__updateRenderBounds(n2), (e2 = a2 && a2.includes("scroll")) && (Se2(n2, r2), Re2(n2, i2)), this.__updateRectRenderBounds(), t2 = !me2(r2, n2), t2 && "show" === a2 && Se2(o2, n2);
    } else this.__updateRectRenderBounds();
    _.stintSet(this, "isOverflow", t2), this.__checkScroll(e2);
  }
  __updateRectRenderBounds() {
  }
  __checkScroll(t2) {
  }
  __updateRectChange() {
  }
  __updateChange() {
    super.__updateChange(), this.__updateRectChange();
  }
  __renderRect(t2, e2) {
  }
  __renderGroup(t2, e2) {
  }
  __render(t2, e2) {
    this.__.__drawAfterFill ? this.__renderRect(t2, e2) : (this.__renderRect(t2, e2), this.children.length && this.__renderGroup(t2, e2)), this.hasScroller && this.scroller.__render(t2, e2);
  }
  __drawContent(t2, e2) {
    this.__renderGroup(t2, e2), (this.__.__useStroke || this.__.__useEffect) && (t2.setWorld(this.__nowWorld), this.__drawRenderPath(t2));
  }
};
St2([Dn(Jt2)], Ae2.prototype, "__", void 0), St2([xn(100)], Ae2.prototype, "width", void 0), St2([xn(100)], Ae2.prototype, "height", void 0), St2([_n(false)], Ae2.prototype, "resizeChildren", void 0), St2([Tn("show")], Ae2.prototype, "overflow", void 0), St2([Hn(ke2.__updateStrokeSpread)], Ae2.prototype, "__updateStrokeSpread", null), St2([Hn(ke2.__updateRenderSpread)], Ae2.prototype, "__updateRectRenderSpread", null), St2([Hn(ke2.__updateBoxBounds)], Ae2.prototype, "__updateRectBoxBounds", null), St2([Hn(ke2.__updateStrokeBounds)], Ae2.prototype, "__updateStrokeBounds", null), St2([Hn(ke2.__updateRenderBounds)], Ae2.prototype, "__updateRectRenderBounds", null), St2([Hn(ke2.__updateChange)], Ae2.prototype, "__updateRectChange", null), St2([Hn(ke2.__render)], Ae2.prototype, "__renderRect", null), St2([Hn(Be2.__render)], Ae2.prototype, "__renderGroup", null), Ae2 = St2([Vn(), Qn()], Ae2);
var Ce2 = class extends Ae2 {
  get __tag() {
    return "Frame";
  }
  get isFrame() {
    return true;
  }
};
St2([Dn(Gt2)], Ce2.prototype, "__", void 0), St2([Pn("#FFFFFF")], Ce2.prototype, "fill", void 0), St2([Tn("hide")], Ce2.prototype, "overflow", void 0), Ce2 = St2([Qn()], Ce2);
var { moveTo: be2, closePath: Pe2, ellipse: Fe2 } = Cr;
var We2 = class extends ge2 {
  get __tag() {
    return "Ellipse";
  }
  __updatePath() {
    const { width: t2, height: e2, innerRadius: i2, startAngle: s2, endAngle: o2 } = this.__, r2 = t2 / 2, a2 = e2 / 2, n2 = this.__.path = [];
    let _2;
    i2 ? s2 || o2 ? (i2 < 1 ? Fe2(n2, r2, a2, r2 * i2, a2 * i2, 0, s2, o2, false) : _2 = true, Fe2(n2, r2, a2, r2, a2, 0, o2, s2, true)) : (i2 < 1 && (Fe2(n2, r2, a2, r2 * i2, a2 * i2), be2(n2, t2, a2)), Fe2(n2, r2, a2, r2, a2, 0, 360, 0, true)) : s2 || o2 ? (be2(n2, r2, a2), Fe2(n2, r2, a2, r2, a2, 0, s2, o2, false)) : Fe2(n2, r2, a2, r2, a2), _2 || Pe2(n2), $t.ellipseToCurve && (this.__.path = this.getPath(true));
  }
};
St2([Dn(Qt2)], We2.prototype, "__", void 0), St2([vn(0)], We2.prototype, "innerRadius", void 0), St2([vn(0)], We2.prototype, "startAngle", void 0), St2([vn(0)], We2.prototype, "endAngle", void 0), We2 = St2([Qn()], We2);
var { sin: Ee2, cos: De2, PI: Ie2 } = Math;
var { moveTo: Te2, lineTo: Le2, closePath: ze2, drawPoints: Me2 } = Cr;
var Oe2 = class extends ge2 {
  get __tag() {
    return "Polygon";
  }
  __updatePath() {
    const t2 = this.__, e2 = t2.path = [];
    if (t2.points) Me2(e2, t2.points, t2.curve, true);
    else {
      const { width: i2, height: s2, sides: o2 } = t2, r2 = i2 / 2, a2 = s2 / 2;
      Te2(e2, r2, 0);
      for (let t3 = 1; t3 < o2; t3++) Le2(e2, r2 + r2 * Ee2(2 * t3 * Ie2 / o2), a2 - a2 * De2(2 * t3 * Ie2 / o2));
      ze2(e2);
    }
  }
};
St2([Dn(Zt2)], Oe2.prototype, "__", void 0), St2([vn(3)], Oe2.prototype, "sides", void 0), St2([vn()], Oe2.prototype, "points", void 0), St2([vn(0)], Oe2.prototype, "curve", void 0), Oe2 = St2([Vn(), Qn()], Oe2);
var { sin: Ne2, cos: Ve2, PI: He2 } = Math;
var { moveTo: Ye2, lineTo: Ue2, closePath: Xe2 } = Cr;
var je2 = class extends ge2 {
  get __tag() {
    return "Star";
  }
  __updatePath() {
    const { width: t2, height: e2, corners: i2, innerRadius: s2 } = this.__, o2 = t2 / 2, r2 = e2 / 2, a2 = this.__.path = [];
    Ye2(a2, o2, 0);
    for (let t3 = 1; t3 < 2 * i2; t3++) Ue2(a2, o2 + (t3 % 2 == 0 ? o2 : o2 * s2) * Ne2(t3 * He2 / i2), r2 - (t3 % 2 == 0 ? r2 : r2 * s2) * Ve2(t3 * He2 / i2));
    Xe2(a2);
  }
};
St2([Dn(te2)], je2.prototype, "__", void 0), St2([vn(5)], je2.prototype, "corners", void 0), St2([vn(0.382)], je2.prototype, "innerRadius", void 0), je2 = St2([Qn()], je2);
var { moveTo: Je2, lineTo: qe2, drawPoints: Ge2 } = Cr;
var { rotate: $e2, getAngle: Ke2, getDistance: Qe2, defaultPoint: Ze2 } = ot;
var ti2 = class extends ge2 {
  get __tag() {
    return "Line";
  }
  get toPoint() {
    const { width: t2, rotation: e2 } = this.__, i2 = Y();
    return t2 && (i2.x = t2), e2 && $e2(i2, e2), i2;
  }
  set toPoint(t2) {
    this.width = Qe2(Ze2, t2), this.rotation = Ke2(Ze2, t2), this.height && (this.height = 0);
  }
  __updatePath() {
    const t2 = this.__, e2 = t2.path = [];
    t2.points ? Ge2(e2, t2.points, t2.curve, t2.closed) : (Je2(e2, 0, 0), qe2(e2, this.width, 0));
  }
};
St2([Dn($t2)], ti2.prototype, "__", void 0), St2([kn("center")], ti2.prototype, "strokeAlign", void 0), St2([xn(0)], ti2.prototype, "height", void 0), St2([vn()], ti2.prototype, "points", void 0), St2([vn(0)], ti2.prototype, "curve", void 0), St2([vn(false)], ti2.prototype, "closed", void 0), ti2 = St2([Qn()], ti2);
var ei2 = class extends xe2 {
  get __tag() {
    return "Image";
  }
  get ready() {
    const { image: t2 } = this;
    return t2 && t2.ready;
  }
  get image() {
    const { fill: t2 } = this.__;
    return l(t2) && t2[0].image;
  }
};
St2([Dn(re2)], ei2.prototype, "__", void 0), St2([xn("")], ei2.prototype, "url", void 0), ei2 = St2([Qn()], ei2);
var ii2 = ei2;
var si2 = class extends xe2 {
  get __tag() {
    return "Canvas";
  }
  get context() {
    return this.canvas.context;
  }
  get ready() {
    return !this.url;
  }
  constructor(t2) {
    super(t2), this.canvas = le.canvas(this.__), t2 && t2.url && this.drawImage(t2.url);
  }
  drawImage(t2) {
    new on({ url: t2 }).load((t3) => {
      this.context.drawImage(t3.view, 0, 0), this.url = void 0, this.paint(), this.emitEvent(new Uo(Uo.LOADED, { image: t3 }));
    });
  }
  draw(t2, e2, i2, s2) {
    const o2 = new pt(t2.worldTransform).invert(), r2 = new pt();
    e2 && r2.translate(e2.x, e2.y), i2 && (o(i2) ? r2.scale(i2) : r2.scale(i2.x, i2.y)), s2 && r2.rotate(s2), o2.multiplyParent(r2), t2.__render(this.canvas, { matrix: o2.withScale() }), this.paint();
  }
  paint() {
    this.forceRender();
  }
  __drawContent(t2, e2) {
    const { width: i2, height: s2 } = this.__, { view: o2 } = this.canvas;
    t2.drawImage(o2, 0, 0, o2.width, o2.height, 0, 0, i2, s2);
  }
  __updateSize() {
    const { canvas: t2 } = this;
    if (t2) {
      const { smooth: e2, safeResize: i2 } = this.__;
      t2.resize(this.__, i2), t2.smooth !== e2 && (t2.smooth = e2);
    }
  }
  destroy() {
    this.canvas && (this.canvas.destroy(), this.canvas = null), super.destroy();
  }
};
St2([Dn(ae2)], si2.prototype, "__", void 0), St2([Rt2(100)], si2.prototype, "width", void 0), St2([Rt2(100)], si2.prototype, "height", void 0), St2([Rt2(1)], si2.prototype, "pixelRatio", void 0), St2([Rt2(true)], si2.prototype, "smooth", void 0), St2([_n(false)], si2.prototype, "safeResize", void 0), St2([Rt2()], si2.prototype, "contextSettings", void 0), si2 = St2([Qn()], si2);
var { copyAndSpread: oi2, includes: ri2, spread: ai2, setList: ni2 } = zt;
var { stintSet: _i2 } = _;
var hi2 = class extends ge2 {
  get __tag() {
    return "Text";
  }
  get textDrawData() {
    return this.updateLayout(), this.__.__textDrawData;
  }
  __updateTextDrawData() {
    const t2 = this.__, { lineHeight: e2, letterSpacing: i2, fontFamily: s2, fontSize: o2, fontWeight: r2, italic: a2, textCase: n2, textOverflow: _2, padding: h2, width: d2, height: l2 } = t2;
    t2.__lineHeight = bt2.number(e2, o2), t2.__letterSpacing = bt2.number(i2, o2), t2.__baseLine = t2.__lineHeight - (t2.__lineHeight - 0.7 * o2) / 2, t2.__font = `${a2 ? "italic " : ""}${"small-caps" === n2 ? "small-caps " : ""}${"normal" !== r2 ? r2 + " " : ""}${o2 || 12}px ${s2 || "caption"}`, _i2(t2, "__padding", h2 && I.fourNumber(h2)), _i2(t2, "__clipText", "show" !== _2 && !t2.__autoSize), _i2(t2, "__isCharMode", d2 || l2 || t2.__letterSpacing || "none" !== n2), t2.__textDrawData = At2.getDrawData((t2.__isPlacehold = t2.placeholder && "" === t2.text) ? t2.placeholder : t2.text, this.__);
  }
  __updateBoxBounds() {
    const t2 = this.__, e2 = this.__layout, { fontSize: i2, italic: s2, padding: o2, __autoWidth: r2, __autoHeight: a2 } = t2;
    this.__updateTextDrawData();
    const { bounds: _2 } = t2.__textDrawData, h2 = e2.boxBounds;
    if (e2.contentBounds = _2, t2.__lineHeight < i2 && ai2(_2, i2 / 2), r2 || a2) {
      if (h2.x = r2 ? _2.x : 0, h2.y = a2 ? _2.y : 0, h2.width = r2 ? _2.width : t2.width, h2.height = a2 ? _2.height : t2.height, o2) {
        const [e3, i3, s3, o3] = t2.__padding;
        r2 && (h2.x -= o3, h2.width += i3 + o3), a2 && (h2.y -= e3, h2.height += s3 + e3);
      }
      this.__updateNaturalSize();
    } else super.__updateBoxBounds();
    s2 && (h2.width += 0.16 * i2), _.stintSet(this, "isOverflow", !ri2(h2, _2)), this.isOverflow ? (ni2(t2.__textBoxBounds = {}, [h2, _2]), e2.renderChanged = true) : t2.__textBoxBounds = h2;
  }
  __updateRenderSpread() {
    let t2 = super.__updateRenderSpread();
    return t2 || (t2 = this.isOverflow ? 1 : 0), t2;
  }
  __updateRenderBounds() {
    const { renderBounds: t2, renderSpread: e2 } = this.__layout;
    oi2(t2, this.__.__textBoxBounds, e2), this.__box && (this.__box.__layout.renderBounds = t2);
  }
  __updateChange() {
    super.__updateChange();
    const t2 = this.__box;
    t2 && (t2.__onUpdateSize(), t2.__updateChange());
  }
  __drawRenderPath(t2) {
    t2.font = this.__.__font;
  }
  __draw(t2, e2, i2) {
    const s2 = this.__box;
    s2 && (s2.__nowWorld = this.__nowWorld, s2.__draw(t2, e2, i2)), this.textEditing && !e2.exporting || super.__draw(t2, e2, i2);
  }
  __drawShape(t2, e2) {
    e2.shape && this.__box && this.__box.__drawShape(t2, e2), super.__drawShape(t2, e2);
  }
  destroy() {
    this.boxStyle && (this.boxStyle = null), super.destroy();
  }
};
St2([Dn(oe2)], hi2.prototype, "__", void 0), St2([xn(0)], hi2.prototype, "width", void 0), St2([xn(0)], hi2.prototype, "height", void 0), St2([Pn()], hi2.prototype, "boxStyle", void 0), St2([_n(false)], hi2.prototype, "resizeFontSize", void 0), St2([Pn("#000000")], hi2.prototype, "fill", void 0), St2([kn("outside")], hi2.prototype, "strokeAlign", void 0), St2([Nn("all")], hi2.prototype, "hitFill", void 0), St2([xn("")], hi2.prototype, "text", void 0), St2([xn("")], hi2.prototype, "placeholder", void 0), St2([xn("caption")], hi2.prototype, "fontFamily", void 0), St2([xn(12)], hi2.prototype, "fontSize", void 0), St2([xn("normal")], hi2.prototype, "fontWeight", void 0), St2([xn(false)], hi2.prototype, "italic", void 0), St2([xn("none")], hi2.prototype, "textCase", void 0), St2([xn("none")], hi2.prototype, "textDecoration", void 0), St2([xn(0)], hi2.prototype, "letterSpacing", void 0), St2([xn({ type: "percent", value: 1.5 })], hi2.prototype, "lineHeight", void 0), St2([xn(0)], hi2.prototype, "paraIndent", void 0), St2([xn(0)], hi2.prototype, "paraSpacing", void 0), St2([xn("x")], hi2.prototype, "writingMode", void 0), St2([xn("left")], hi2.prototype, "textAlign", void 0), St2([xn("top")], hi2.prototype, "verticalAlign", void 0), St2([xn(true)], hi2.prototype, "autoSizeAlign", void 0), St2([xn("normal")], hi2.prototype, "textWrap", void 0), St2([xn("show")], hi2.prototype, "textOverflow", void 0), St2([Pn(false)], hi2.prototype, "textEditing", void 0), hi2 = St2([Qn()], hi2);
var di2 = class extends ge2 {
  get __tag() {
    return "Path";
  }
};
St2([Dn(ee2)], di2.prototype, "__", void 0), St2([kn("center")], di2.prototype, "strokeAlign", void 0), di2 = St2([Qn()], di2);
var li2 = class extends ye2 {
  get __tag() {
    return "Pen";
  }
  setStyle(t2) {
    const e2 = this.pathElement = new di2(t2);
    return this.pathStyle = t2, this.__path = e2.path || (e2.path = []), this.add(e2), this;
  }
  beginPath() {
    return this;
  }
  moveTo(t2, e2) {
    return this;
  }
  lineTo(t2, e2) {
    return this;
  }
  bezierCurveTo(t2, e2, i2, s2, o2, r2) {
    return this;
  }
  quadraticCurveTo(t2, e2, i2, s2) {
    return this;
  }
  closePath() {
    return this;
  }
  rect(t2, e2, i2, s2) {
    return this;
  }
  roundRect(t2, e2, i2, s2, o2) {
    return this;
  }
  ellipse(t2, e2, i2, s2, o2, r2, a2, n2) {
    return this;
  }
  arc(t2, e2, i2, s2, o2, r2) {
    return this;
  }
  arcTo(t2, e2, i2, s2, o2) {
    return this;
  }
  drawEllipse(t2, e2, i2, s2, o2, r2, a2, n2) {
    return this;
  }
  drawArc(t2, e2, i2, s2, o2, r2) {
    return this;
  }
  drawPoints(t2, e2, i2) {
    return this;
  }
  clearPath() {
    return this;
  }
  paint() {
    this.pathElement.__layout.boxChanged || this.pathElement.forceUpdate("path");
  }
};
St2([Dn(ie2)], li2.prototype, "__", void 0), St2([(e2, i2) => {
  an(e2, i2, { get() {
    return this.__path;
  } });
}], li2.prototype, "path", void 0), li2 = St2([qn(Fr, ["set", "path", "paint"]), Qn()], li2);

// node_modules/@leafer-ui/core/lib/core.esm.min.js
function I2(t2, e2, i2, s2) {
  var a2, n2 = arguments.length, r2 = n2 < 3 ? e2 : null === s2 ? s2 = Object.getOwnPropertyDescriptor(e2, i2) : s2;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r2 = Reflect.decorate(t2, e2, i2, s2);
  else for (var h2 = t2.length - 1; h2 >= 0; h2--) (a2 = t2[h2]) && (r2 = (n2 < 3 ? a2(r2) : n2 > 3 ? a2(e2, i2, r2) : a2(e2, i2)) || r2);
  return n2 > 3 && r2 && Object.defineProperty(e2, i2, r2), r2;
}
var N2 = class extends we2 {
  get __tag() {
    return "App";
  }
  get isApp() {
    return true;
  }
  constructor(t2, e2) {
    super(t2, e2);
  }
  init(t2, e2) {
    if (super.init(t2, e2), t2) {
      const { ground: e3, tree: i2, sky: s2, editor: a2 } = t2;
      e3 && (this.ground = this.addLeafer(e3)), (i2 || a2) && (this.tree = this.addLeafer(i2 || { type: t2.type || "design" })), (s2 || a2) && (this.sky = this.addLeafer(s2)), a2 && le.editor(a2, this);
    }
  }
  __setApp() {
    const { canvas: t2 } = this, { realCanvas: e2, view: i2 } = this.config;
    e2 || i2 === this.canvas.view || !t2.parentView ? this.realCanvas = true : t2.unrealCanvas(), this.leafer = this, this.watcher.disable(), this.layouter.disable();
  }
  __updateLocalBounds() {
    this.forEach((t2) => t2.updateLayout()), super.__updateLocalBounds();
  }
  start() {
    super.start(), this.forEach((t2) => t2.start());
  }
  stop() {
    this.forEach((t2) => t2.stop()), super.stop();
  }
  unlockLayout() {
    super.unlockLayout(), this.forEach((t2) => t2.unlockLayout());
  }
  lockLayout() {
    super.lockLayout(), this.forEach((t2) => t2.lockLayout());
  }
  forceRender(t2, e2) {
    this.forEach((i2) => i2.forceRender(t2, e2));
  }
  addLeafer(e2) {
    const i2 = new we2(e2);
    return this.add(i2), i2;
  }
  add(t2, e2) {
    if (!t2.view) {
      if (this.realCanvas && !this.canvas.bounds) return void setTimeout(() => this.add(t2, e2), 10);
      t2.init(this.__getChildConfig(t2.userConfig), this);
    }
    super.add(t2, e2), s(e2) || (t2.canvas.childIndex = e2), this.__listenChildEvents(t2);
  }
  forEach(t2) {
    this.children.forEach(t2);
  }
  __onCreated() {
    this.created = this.children.every((t2) => t2.created);
  }
  __onReady() {
    this.children.every((t2) => t2.ready) && super.__onReady();
  }
  __onViewReady() {
    this.children.every((t2) => t2.viewReady) && super.__onViewReady();
  }
  __onChildRenderEnd(t2) {
    this.renderer.addBlock(t2.renderBounds), this.viewReady && this.renderer.update();
  }
  __render(t2, e2) {
    t2.context && this.forEach((i2) => e2.matrix ? i2.__render(t2, e2) : t2.copyWorld(i2.canvas, e2.bounds));
  }
  __onResize(t2) {
    this.forEach((e2) => e2.resize(t2)), super.__onResize(t2);
  }
  updateLayout() {
    this.forEach((t2) => t2.updateLayout());
  }
  __getChildConfig(t2) {
    const e2 = Object.assign({}, this.config);
    return e2.hittable = e2.realCanvas = void 0, t2 && _.assign(e2, t2), this.autoLayout && _.copyAttrs(e2, this, Re), e2.view = this.realCanvas ? void 0 : this.view, e2.fill = void 0, e2;
  }
  __listenChildEvents(t2) {
    t2.once([[$o.END, this.__onReady, this], [Ko.START, this.__onCreated, this], [Ko.END, this.__onViewReady, this]]), this.realCanvas && this.__eventIds.push(t2.on_(Ko.END, this.__onChildRenderEnd, this));
  }
};
N2 = I2([Qn()], N2);
var F2 = {};
var W2 = { isHoldSpaceKey: () => W2.isHold("Space"), isHold: (t2) => F2[t2], isHoldKeys: (t2, e2) => e2 ? t2(e2) : void 0, setDownCode(t2) {
  F2[t2] || (F2[t2] = true);
}, setUpCode(t2) {
  F2[t2] = false;
} };
var K2 = { LEFT: 1, RIGHT: 2, MIDDLE: 4, defaultLeft(t2) {
  t2.buttons || (t2.buttons = 1);
}, left: (t2) => 1 === t2.buttons, right: (t2) => 2 === t2.buttons, middle: (t2) => 4 === t2.buttons };
var V2 = class extends Yo {
  get spaceKey() {
    return W2.isHoldSpaceKey();
  }
  get left() {
    return K2.left(this);
  }
  get right() {
    return K2.right(this);
  }
  get middle() {
    return K2.middle(this);
  }
  constructor(t2) {
    super(t2.type), this.bubbles = true, Object.assign(this, t2);
  }
  isHoldKeys(t2) {
    return W2.isHoldKeys(t2, this);
  }
  getBoxPoint(t2) {
    return (t2 || this.current).getBoxPoint(this);
  }
  getInnerPoint(t2) {
    return (t2 || this.current).getInnerPoint(this);
  }
  getLocalPoint(t2) {
    return (t2 || this.current).getLocalPoint(this);
  }
  getPagePoint() {
    return this.current.getPagePoint(this);
  }
  getInner(t2) {
    return this.getInnerPoint(t2);
  }
  getLocal(t2) {
    return this.getLocalPoint(t2);
  }
  getPage() {
    return this.getPagePoint();
  }
  static changeName(t2, e2) {
    pe.changeName(t2, e2);
  }
};
var { min: U2, max: j2, abs: X2 } = Math;
var { float: Y2, sign: z2 } = I;
var { minX: G2, maxX: Z2, minY: q2, maxY: J2 } = zt;
var Q2 = new Ht();
var $2 = new Ht();
var tt2 = { limitMove(t2, e2) {
  const { dragBounds: i2, dragBoundsType: s2 } = t2;
  i2 && et2.getValidMove(t2.__localBoxBounds, et2.getDragBounds(t2), s2, e2, true), et2.axisMove(t2, e2);
}, limitScaleOf(t2, e2, i2, s2) {
  const { dragBounds: a2, dragBoundsType: n2 } = t2;
  a2 && et2.getValidScaleOf(t2.__localBoxBounds, et2.getDragBounds(t2), n2, t2.getLocalPointByInner(t2.getInnerPointByBox(e2)), i2, s2, true);
}, axisMove(t2, e2) {
  const { draggable: i2 } = t2;
  "x" === i2 && (e2.y = 0), "y" === i2 && (e2.x = 0);
}, getDragBounds(t2) {
  const { dragBounds: e2 } = t2;
  return "parent" === e2 ? t2.parent.boxBounds : e2;
}, isInnerMode: (t2, e2, i2, s2) => "inner" === i2 || "auto" === i2 && t2[s2] > e2[s2], getValidMove(t2, e2, i2, s2, a2) {
  const n2 = t2.x + s2.x, r2 = t2.y + s2.y, h2 = n2 + t2.width, o2 = r2 + t2.height, d2 = e2.x + e2.width, g2 = e2.y + e2.height;
  return a2 || (s2 = Object.assign({}, s2)), et2.isInnerMode(t2, e2, i2, "width") ? n2 > e2.x ? s2.x += e2.x - n2 : h2 < d2 && (s2.x += d2 - h2) : n2 < e2.x ? s2.x += e2.x - n2 : h2 > d2 && (s2.x += d2 - h2), et2.isInnerMode(t2, e2, i2, "height") ? r2 > e2.y ? s2.y += e2.y - r2 : o2 < g2 && (s2.y += g2 - o2) : r2 < e2.y ? s2.y += e2.y - r2 : o2 > g2 && (s2.y += g2 - o2), s2.x = Y2(s2.x), s2.y = Y2(s2.y), s2;
}, getValidScaleOf(t2, e2, i2, s2, a2, n2, r2) {
  r2 || (a2 = Object.assign({}, a2)), $2.set(e2), Q2.set(t2).scaleOf(s2, a2.x, a2.y);
  const h2 = (s2.x - t2.x) / t2.width, o2 = 1 - h2, d2 = (s2.y - t2.y) / t2.height, g2 = 1 - d2;
  let l2, c2, u2, p2, _2 = 1, m2 = 1;
  return et2.isInnerMode(t2, e2, i2, "width") ? (a2.x < 0 && Q2.scaleOf(s2, _2 = 1 / a2.x, 1), u2 = Y2(Q2.minX - $2.minX), p2 = Y2($2.maxX - Q2.maxX), l2 = h2 && u2 > 0 ? 1 + u2 / (h2 * Q2.width) : 1, c2 = o2 && p2 > 0 ? 1 + p2 / (o2 * Q2.width) : 1, _2 *= j2(l2, c2)) : (a2.x < 0 && ((Y2(G2(t2) - G2(e2)) <= 0 || Y2(Z2(e2) - Z2(t2)) <= 0) && Q2.scaleOf(s2, _2 = 1 / a2.x, 1), Q2.unsign()), u2 = Y2($2.minX - Q2.minX), p2 = Y2(Q2.maxX - $2.maxX), l2 = h2 && u2 > 0 ? 1 - u2 / (h2 * Q2.width) : 1, c2 = o2 && p2 > 0 ? 1 - p2 / (o2 * Q2.width) : 1, _2 *= U2(l2, c2)), et2.isInnerMode(t2, e2, i2, "height") ? (a2.y < 0 && Q2.scaleOf(s2, 1, m2 = 1 / a2.y), u2 = Y2(Q2.minY - $2.minY), p2 = Y2($2.maxY - Q2.maxY), l2 = d2 && u2 > 0 ? 1 + u2 / (d2 * Q2.height) : 1, c2 = g2 && p2 > 0 ? 1 + p2 / (g2 * Q2.height) : 1, m2 *= j2(l2, c2), n2 && (l2 = j2(X2(_2), X2(m2)), _2 = z2(_2) * l2, m2 = z2(m2) * l2)) : (a2.y < 0 && ((Y2(q2(t2) - q2(e2)) <= 0 || Y2(J2(e2) - J2(t2)) <= 0) && Q2.scaleOf(s2, 1, m2 = 1 / a2.y), Q2.unsign()), u2 = Y2($2.minY - Q2.minY), p2 = Y2(Q2.maxY - $2.maxY), l2 = d2 && u2 > 0 ? 1 - u2 / (d2 * Q2.height) : 1, c2 = g2 && p2 > 0 ? 1 - p2 / (g2 * Q2.height) : 1, m2 *= U2(l2, c2)), a2.x *= n(_2) ? _2 : 1, a2.y *= n(m2) ? m2 : 1, a2;
} };
var et2 = tt2;
var it2 = class extends V2 {
};
it2.POINTER = "pointer", it2.BEFORE_DOWN = "pointer.before_down", it2.BEFORE_MOVE = "pointer.before_move", it2.BEFORE_UP = "pointer.before_up", it2.DOWN = "pointer.down", it2.MOVE = "pointer.move", it2.UP = "pointer.up", it2.OVER = "pointer.over", it2.OUT = "pointer.out", it2.ENTER = "pointer.enter", it2.LEAVE = "pointer.leave", it2.TAP = "tap", it2.DOUBLE_TAP = "double_tap", it2.CLICK = "click", it2.DOUBLE_CLICK = "double_click", it2.LONG_PRESS = "long_press", it2.LONG_TAP = "long_tap", it2.MENU = "pointer.menu", it2.MENU_TAP = "pointer.menu_tap", it2 = I2([Jn()], it2);
var st2 = it2;
var at2 = {};
var nt2 = class extends it2 {
  static setList(t2) {
    this.list = t2 instanceof Bh ? t2 : new Bh(t2);
  }
  static setData(t2) {
    this.data = t2;
  }
  static getValidMove(t2, e2, i2, s2 = true) {
    const a2 = t2.getLocalPoint(i2, null, true);
    return ot.move(a2, e2.x - t2.x, e2.y - t2.y), s2 && this.limitMove(t2, a2), tt2.axisMove(t2, a2), a2;
  }
  static limitMove(t2, e2) {
    tt2.limitMove(t2, e2);
  }
  getPageMove(t2) {
    return this.assignMove(t2), this.current.getPagePoint(at2, null, true);
  }
  getInnerMove(t2, e2) {
    return t2 || (t2 = this.current), this.assignMove(e2), t2.getInnerPoint(at2, null, true);
  }
  getLocalMove(t2, e2) {
    return t2 || (t2 = this.current), this.assignMove(e2), t2.getLocalPoint(at2, null, true);
  }
  getPageTotal() {
    return this.getPageMove(true);
  }
  getInnerTotal(t2) {
    return this.getInnerMove(t2, true);
  }
  getLocalTotal(t2) {
    return this.getLocalMove(t2, true);
  }
  getPageBounds() {
    const t2 = this.getPageTotal(), e2 = this.getPagePoint(), i2 = {};
    return zt.set(i2, e2.x - t2.x, e2.y - t2.y, t2.x, t2.y), zt.unsign(i2), i2;
  }
  assignMove(t2) {
    at2.x = t2 ? this.totalX : this.moveX, at2.y = t2 ? this.totalY : this.moveY;
  }
};
nt2.BEFORE_DRAG = "drag.before_drag", nt2.START = "drag.start", nt2.DRAG = "drag", nt2.END = "drag.end", nt2.OVER = "drag.over", nt2.OUT = "drag.out", nt2.ENTER = "drag.enter", nt2.LEAVE = "drag.leave", nt2 = I2([Jn()], nt2);
var rt2 = nt2;
var ht2 = class extends it2 {
  static setList(t2) {
    nt2.setList(t2);
  }
  static setData(t2) {
    nt2.setData(t2);
  }
};
ht2.DROP = "drop", ht2 = I2([Jn()], ht2);
var ot2 = class extends nt2 {
};
ot2.BEFORE_MOVE = "move.before_move", ot2.START = "move.start", ot2.MOVE = "move", ot2.DRAG_ANIMATE = "move.drag_animate", ot2.END = "move.end", ot2.PULL_DOWN = "move.pull_down", ot2.REACH_BOTTOM = "move.reach_bottom", ot2 = I2([Jn()], ot2);
var dt2 = class extends V2 {
};
dt2 = I2([Jn()], dt2);
var gt2 = dt2;
var lt2 = class extends it2 {
};
lt2.BEFORE_ROTATE = "rotate.before_rotate", lt2.START = "rotate.start", lt2.ROTATE = "rotate", lt2.END = "rotate.end", lt2 = I2([Jn()], lt2);
var ct2 = class extends nt2 {
};
ct2.SWIPE = "swipe", ct2.LEFT = "swipe.left", ct2.RIGHT = "swipe.right", ct2.UP = "swipe.up", ct2.DOWN = "swipe.down", ct2 = I2([Jn()], ct2);
var ut2 = class extends it2 {
};
ut2.BEFORE_ZOOM = "zoom.before_zoom", ut2.START = "zoom.start", ut2.ZOOM = "zoom", ut2.END = "zoom.end", ut2 = I2([Jn()], ut2);
var pt2 = class extends V2 {
};
pt2.BEFORE_DOWN = "key.before_down", pt2.BEFORE_UP = "key.before_up", pt2.DOWN = "key.down", pt2.HOLD = "key.hold", pt2.UP = "key.up", pt2 = I2([Jn()], pt2);
var _t2 = { getDragEventData: (t2, e2, i2) => Object.assign(Object.assign({}, i2), { x: i2.x, y: i2.y, moveX: i2.x - e2.x, moveY: i2.y - e2.y, totalX: i2.x - t2.x, totalY: i2.y - t2.y }), getDropEventData: (t2, e2, i2) => Object.assign(Object.assign({}, t2), { list: e2, data: i2 }), getSwipeDirection: (t2) => t2 < -45 && t2 > -135 ? ct2.UP : t2 > 45 && t2 < 135 ? ct2.DOWN : t2 <= 45 && t2 >= -45 ? ct2.RIGHT : ct2.LEFT, getSwipeEventData: (t2, e2, i2) => Object.assign(Object.assign({}, i2), { moveX: e2.moveX, moveY: e2.moveY, totalX: i2.x - t2.x, totalY: i2.y - t2.y, type: mt3.getSwipeDirection(ot.getAngle(t2, i2)) }), getBase(t2) {
  const e2 = 1 === t2.button ? 4 : t2.button;
  return { altKey: t2.altKey, ctrlKey: t2.ctrlKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, time: Date.now(), buttons: s(t2.buttons) ? 1 : 0 === t2.buttons ? e2 : t2.buttons, origin: t2 };
}, pathHasEventType(t2, e2) {
  const { list: i2 } = t2;
  for (let t3 = 0, s2 = i2.length; t3 < s2; t3++) if (i2[t3].hasEvent(e2)) return true;
  return false;
}, filterPathByEventType(t2, e2) {
  const i2 = new Bh(), { list: s2 } = t2;
  for (let t3 = 0, a2 = s2.length; t3 < a2; t3++) s2[t3].hasEvent(e2) && i2.add(s2[t3]);
  return i2;
}, pathCanDrag: (t2) => t2 && t2.list.some((t3) => ho.draggable(t3) || !t3.isLeafer && t3.hasEvent(nt2.DRAG)), pathHasOutside: (t2) => t2 && t2.list.some((t3) => t3.isOutside) };
var mt3 = _t2;
var vt2 = new Bh();
var { getDragEventData: ft2, getDropEventData: yt2, getSwipeEventData: Et3 } = _t2;
var Dt3 = class {
  constructor(t2) {
    this.dragDataList = [], this.interaction = t2;
  }
  setDragData(t2) {
    this.animateWait && this.dragEndReal(), this.downData = this.interaction.downData, this.dragData = ft2(t2, t2, t2), this.canAnimate = this.canDragOut = true;
  }
  getList(t2, e2) {
    const { proxy: i2 } = this.interaction.selector, s2 = i2 && i2.list.length, a2 = nt2.list || this.draggableList || vt2;
    return this.dragging && (s2 ? t2 ? vt2 : new Bh(e2 ? [...i2.list, ...i2.dragHoverExclude] : i2.list) : a2);
  }
  checkDrag(t2, e2) {
    const { interaction: i2 } = this;
    if (this.moving && t2.buttons < 1) return this.canAnimate = false, void i2.pointerCancel();
    !this.moving && e2 && (this.moving = i2.canMove(this.downData) || i2.isHoldRightKey || i2.isMobileDragEmpty) && (this.dragData.moveType = "drag", i2.emit(ot2.START, this.dragData)), this.moving || this.dragStart(t2, e2), this.drag(t2);
  }
  dragStart(t2, e2) {
    this.dragging || (this.dragging = e2 && K2.left(t2), this.dragging && (this.interaction.emit(nt2.START, this.dragData), this.getDraggableList(this.dragData.path), this.setDragStartPoints(this.realDraggableList = this.getList(true))));
  }
  setDragStartPoints(t2) {
    this.dragStartPoints = {}, t2.forEach((t3) => this.dragStartPoints[t3.innerId] = { x: t3.x, y: t3.y });
  }
  getDraggableList(t2) {
    let e2;
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) if (e2 = t2.list[i2], ho.draggable(e2)) {
      this.draggableList = new Bh(e2);
      break;
    }
  }
  drag(t2) {
    const { interaction: e2, dragData: i2, downData: s2 } = this, { path: a2, throughPath: n2 } = s2;
    this.dragData = ft2(s2, i2, t2), n2 && (this.dragData.throughPath = n2), this.dragData.path = a2, this.dragDataList.push(this.dragData), this.moving ? (t2.moving = true, this.dragData.moveType = "drag", e2.emit(ot2.BEFORE_MOVE, this.dragData), e2.emit(ot2.MOVE, this.dragData)) : this.dragging && (t2.dragging = true, this.dragReal(), e2.emit(nt2.BEFORE_DRAG, this.dragData), e2.emit(nt2.DRAG, this.dragData));
  }
  dragReal(t2) {
    const { interaction: e2 } = this, { running: i2 } = e2, s2 = this.realDraggableList;
    if (s2.length && i2) {
      const { totalX: i3, totalY: a2 } = this.dragData, { dragLimitAnimate: n2 } = e2.p, r2 = !n2 || !!t2;
      s2.forEach((e3) => {
        if (e3.draggable) {
          const s3 = i(e3.draggable), h2 = nt2.getValidMove(e3, this.dragStartPoints[e3.innerId], { x: i3, y: a2 }, r2 || s3);
          n2 && !s3 && t2 ? ho.animateMove(e3, h2, o(n2) ? n2 : 0.3) : e3.move(h2);
        }
      });
    }
  }
  dragOverOrOut(t2) {
    const { interaction: e2 } = this, { dragOverPath: i2 } = this, { path: s2 } = t2;
    this.dragOverPath = s2, i2 ? s2.indexAt(0) !== i2.indexAt(0) && (e2.emit(nt2.OUT, t2, i2), e2.emit(nt2.OVER, t2, s2)) : e2.emit(nt2.OVER, t2, s2);
  }
  dragEnterOrLeave(t2) {
    const { interaction: e2 } = this, { dragEnterPath: i2 } = this, { path: s2 } = t2;
    e2.emit(nt2.LEAVE, t2, i2, s2), e2.emit(nt2.ENTER, t2, s2, i2), this.dragEnterPath = s2;
  }
  dragEnd(t2) {
    (this.dragging || this.moving) && (this.checkDragEndAnimate(t2) || this.dragEndReal(t2));
  }
  dragEndReal(t2) {
    const { interaction: e2, downData: i2, dragData: s2 } = this;
    t2 || (t2 = s2);
    const { path: a2, throughPath: n2 } = i2, r2 = ft2(i2, t2, t2);
    if (n2 && (r2.throughPath = n2), r2.path = a2, this.moving && (this.moving = false, r2.moveType = "drag", e2.emit(ot2.END, r2)), this.dragging) {
      const a3 = this.getList();
      this.dragging = false, e2.p.dragLimitAnimate && this.dragReal(true), e2.emit(nt2.END, r2), this.swipe(t2, i2, s2, r2), this.drop(t2, a3, this.dragEnterPath);
    }
    this.autoMoveCancel(), this.dragReset(), this.animate(null, "off");
  }
  swipe(t2, e2, i2, s2) {
    const { interaction: a2 } = this;
    if (ot.getDistance(e2, t2) > a2.config.pointer.swipeDistance) {
      const t3 = Et3(e2, i2, s2);
      this.interaction.emit(t3.type, t3);
    }
  }
  drop(t2, e2, i2) {
    const s2 = yt2(t2, e2, nt2.data);
    s2.path = i2, this.interaction.emit(ht2.DROP, s2), this.interaction.emit(nt2.LEAVE, t2, i2);
  }
  dragReset() {
    nt2.list = nt2.data = this.draggableList = this.dragData = this.downData = this.dragOverPath = this.dragEnterPath = null, this.dragDataList = [];
  }
  checkDragEndAnimate(t2, e2) {
    return false;
  }
  animate(t2, e2) {
  }
  stopAnimate() {
  }
  checkDragOut(t2) {
  }
  autoMoveOnDragOut(t2) {
  }
  autoMoveCancel() {
  }
  destroy() {
    this.dragReset();
  }
};
var Pt3 = ee.get("emit");
var xt2 = ["move", "zoom", "rotate", "key"];
function wt2(t2, e2, i2, s2, a2) {
  if (xt2.some((t3) => e2.startsWith(t3)) && t2.__.hitChildren && !Tt3(t2, a2)) {
    let n2;
    for (let r2 = 0, h2 = t2.children.length; r2 < h2; r2++) n2 = t2.children[r2], !i2.path.has(n2) && n2.__.hittable && Ot3(n2, e2, i2, s2, a2);
  }
}
function Ot3(t2, i2, s2, a2, n2) {
  if (t2.destroyed) return false;
  if (t2.__.hitSelf && !Tt3(t2, n2) && (Lt2.updateEventStyle && !a2 && Lt2.updateEventStyle(t2, i2), t2.hasEvent(i2, a2))) {
    s2.phase = a2 ? 1 : t2 === s2.target ? 2 : 3;
    const e2 = pe.get(i2, s2);
    if (t2.emitEvent(e2, a2), e2.isStop) return true;
  }
  return false;
}
function Tt3(t2, e2) {
  return e2 && e2.has(t2);
}
var Lt3 = { wheel: { zoomSpeed: 0.5, moveSpeed: 0.5, rotateSpeed: 0.5, delta: { x: 20, y: 8 } }, pointer: { type: "pointer", snap: true, hitRadius: 5, tapTime: 120, longPressTime: 800, transformTime: 500, hover: true, dragHover: true, dragDistance: 2, swipeDistance: 20 }, touch: { preventDefault: "auto" }, multiTouch: {}, move: { autoDistance: 2 }, zoom: {}, cursor: true, keyEvent: true };
var { pathHasEventType: Rt3, pathCanDrag: Ct3, pathHasOutside: bt3 } = _t2;
var Mt3 = class {
  get dragging() {
    return this.dragger.dragging;
  }
  get transforming() {
    return this.transformer.transforming;
  }
  get moveMode() {
    return true === this.m.drag || this.isHoldSpaceKey || this.isHoldMiddleKey || this.isHoldRightKey && this.dragger.moving || this.isDragEmpty;
  }
  get canHover() {
    return this.p.hover && !this.config.mobile;
  }
  get isDragEmpty() {
    return this.m.dragEmpty && this.isRootPath(this.hoverData) && (!this.downData || this.isRootPath(this.downData));
  }
  get isMobileDragEmpty() {
    return this.m.dragEmpty && !this.canHover && this.downData && this.isTreePath(this.downData);
  }
  get isHoldMiddleKey() {
    return this.m.holdMiddleKey && this.downData && K2.middle(this.downData);
  }
  get isHoldRightKey() {
    return this.m.holdRightKey && this.downData && K2.right(this.downData);
  }
  get isHoldSpaceKey() {
    return this.m.holdSpaceKey && W2.isHoldSpaceKey();
  }
  get m() {
    return this.config.move;
  }
  get p() {
    return this.config.pointer;
  }
  get hitRadius() {
    return this.p.hitRadius;
  }
  constructor(t2, e2, i2, s2) {
    this.config = _.clone(Lt3), this.tapCount = 0, this.downKeyMap = {}, this.target = t2, this.canvas = e2, this.selector = i2, this.defaultPath = new Bh(t2), this.createTransformer(), this.dragger = new Dt3(this), s2 && (this.config = _.default(s2, this.config)), this.__listenEvents();
  }
  start() {
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  receive(t2) {
  }
  pointerDown(t2, e2) {
    t2 || (t2 = this.hoverData), t2 && (K2.defaultLeft(t2), this.updateDownData(t2), this.checkPath(t2, e2), this.downTime = Date.now(), this.emit(it2.BEFORE_DOWN, t2), this.emit(it2.DOWN, t2), K2.left(t2) && (this.tapWait(), this.longPressWait(t2)), this.waitRightTap = K2.right(t2), this.dragger.setDragData(t2), this.isHoldRightKey || this.updateCursor(t2));
  }
  pointerMove(t2) {
    if (t2 || (t2 = this.hoverData), !t2) return;
    const { downData: e2 } = this;
    e2 && K2.defaultLeft(t2);
    (this.canvas.bounds.hitPoint(t2) || e2) && (this.pointerMoveReal(t2), e2 && this.dragger.checkDragOut(t2));
  }
  pointerMoveReal(t2) {
    if (this.emit(it2.BEFORE_MOVE, t2, this.defaultPath), this.downData) {
      const e2 = ot.getDistance(this.downData, t2) > this.p.dragDistance;
      e2 && (this.pointerWaitCancel(), this.waitRightTap = false), this.dragger.checkDrag(t2, e2);
    }
    this.dragger.moving || (this.updateHoverData(t2), this.checkPath(t2), this.emit(it2.MOVE, t2), this.pointerHover(t2), this.dragging && (this.dragger.dragOverOrOut(t2), this.dragger.dragEnterOrLeave(t2))), this.updateCursor(this.downData || t2);
  }
  pointerUp(t2) {
    const { downData: e2 } = this;
    if (t2 || (t2 = e2), !e2) return;
    K2.defaultLeft(t2), t2.multiTouch = e2.multiTouch, this.findPath(t2);
    const i2 = Object.assign(Object.assign({}, t2), { path: t2.path.clone() });
    t2.path.addList(e2.path.list), this.checkPath(t2), this.downData = null, this.emit(it2.BEFORE_UP, t2), this.emit(it2.UP, t2), this.touchLeave(t2), t2.isCancel || (this.tap(t2), this.menuTap(t2)), this.dragger.dragEnd(t2), this.updateCursor(i2);
  }
  pointerCancel() {
    const t2 = Object.assign({}, this.dragger.dragData);
    t2.isCancel = true, this.pointerUp(t2);
  }
  menu(t2) {
    this.findPath(t2), this.emit(it2.MENU, t2), this.waitMenuTap = true, !this.downData && this.waitRightTap && this.menuTap(t2);
  }
  menuTap(t2) {
    this.waitRightTap && this.waitMenuTap && (this.emit(it2.MENU_TAP, t2), this.waitRightTap = this.waitMenuTap = false);
  }
  createTransformer() {
  }
  move(t2) {
  }
  zoom(t2) {
  }
  rotate(t2) {
  }
  transformEnd() {
  }
  wheel(t2) {
  }
  multiTouch(t2, e2) {
  }
  keyDown(t2) {
    if (!this.config.keyEvent) return;
    this.emit(pt2.BEFORE_DOWN, t2, this.defaultPath);
    const { code: e2 } = t2;
    this.downKeyMap[e2] || (this.downKeyMap[e2] = true, W2.setDownCode(e2), this.emit(pt2.HOLD, t2, this.defaultPath), this.moveMode && (this.cancelHover(), this.updateCursor())), this.emit(pt2.DOWN, t2, this.defaultPath);
  }
  keyUp(t2) {
    if (!this.config.keyEvent) return;
    this.emit(pt2.BEFORE_UP, t2, this.defaultPath);
    const { code: e2 } = t2;
    this.downKeyMap[e2] = false, W2.setUpCode(e2), this.emit(pt2.UP, t2, this.defaultPath), "grab" === this.cursor && this.updateCursor();
  }
  pointerHover(t2) {
    !this.canHover || this.dragging && !this.p.dragHover || (t2.path || (t2.path = new Bh()), this.pointerOverOrOut(t2), this.pointerEnterOrLeave(t2));
  }
  pointerOverOrOut(t2) {
    const { path: e2 } = t2, { overPath: i2 } = this;
    this.overPath = e2, i2 ? e2.indexAt(0) !== i2.indexAt(0) && (this.emit(it2.OUT, t2, i2), this.emit(it2.OVER, t2, e2)) : this.emit(it2.OVER, t2, e2);
  }
  pointerEnterOrLeave(t2) {
    let { path: e2 } = t2;
    this.downData && !this.moveMode && (e2 = e2.clone(), this.downData.path.forEach((t3) => e2.add(t3)));
    const { enterPath: i2 } = this;
    this.enterPath = e2, this.emit(it2.LEAVE, t2, i2, e2), this.emit(it2.ENTER, t2, e2, i2);
  }
  touchLeave(t2) {
    "touch" === t2.pointerType && this.enterPath && (this.emit(it2.LEAVE, t2), this.dragger.dragging && this.emit(ht2.LEAVE, t2));
  }
  tap(t2) {
    const { pointer: e2 } = this.config, i2 = this.longTap(t2);
    if (!e2.tapMore && i2) return;
    if (!this.waitTap) return;
    e2.tapMore && this.emitTap(t2);
    const s2 = Date.now() - this.downTime, a2 = [it2.DOUBLE_TAP, it2.DOUBLE_CLICK].some((e3) => Rt3(t2.path, e3));
    s2 < e2.tapTime + 50 && a2 ? (this.tapCount++, 2 === this.tapCount ? (this.tapWaitCancel(), this.emitDoubleTap(t2)) : (clearTimeout(this.tapTimer), this.tapTimer = setTimeout(() => {
      e2.tapMore || (this.tapWaitCancel(), this.emitTap(t2));
    }, e2.tapTime))) : e2.tapMore || (this.tapWaitCancel(), this.emitTap(t2));
  }
  findPath(t2, e2) {
    const { hitRadius: i2, through: s2 } = this.p, { bottomList: a2, target: n2 } = this;
    $t.backgrounder || t2.origin || n2 && n2.updateLayout();
    const r2 = this.selector.getByPoint(t2, i2, Object.assign({ bottomList: a2, name: t2.type }, e2 || { through: s2 }));
    return r2.throughPath && (t2.throughPath = r2.throughPath), t2.path = r2.path, r2.path;
  }
  isRootPath(t2) {
    return t2 && t2.path.list[0].isLeafer;
  }
  isTreePath(t2) {
    const e2 = this.target.app;
    return !(!e2 || !e2.isApp) && (e2.editor && !t2.path.has(e2.editor) && t2.path.has(e2.tree) && !t2.target.syncEventer);
  }
  checkPath(t2, e2) {
    (e2 || this.moveMode && !bt3(t2.path)) && (t2.path = this.defaultPath);
  }
  canMove(t2) {
    return t2 && (this.moveMode || "auto" === this.m.drag && !Ct3(t2.path)) && !bt3(t2.path);
  }
  isDrag(t2) {
    return this.dragger.getList().has(t2);
  }
  isPress(t2) {
    return this.downData && this.downData.path.has(t2);
  }
  isHover(t2) {
    return this.enterPath && this.enterPath.has(t2);
  }
  isFocus(t2) {
    return this.focusData === t2;
  }
  cancelHover() {
    const { hoverData: t2 } = this;
    t2 && (t2.path = this.defaultPath, this.pointerHover(t2));
  }
  stopDragAnimate() {
    this.dragger.stopAnimate();
  }
  updateDownData(t2, e2, i2) {
    const { downData: s2 } = this;
    !t2 && s2 && (t2 = s2), t2 && (this.findPath(t2, e2), i2 && s2 && t2.path.addList(s2.path.list), this.downData = t2);
  }
  updateHoverData(t2) {
    t2 || (t2 = this.hoverData), t2 && (this.findPath(t2, { exclude: this.dragger.getList(false, true), name: it2.MOVE }), this.hoverData = t2);
  }
  updateCursor(t2) {
    if (!this.config.cursor || !this.canHover) return;
    if (t2 || (this.updateHoverData(), t2 = this.downData || this.hoverData), this.dragger.moving) return this.setCursor("grabbing");
    if (this.canMove(t2)) return this.setCursor(this.downData ? "grabbing" : "grab");
    if (!t2) return;
    let e2, i2;
    const { path: s2 } = t2;
    for (let t3 = 0, a2 = s2.length; t3 < a2 && (e2 = s2.list[t3], i2 = e2.syncEventer && e2.syncEventer.cursor || e2.cursor, !i2); t3++) ;
    this.setCursor(i2);
  }
  setCursor(t2) {
    this.cursor = t2;
  }
  getLocal(t2, e2) {
    const i2 = this.canvas.getClientBounds(e2), s2 = { x: t2.clientX - i2.x, y: t2.clientY - i2.y }, { bounds: a2 } = this.canvas;
    return s2.x *= a2.width / i2.width, s2.y *= a2.height / i2.height, this.p.snap && ot.round(s2), s2;
  }
  emitTap(t2) {
    this.emit(it2.TAP, t2), this.emit(it2.CLICK, t2);
  }
  emitDoubleTap(t2) {
    this.emit(it2.DOUBLE_TAP, t2), this.emit(it2.DOUBLE_CLICK, t2);
  }
  pointerWaitCancel() {
    this.tapWaitCancel(), this.longPressWaitCancel();
  }
  tapWait() {
    clearTimeout(this.tapTimer), this.waitTap = true;
  }
  tapWaitCancel() {
    this.waitTap && (clearTimeout(this.tapTimer), this.waitTap = false, this.tapCount = 0);
  }
  longPressWait(t2) {
    clearTimeout(this.longPressTimer), this.longPressTimer = setTimeout(() => {
      this.longPressed = true, this.emit(it2.LONG_PRESS, t2);
    }, this.p.longPressTime);
  }
  longTap(t2) {
    let e2;
    return this.longPressed && (this.emit(it2.LONG_TAP, t2), (Rt3(t2.path, it2.LONG_TAP) || Rt3(t2.path, it2.LONG_PRESS)) && (e2 = true)), this.longPressWaitCancel(), e2;
  }
  longPressWaitCancel() {
    this.longPressTimer && (clearTimeout(this.longPressTimer), this.longPressed = false);
  }
  __onResize() {
    const { dragOut: t2 } = this.m;
    this.shrinkCanvasBounds = new Ht(this.canvas.bounds), this.shrinkCanvasBounds.spread(-(o(t2) ? t2 : 2));
  }
  __listenEvents() {
    const { target: t2 } = this;
    this.__eventIds = [t2.on_(Jo.RESIZE, this.__onResize, this)], t2.once(ta.READY, () => this.__onResize());
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds), this.__eventIds.length = 0;
  }
  emit(t2, e2, i2, s2) {
    this.running && (function(t3, e3, i3, s3) {
      if (!i3 && !e3.path) return;
      let a2;
      e3.type = t3, i3 ? e3 = Object.assign(Object.assign({}, e3), { path: i3 }) : i3 = e3.path, e3.target = i3.indexAt(0);
      try {
        for (let n2 = i3.length - 1; n2 > -1; n2--) {
          if (a2 = i3.list[n2], Ot3(a2, t3, e3, true, s3)) return;
          a2.isApp && wt2(a2, t3, e3, true, s3);
        }
        for (let n2 = 0, r2 = i3.length; n2 < r2; n2++) if (a2 = i3.list[n2], a2.isApp && wt2(a2, t3, e3, false, s3), Ot3(a2, t3, e3, false, s3)) return;
      } catch (t4) {
        Pt3.error(t4);
      }
    })(t2, e2, i2, s2);
  }
  destroy() {
    this.__eventIds.length && (this.stop(), this.__removeListenEvents(), this.dragger.destroy(), this.transformer && this.transformer.destroy(), this.downData = this.overPath = this.enterPath = null);
  }
};
var St3 = class {
  static set(t2, e2) {
    this.custom[t2] = e2;
  }
  static get(t2) {
    return this.custom[t2];
  }
};
St3.custom = {};
var At3 = class extends ge {
  constructor() {
    super(...arguments), this.maxTotal = 1e3, this.pathList = new Bh(), this.pixelList = new Bh();
  }
  getPixelType(t2, e2) {
    return this.__autoClear(), this.pixelList.add(t2), le.hitCanvas(e2);
  }
  getPathType(t2) {
    return this.__autoClear(), this.pathList.add(t2), le.hitCanvas();
  }
  clearImageType() {
    this.__clearLeafList(this.pixelList);
  }
  clearPathType() {
    this.__clearLeafList(this.pathList);
  }
  __clearLeafList(t2) {
    t2.length && (t2.forEach((t3) => {
      t3.__hitCanvas && (t3.__hitCanvas.destroy(), t3.__hitCanvas = null);
    }), t2.reset());
  }
  __autoClear() {
    this.pathList.length + this.pixelList.length > this.maxTotal && this.clear();
  }
  clear() {
    this.clearPathType(), this.clearImageType();
  }
};
$t.getSelector = function(t2) {
  return t2.leafer ? t2.leafer.selector : $t.selector || ($t.selector = le.selector());
};
var { toInnerRadiusPointOf: Bt3, copyRadiusPoint: kt3 } = ot;
var { hitRadiusPoint: Ht3, hitPoint: It3 } = zt;
var Nt3 = {};
var Ft3 = {};
var Wt3 = ch.prototype;
Wt3.hit = function(t2, e2 = 0) {
  this.updateLayout(), kt3(Ft3, t2, e2);
  const i2 = this.__world;
  return !!(e2 ? Ht3(i2, Ft3) : It3(i2, Ft3)) && (this.isBranch ? $t.getSelector(this).hitPoint(Object.assign({}, Ft3), e2, { target: this }) : this.__hitWorld(Ft3));
}, Wt3.__hitWorld = function(t2, e2) {
  const i2 = this.__;
  if (!i2.hitSelf) return false;
  const s2 = this.__world, a2 = this.__layout, n2 = s2.width < 10 && s2.height < 10;
  if (i2.hitRadius && (kt3(Nt3, t2, i2.hitRadius), t2 = Nt3), Bt3(t2, s2, Nt3), i2.hitBox || n2) {
    if (zt.hitRadiusPoint(a2.boxBounds, Nt3)) return true;
    if (n2) return false;
  }
  return !a2.hitCanvasChanged && this.__hitCanvas || (this.__updateHitCanvas(), a2.boundsChanged || (a2.hitCanvasChanged = false)), this.__hit(Nt3, e2);
}, Wt3.__hitFill = function(t2) {
  const e2 = this.__hitCanvas;
  return e2 && e2.hitFill(t2, this.__.windingRule);
}, Wt3.__hitStroke = function(t2, e2) {
  const i2 = this.__hitCanvas;
  return i2 && i2.hitStroke(t2, e2);
}, Wt3.__hitPixel = function(t2) {
  const e2 = this.__hitCanvas;
  return e2 && e2.hitPixel(t2, this.__layout.renderBounds, e2.hitScale);
}, Wt3.__drawHitPath = function(t2) {
  t2 && this.__drawRenderPath(t2);
};
var Kt3 = new pt();
var Vt3 = ge2.prototype;
Vt3.__updateHitCanvas = function() {
  this.__box && this.__box.__updateHitCanvas();
  const { hitCanvasManager: t2 } = this.leafer || this.parent && this.parent.leafer || {};
  if (!t2) return;
  const e2 = this.__, i2 = (e2.__isAlphaPixelFill || e2.__isCanvas) && "pixel" === e2.hitFill, s2 = e2.__isAlphaPixelStroke && "pixel" === e2.hitStroke, a2 = i2 || s2;
  this.__hitCanvas || (this.__hitCanvas = a2 ? t2.getPixelType(this, { contextSettings: { willReadFrequently: true } }) : t2.getPathType(this));
  const n2 = this.__hitCanvas;
  if (a2) {
    const { renderBounds: t3 } = this.__layout, a3 = $t.image.hitCanvasSize, r2 = n2.hitScale = Vt.set(0, 0, a3, a3).getFitMatrix(t3).a, { x: h2, y: o2, width: d2, height: g2 } = Vt.set(t3).scale(r2);
    n2.resize({ width: d2, height: g2, pixelRatio: 1 }), n2.clear(), en.patternLocked = true, this.__renderShape(n2, { matrix: Kt3.setWith(this.__world).scaleWith(1 / r2).invertWith().translate(-h2, -o2), snapshot: true, ignoreFill: !i2, ignoreStroke: !s2 }), en.patternLocked = false, n2.resetTransform(), e2.__isHitPixel = true;
  } else e2.__isHitPixel && (e2.__isHitPixel = false);
  this.__drawHitPath(n2), n2.setStrokeOptions(e2);
}, Vt3.__hit = function(t2, e2) {
  if (this.__box && this.__box.__hit(t2)) return true;
  const i2 = this.__;
  if (i2.__isHitPixel && this.__hitPixel(t2)) return true;
  const { hitFill: s2 } = i2, a2 = (i2.fill || i2.__isCanvas) && ("path" === s2 || "pixel" === s2 && !(i2.__isAlphaPixelFill || i2.__isCanvas)) || "all" === s2 || e2;
  if (a2 && this.__hitFill(t2)) return true;
  const { hitStroke: n2, __maxStrokeWidth: r2 } = i2, h2 = i2.stroke && ("path" === n2 || "pixel" === n2 && !i2.__isAlphaPixelStroke) || "all" === n2;
  if (!a2 && !h2) return false;
  const o2 = 2 * t2.radiusX;
  let d2 = o2;
  if (h2) switch (i2.strokeAlign) {
    case "inside":
      if (d2 += 2 * r2, !a2 && this.__hitFill(t2) && this.__hitStroke(t2, d2)) return true;
      d2 = o2;
      break;
    case "center":
      d2 += r2;
      break;
    case "outside":
      if (d2 += 2 * r2, !a2) {
        if (!this.__hitFill(t2) && this.__hitStroke(t2, d2)) return true;
        d2 = o2;
      }
  }
  return !!d2 && this.__hitStroke(t2, d2);
};
var Ut3 = ge2.prototype;
var jt3 = xe2.prototype;
var Xt3 = Ae2.prototype;
jt3.__updateHitCanvas = Xt3.__updateHitCanvas = function() {
  this.stroke || this.cornerRadius || (this.fill || this.__.__isCanvas) && "pixel" === this.hitFill || "all" === this.hitStroke ? Ut3.__updateHitCanvas.call(this) : this.__hitCanvas && (this.__hitCanvas = null);
}, jt3.__hitFill = Xt3.__hitFill = function(t2) {
  return this.__hitCanvas ? Ut3.__hitFill.call(this, t2) : zt.hitRadiusPoint(this.__layout.boxBounds, t2);
}, hi2.prototype.__drawHitPath = function(t2) {
  const { __lineHeight: e2, fontSize: i2, __baseLine: s2, __letterSpacing: a2, __textDrawData: n2 } = this.__;
  t2.beginPath(), a2 < 0 ? this.__drawPathByBox(t2) : n2.rows.forEach((a3) => t2.rect(a3.x, a3.y - s2, a3.width, e2 < i2 ? i2 : e2));
}, ye2.prototype.pick = function(t2, e2) {
  return e2 || (e2 = e), this.updateLayout(), $t.getSelector(this).getByPoint(t2, e2.hitRadius || 0, Object.assign(Object.assign({}, e2), { target: this }));
};
var Yt3 = Ee.prototype;
Yt3.hitFill = function(t2, e2) {
  return e2 ? this.context.isPointInPath(t2.x, t2.y, e2) : this.context.isPointInPath(t2.x, t2.y);
}, Yt3.hitStroke = function(t2, e2) {
  return this.strokeWidth = e2, this.context.isPointInStroke(t2.x, t2.y);
}, Yt3.hitPixel = function(t2, e2, i2 = 1) {
  let { x: s2, y: a2, radiusX: n2, radiusY: r2 } = t2;
  e2 && (s2 -= e2.x, a2 -= e2.y), Vt.set(s2 - n2, a2 - r2, 2 * n2, 2 * r2).scale(i2).ceil();
  const { data: h2 } = this.context.getImageData(Vt.x, Vt.y, Vt.width || 1, Vt.height || 1);
  for (let t3 = 0, e3 = h2.length; t3 < e3; t3 += 4) if (h2[t3 + 3] > 0) return true;
  return h2[3] > 0;
};

// node_modules/leafer-ui/dist/web.esm.min.js
var Z3;
!(function(t2) {
  t2[t2.none = 1] = "none", t2[t2.free = 2] = "free", t2[t2.mirrorAngle = 3] = "mirrorAngle", t2[t2.mirror = 4] = "mirror";
})(Z3 || (Z3 = {}));
var J3 = ee.get("LeaferCanvas");
var tt3 = class extends Ee {
  set zIndex(t2) {
    const { style: e2 } = this.view;
    e2.zIndex = t2, this.setAbsolute(this.view);
  }
  set childIndex(t2) {
    const { view: e2, parentView: i2 } = this;
    if (e2 && i2) {
      const s2 = i2.children[t2];
      s2 ? (this.setAbsolute(s2), i2.insertBefore(e2, s2)) : i2.appendChild(s2);
    }
  }
  init() {
    const { config: t2 } = this, e2 = t2.view || t2.canvas;
    e2 ? this.__createViewFrom(e2) : this.__createView();
    const { style: s2 } = this.view;
    if (s2.display || (s2.display = "block"), this.parentView = this.view.parentElement, this.parentView) {
      const t3 = this.parentView.style;
      t3.webkitUserSelect = t3.userSelect = "none", this.view.classList.add("leafer-canvas-view");
    }
    $t.syncDomFont && !this.parentView && (s2.display = "none", document.body && document.body.appendChild(this.view)), this.__createContext(), this.autoLayout || this.resize(t2);
  }
  set backgroundColor(t2) {
    this.view.style.backgroundColor = t2;
  }
  get backgroundColor() {
    return this.view.style.backgroundColor;
  }
  set hittable(t2) {
    this.view.style.pointerEvents = t2 ? "auto" : "none";
  }
  get hittable() {
    return "none" !== this.view.style.pointerEvents;
  }
  __createView() {
    this.view = document.createElement("canvas");
  }
  __createViewFrom(t2) {
    let e2 = i(t2) ? document.getElementById(t2) : t2;
    if (e2) if (e2 instanceof HTMLCanvasElement) this.view = e2;
    else {
      let t3 = e2;
      if (e2 === window || e2 === document) {
        const e3 = document.createElement("div"), { style: i3 } = e3;
        i3.position = "absolute", i3.top = i3.bottom = i3.left = i3.right = "0px", document.body.appendChild(e3), t3 = e3;
      }
      this.__createView();
      const i2 = this.view;
      t3.hasChildNodes() && (this.setAbsolute(i2), t3.style.position || (t3.style.position = "relative")), t3.appendChild(i2);
    }
    else J3.error(`no id: ${t2}`), this.__createView();
  }
  setAbsolute(t2) {
    const { style: e2 } = t2;
    e2.position = "absolute", e2.top = e2.left = "0px";
  }
  updateViewSize() {
    const { width: t2, height: e2, pixelRatio: i2 } = this, { style: s2 } = this.view;
    s2.width = t2 + "px", s2.height = e2 + "px", this.unreal || (this.view.width = Math.ceil(t2 * i2), this.view.height = Math.ceil(e2 * i2));
  }
  updateClientBounds() {
    this.view.parentElement && (this.clientBounds = this.view.getBoundingClientRect());
  }
  startAutoLayout(t2, e2) {
    if (this.resizeListener = e2, t2) {
      if (this.autoBounds = t2, this.resizeObserver) return;
      try {
        this.resizeObserver = new ResizeObserver((t4) => {
          this.updateClientBounds();
          for (const e3 of t4) this.checkAutoBounds(e3.contentRect);
        });
        const t3 = this.parentView;
        t3 ? (this.resizeObserver.observe(t3), this.checkAutoBounds(t3.getBoundingClientRect())) : (this.checkAutoBounds(this.view), J3.warn("no parent"));
      } catch (t3) {
        this.imitateResizeObserver();
      }
      this.stopListenPixelRatio();
    } else this.listenPixelRatio(), this.unreal && this.updateViewSize();
  }
  imitateResizeObserver() {
    this.autoLayout && (this.parentView && this.checkAutoBounds(this.parentView.getBoundingClientRect()), $t.requestRender(this.imitateResizeObserver.bind(this)));
  }
  listenPixelRatio() {
    this.windowListener || window.addEventListener("resize", this.windowListener = () => {
      const t2 = $t.devicePixelRatio;
      if (!this.config.pixelRatio && this.pixelRatio !== t2) {
        const { width: e2, height: i2 } = this;
        this.emitResize({ width: e2, height: i2, pixelRatio: t2 });
      }
    });
  }
  stopListenPixelRatio() {
    this.windowListener && (window.removeEventListener("resize", this.windowListener), this.windowListener = null);
  }
  checkAutoBounds(t2) {
    const e2 = this.view, { x: s2, y: n2, width: o2, height: r2 } = this.autoBounds.getBoundsFrom(t2), a2 = { width: o2, height: r2, pixelRatio: this.config.pixelRatio ? this.pixelRatio : $t.devicePixelRatio };
    if (!this.isSameSize(a2)) {
      const { style: t3 } = e2;
      t3.marginLeft = s2 + "px", t3.marginTop = n2 + "px", this.emitResize(a2);
    }
  }
  stopAutoLayout() {
    this.autoLayout = false, this.resizeObserver && this.resizeObserver.disconnect(), this.resizeListener = this.resizeObserver = null;
  }
  emitResize(t2) {
    const e2 = {};
    _.copyAttrs(e2, this, Re), this.resize(t2), this.resizeListener && !s(this.width) && this.resizeListener(new Jo(t2, e2));
  }
  unrealCanvas() {
    if (!this.unreal && this.parentView) {
      let t2 = this.view;
      t2 && t2.remove(), t2 = this.view = document.createElement("div"), this.parentView.appendChild(this.view), t2.classList.add("leafer-app-view"), this.unreal = true;
    }
  }
  destroy() {
    const { view: t2 } = this;
    t2 && (this.stopAutoLayout(), this.stopListenPixelRatio(), t2.parentElement && t2.remove(), super.destroy());
  }
};
Vi(CanvasRenderingContext2D.prototype), Vi(Path2D.prototype);
var { mineType: et3, fileType: it3 } = Gi;
function st3(t2, e2) {
  $t.origin = { createCanvas(t3, e3) {
    const i2 = document.createElement("canvas");
    return i2.width = t3, i2.height = e3, i2;
  }, canvasToDataURL: (t3, e3, i2) => {
    const s2 = et3(e3), n2 = t3.toDataURL(s2, i2);
    return "image/bmp" === s2 ? n2.replace("image/png;", "image/bmp;") : n2;
  }, canvasToBolb: (t3, e3, i2) => new Promise((s2) => t3.toBlob(s2, et3(e3), i2)), canvasSaveAs: (t3, e3, s2) => {
    const n2 = t3.toDataURL(et3(it3(e3)), s2);
    return $t.origin.download(n2, e3);
  }, download: (t3, e3) => new Promise((i2) => {
    let s2 = document.createElement("a");
    s2.href = t3, s2.download = e3, document.body.appendChild(s2), s2.click(), document.body.removeChild(s2), i2();
  }), loadImage: (t3) => new Promise((e3, s2) => {
    const n2 = new $t.origin.Image(), { crossOrigin: o2 } = $t.image;
    o2 && (n2.setAttribute("crossOrigin", o2), n2.crossOrigin = o2), n2.onload = () => {
      e3(n2);
    }, n2.onerror = (t4) => {
      s2(t4);
    }, n2.src = $t.image.getRealURL(t3);
  }), Image, PointerEvent, DragEvent }, $t.event = { stopDefault(t3) {
    t3.preventDefault();
  }, stopNow(t3) {
    t3.stopImmediatePropagation();
  }, stop(t3) {
    t3.stopPropagation();
  } }, $t.canvas = le.canvas(), $t.conicGradientSupport = !!$t.canvas.context.createConicGradient;
}
Object.assign(le, { canvas: (t2, e2) => new tt3(t2, e2), image: (t2) => new on(t2) }), $t.name = "web", $t.isMobile = "ontouchstart" in window, $t.requestRender = function(t2) {
  window.requestAnimationFrame(t2);
}, an($t, "devicePixelRatio", { get: () => devicePixelRatio });
var { userAgent: nt3 } = navigator;
nt3.indexOf("Firefox") > -1 ? ($t.conicGradientRotate90 = true, $t.intWheelDeltaY = true, $t.syncDomFont = true) : (/iPhone|iPad|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && /Version\/[\d.]+.*Safari/.test(navigator.userAgent)) && ($t.fullImageShadow = true), nt3.indexOf("Windows") > -1 ? ($t.os = "Windows", $t.intWheelDeltaY = true) : nt3.indexOf("Mac") > -1 ? $t.os = "Mac" : nt3.indexOf("Linux") > -1 && ($t.os = "Linux");
var ot3 = class {
  get childrenChanged() {
    return this.hasAdd || this.hasRemove || this.hasVisible;
  }
  get updatedList() {
    if (this.hasRemove && this.config.usePartLayout) {
      const t2 = new Bh();
      return this.__updatedList.list.forEach((e2) => {
        e2.leafer && t2.add(e2);
      }), t2;
    }
    return this.__updatedList;
  }
  constructor(t2, e2) {
    this.totalTimes = 0, this.config = {}, this.__updatedList = new Bh(), this.target = t2, e2 && (this.config = _.default(e2, this.config)), this.__listenEvents();
  }
  start() {
    this.disabled || (this.running = true);
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop(), this.__removeListenEvents(), this.disabled = true;
  }
  update() {
    this.changed = true, this.running && this.target.emit(Ko.REQUEST);
  }
  __onAttrChange(t2) {
    this.config.usePartLayout && this.__updatedList.add(t2.target), this.update();
  }
  __onChildEvent(t2) {
    this.config.usePartLayout && (t2.type === Do.ADD ? (this.hasAdd = true, this.__pushChild(t2.child)) : (this.hasRemove = true, this.__updatedList.add(t2.parent))), this.update();
  }
  __pushChild(t2) {
    this.__updatedList.add(t2), t2.isBranch && this.__loopChildren(t2);
  }
  __loopChildren(t2) {
    const { children: e2 } = t2;
    for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) this.__pushChild(e2[t3]);
  }
  __onRquestData() {
    this.target.emitEvent(new Zo(Zo.DATA, { updatedList: this.updatedList })), this.__updatedList = new Bh(), this.totalTimes++, this.changed = this.hasVisible = this.hasRemove = this.hasAdd = false;
  }
  __listenEvents() {
    this.__eventIds = [this.target.on_([[zo.CHANGE, this.__onAttrChange, this], [[Do.ADD, Do.REMOVE], this.__onChildEvent, this], [Zo.REQUEST, this.__onRquestData, this]])];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    this.target && (this.stop(), this.__removeListenEvents(), this.target = this.__updatedList = null);
  }
};
var { updateAllMatrix: rt3, updateBounds: at3, updateChange: ht3 } = ho;
var { pushAllChildBranch: lt3, pushAllParent: ct3 } = bo;
var { worldBounds: dt3 } = yo;
var ut3 = class {
  constructor(t2) {
    this.updatedBounds = new Ht(), this.beforeBounds = new Ht(), this.afterBounds = new Ht(), l(t2) && (t2 = new Bh(t2)), this.updatedList = t2;
  }
  setBefore() {
    this.beforeBounds.setListWithFn(this.updatedList.list, dt3);
  }
  setAfter() {
    this.afterBounds.setListWithFn(this.updatedList.list, dt3), this.updatedBounds.setList([this.beforeBounds, this.afterBounds]);
  }
  merge(t2) {
    this.updatedList.addList(t2.updatedList.list), this.beforeBounds.add(t2.beforeBounds), this.afterBounds.add(t2.afterBounds), this.updatedBounds.add(t2.updatedBounds);
  }
  destroy() {
    this.updatedList = null;
  }
};
var { updateAllMatrix: ft3, updateAllChange: pt3 } = ho;
var gt3 = ee.get("Layouter");
var _t3 = class __t {
  constructor(t2, e2) {
    this.totalTimes = 0, this.config = { usePartLayout: true }, this.__levelList = new vh(), this.target = t2, e2 && (this.config = _.default(e2, this.config)), this.__listenEvents();
  }
  start() {
    this.disabled || (this.running = true);
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop(), this.__removeListenEvents(), this.disabled = true;
  }
  layout() {
    if (this.layouting || !this.running) return;
    const { target: t2 } = this;
    this.times = 0;
    try {
      t2.emit($o.START), this.layoutOnce(), t2.emitEvent(new $o($o.END, this.layoutedBlocks, this.times));
    } catch (t3) {
      gt3.error(t3);
    }
    this.layoutedBlocks = null;
  }
  layoutAgain() {
    this.layouting ? this.waitAgain = true : this.layoutOnce();
  }
  layoutOnce() {
    return this.layouting ? gt3.warn("layouting") : this.times > 3 ? gt3.warn("layout max times") : (this.times++, this.totalTimes++, this.layouting = true, this.target.emit(Zo.REQUEST), this.totalTimes > 1 && this.config.usePartLayout ? this.partLayout() : this.fullLayout(), this.layouting = false, void (this.waitAgain && (this.waitAgain = false, this.layoutOnce())));
  }
  partLayout() {
    var t2;
    if (!(null === (t2 = this.__updatedList) || void 0 === t2 ? void 0 : t2.length)) return;
    const e2 = ne.start("PartLayout"), { target: i2, __updatedList: s2 } = this, { BEFORE: n2, LAYOUT: o2, AFTER: r2 } = $o, a2 = this.getBlocks(s2);
    a2.forEach((t3) => t3.setBefore()), i2.emitEvent(new $o(n2, a2, this.times)), this.extraBlock = null, s2.sort(), (function(t3, e3) {
      let i3;
      t3.list.forEach((t4) => {
        i3 = t4.__layout, e3.without(t4) && !i3.proxyZoom && (i3.matrixChanged ? (rt3(t4, true), e3.add(t4), t4.isBranch && lt3(t4, e3), ct3(t4, e3)) : i3.boundsChanged && (e3.add(t4), t4.isBranch && (t4.__tempNumber = 0), ct3(t4, e3)));
      });
    })(s2, this.__levelList), (function(t3) {
      let e3, i3, s3;
      t3.sort(true), t3.levels.forEach((n3) => {
        e3 = t3.levelMap[n3];
        for (let t4 = 0, n4 = e3.length; t4 < n4; t4++) {
          if (i3 = e3[t4], i3.isBranch && i3.__tempNumber) {
            s3 = i3.children;
            for (let t5 = 0, e4 = s3.length; t5 < e4; t5++) s3[t5].isBranch || at3(s3[t5]);
          }
          at3(i3);
        }
      });
    })(this.__levelList), (function(t3) {
      t3.list.forEach(ht3);
    })(s2), this.extraBlock && a2.push(this.extraBlock), a2.forEach((t3) => t3.setAfter()), i2.emitEvent(new $o(o2, a2, this.times)), i2.emitEvent(new $o(r2, a2, this.times)), this.addBlocks(a2), this.__levelList.reset(), this.__updatedList = null, ne.end(e2);
  }
  fullLayout() {
    const t2 = ne.start("FullLayout"), { target: e2 } = this, { BEFORE: i2, LAYOUT: s2, AFTER: n2 } = $o, o2 = this.getBlocks(new Bh(e2));
    e2.emitEvent(new $o(i2, o2, this.times)), __t.fullLayout(e2), o2.forEach((t3) => {
      t3.setAfter();
    }), e2.emitEvent(new $o(s2, o2, this.times)), e2.emitEvent(new $o(n2, o2, this.times)), this.addBlocks(o2), ne.end(t2);
  }
  static fullLayout(t2) {
    ft3(t2, true), t2.isBranch ? bo.updateBounds(t2) : ho.updateBounds(t2), pt3(t2);
  }
  addExtra(t2) {
    if (!this.__updatedList.has(t2)) {
      const { updatedList: e2, beforeBounds: i2 } = this.extraBlock || (this.extraBlock = new ut3([]));
      e2.length ? i2.add(t2.__world) : i2.set(t2.__world), e2.add(t2);
    }
  }
  createBlock(t2) {
    return new ut3(t2);
  }
  getBlocks(t2) {
    return [this.createBlock(t2)];
  }
  addBlocks(t2) {
    this.layoutedBlocks ? this.layoutedBlocks.push(...t2) : this.layoutedBlocks = t2;
  }
  __onReceiveWatchData(t2) {
    this.__updatedList = t2.data.updatedList;
  }
  __listenEvents() {
    this.__eventIds = [this.target.on_([[$o.REQUEST, this.layout, this], [$o.AGAIN, this.layoutAgain, this], [Zo.DATA, this.__onReceiveWatchData, this]])];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    this.target && (this.stop(), this.__removeListenEvents(), this.target = this.config = null);
  }
};
var wt3 = ee.get("Renderer");
var mt4 = class _mt {
  get needFill() {
    return !(this.canvas.allowBackgroundColor || !this.config.fill);
  }
  constructor(t2, e2, i2) {
    this.FPS = 60, this.totalTimes = 0, this.times = 0, this.config = { usePartRender: true, ceilPartPixel: true, maxFPS: 120 }, this.frames = [], this.target = t2, this.canvas = e2, i2 && (this.config = _.default(i2, this.config)), this.__listenEvents();
  }
  start() {
    this.running = true, this.update(false);
  }
  stop() {
    this.running = false;
  }
  update(t2 = true) {
    this.changed || (this.changed = t2), this.requestTime || this.__requestRender();
  }
  requestLayout() {
    this.target.emit($o.REQUEST);
  }
  checkRender() {
    if (this.running) {
      const { target: t2 } = this;
      t2.isApp && (t2.emit(Ko.CHILD_START, t2), t2.children.forEach((t3) => {
        t3.renderer.FPS = this.FPS, t3.renderer.checkRender();
      }), t2.emit(Ko.CHILD_END, t2)), this.changed && this.canvas.view && this.render(), this.target.emit(Ko.NEXT);
    }
  }
  render(t2) {
    if (!this.running || !this.canvas.view) return this.update();
    const { target: e2 } = this;
    this.times = 0, this.totalBounds = new Ht(), wt3.log(e2.innerName, "--->");
    try {
      this.emitRender(Ko.START), this.renderOnce(t2), this.emitRender(Ko.END, this.totalBounds), en.clearRecycled();
    } catch (t3) {
      this.rendering = false, wt3.error(t3);
    }
    wt3.log("-------------|");
  }
  renderAgain() {
    this.rendering ? this.waitAgain = true : this.renderOnce();
  }
  renderOnce(t2) {
    if (this.rendering) return wt3.warn("rendering");
    if (this.times > 3) return wt3.warn("render max times");
    if (this.times++, this.totalTimes++, this.rendering = true, this.changed = false, this.renderBounds = new Ht(), this.renderOptions = {}, t2) this.emitRender(Ko.BEFORE), t2();
    else {
      if (this.requestLayout(), this.ignore) return void (this.ignore = this.rendering = false);
      this.emitRender(Ko.BEFORE), this.config.usePartRender && this.totalTimes > 1 ? this.partRender() : this.fullRender();
    }
    this.emitRender(Ko.RENDER, this.renderBounds, this.renderOptions), this.emitRender(Ko.AFTER, this.renderBounds, this.renderOptions), this.updateBlocks = null, this.rendering = false, this.waitAgain && (this.waitAgain = false, this.renderOnce());
  }
  partRender() {
    const { canvas: t2, updateBlocks: e2 } = this;
    e2 && (this.mergeBlocks(), e2.forEach((e3) => {
      t2.bounds.hit(e3) && !e3.isEmpty() && this.clipRender(e3);
    }));
  }
  clipRender(t2) {
    const e2 = ne.start("PartRender"), { canvas: i2 } = this, s2 = t2.getIntersect(i2.bounds), n2 = new Ht(s2);
    i2.save(), s2.spread(_mt.clipSpread).ceil();
    const { ceilPartPixel: o2 } = this.config;
    i2.clipWorld(s2, o2), i2.clearWorld(s2, o2), this.__render(s2, n2), i2.restore(), ne.end(e2);
  }
  fullRender() {
    const t2 = ne.start("FullRender"), { canvas: e2 } = this;
    e2.save(), e2.clear(), this.__render(e2.bounds), e2.restore(), ne.end(t2);
  }
  __render(e2, s2) {
    const { canvas: n2, target: o2 } = this, r2 = e2.includes(o2.__world), a2 = r2 ? { includes: r2 } : { bounds: e2, includes: r2 };
    this.needFill && n2.fillWorld(e2, this.config.fill), ee.showRepaint && ee.drawRepaint(n2, e2), this.config.useCellRender && (a2.cellList = this.getCellList()), $t.render(o2, n2, a2), this.renderBounds = s2 = s2 || e2, this.renderOptions = a2, this.totalBounds.isEmpty() ? this.totalBounds = s2 : this.totalBounds.add(s2), n2.updateRender(s2);
  }
  getCellList() {
  }
  addBlock(t2) {
    this.updateBlocks || (this.updateBlocks = []), this.updateBlocks.push(t2);
  }
  mergeBlocks() {
    const { updateBlocks: t2 } = this;
    if (t2) {
      const e2 = new Ht();
      e2.setList(t2), t2.length = 0, t2.push(e2);
    }
  }
  __requestRender() {
    const t2 = this.target;
    if (this.requestTime || !t2) return;
    if (t2.parentApp) return t2.parentApp.requestRender(false);
    this.requestTime = this.frameTime || Date.now();
    const e2 = () => {
      const t3 = 1e3 / ((this.frameTime = Date.now()) - this.requestTime), { maxFPS: s2 } = this.config;
      if (s2 && t3 > s2) return $t.requestRender(e2);
      const { frames: n2 } = this;
      n2.length > 30 && n2.shift(), n2.push(t3), this.FPS = Math.round(n2.reduce((t4, e3) => t4 + e3, 0) / n2.length), this.requestTime = 0, this.checkRender();
    };
    $t.requestRender(e2);
  }
  __onResize(t2) {
    if (!this.canvas.unreal) {
      if (t2.bigger || !t2.samePixelRatio) {
        const { width: e2, height: i2 } = t2.old;
        if (!new Ht(0, 0, e2, i2).includes(this.target.__world) || this.needFill || !t2.samePixelRatio) return this.addBlock(this.canvas.bounds), void this.target.forceUpdate("surface");
      }
      this.addBlock(new Ht(0, 0, 1, 1)), this.update();
    }
  }
  __onLayoutEnd(t2) {
    t2.data && t2.data.map((t3) => {
      let e2;
      t3.updatedList && t3.updatedList.list.some((t4) => (e2 = !t4.__world.width || !t4.__world.height, e2 && (t4.isLeafer || wt3.tip(t4.innerName, ": empty"), e2 = !t4.isBranch || t4.isBranchLeaf), e2)), this.addBlock(e2 ? this.canvas.bounds : t3.updatedBounds);
    });
  }
  emitRender(t2, e2, i2) {
    this.target.emitEvent(new Ko(t2, this.times, e2, i2));
  }
  __listenEvents() {
    this.__eventIds = [this.target.on_([[Ko.REQUEST, this.update, this], [$o.END, this.__onLayoutEnd, this], [Ko.AGAIN, this.renderAgain, this], [Jo.RESIZE, this.__onResize, this]])];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    this.target && (this.stop(), this.__removeListenEvents(), this.config = {}, this.target = this.canvas = null);
  }
};
mt4.clipSpread = 10;
var vt3 = {};
var { copyRadiusPoint: yt3 } = ot;
var { hitRadiusPoint: xt3 } = zt;
var bt4 = class {
  constructor(t2, e2) {
    this.target = t2, this.selector = e2;
  }
  getByPoint(t2, e2, i2) {
    e2 || (e2 = 0), i2 || (i2 = {});
    const s2 = i2.through || false, n2 = i2.ignoreHittable || false, o2 = i2.target || this.target;
    this.exclude = i2.exclude || null, this.point = { x: t2.x, y: t2.y, radiusX: e2, radiusY: e2 }, this.findList = new Bh(i2.findList), i2.findList || this.hitBranch(o2.isBranchLeaf ? { children: [o2] } : o2);
    const { list: r2 } = this.findList, a2 = this.getBestMatchLeaf(r2, i2.bottomList, n2, !!i2.findList), h2 = n2 ? this.getPath(a2) : this.getHitablePath(a2);
    return this.clear(), s2 ? { path: h2, target: a2, throughPath: r2.length ? this.getThroughPath(r2) : h2 } : { path: h2, target: a2 };
  }
  hitPoint(t2, e2, i2) {
    return !!this.getByPoint(t2, e2, i2).target;
  }
  getBestMatchLeaf(t2, e2, i2, s2) {
    const n2 = this.findList = new Bh();
    if (t2.length) {
      let e3;
      const { x: s3, y: o2 } = this.point, r2 = { x: s3, y: o2, radiusX: 0, radiusY: 0 };
      for (let s4 = 0, o3 = t2.length; s4 < o3; s4++) if (e3 = t2[s4], (i2 || ho.worldHittable(e3)) && (this.hitChild(e3, r2), n2.length)) {
        if (e3.isBranchLeaf && t2.some((t3) => t3 !== e3 && ho.hasParent(t3, e3))) {
          n2.reset();
          break;
        }
        return n2.list[0];
      }
    }
    if (e2) {
      for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) if (this.hitChild(e2[t3].target, this.point, e2[t3].proxy), n2.length) return n2.list[0];
    }
    return s2 ? null : i2 ? t2[0] : t2.find((t3) => ho.worldHittable(t3));
  }
  getPath(t2) {
    const e2 = new Bh(), i2 = [], { target: s2 } = this;
    for (; t2 && (t2.syncEventer && i2.push(t2.syncEventer), e2.add(t2), (t2 = t2.parent) !== s2); ) ;
    return i2.length && i2.forEach((t3) => {
      for (; t3 && (t3.__.hittable && e2.add(t3), (t3 = t3.parent) !== s2); ) ;
    }), s2 && e2.add(s2), e2;
  }
  getHitablePath(t2) {
    const e2 = this.getPath(t2 && t2.hittable ? t2 : null);
    let i2, s2 = new Bh();
    for (let t3 = e2.list.length - 1; t3 > -1 && (i2 = e2.list[t3], i2.__.hittable) && (s2.addAt(i2, 0), i2.__.hitChildren && (!i2.isLeafer || "draw" !== i2.mode)); t3--) ;
    return s2;
  }
  getThroughPath(t2) {
    const e2 = new Bh(), i2 = [];
    for (let e3 = t2.length - 1; e3 > -1; e3--) i2.push(this.getPath(t2[e3]));
    let s2, n2, o2;
    for (let t3 = 0, r2 = i2.length; t3 < r2; t3++) {
      s2 = i2[t3], n2 = i2[t3 + 1];
      for (let t4 = 0, i3 = s2.length; t4 < i3 && (o2 = s2.list[t4], !n2 || !n2.has(o2)); t4++) e2.add(o2);
    }
    return e2;
  }
  hitBranch(t2) {
    this.eachFind(t2.children, t2.__onlyHitMask);
  }
  eachFind(t2, e2) {
    let i2, s2, n2;
    const { point: o2 } = this;
    for (let r2 = t2.length - 1; r2 > -1; r2--) if (i2 = t2[r2], n2 = i2.__, n2.visible && (!e2 || n2.mask)) if (s2 = xt3(i2.__world, n2.hitRadius ? yt3(vt3, o2, n2.hitRadius) : o2), i2.isBranch) {
      if (s2 || i2.__ignoreHitWorld) {
        if (i2.isBranchLeaf && n2.__clipAfterFill && !i2.__hitWorld(o2, true)) continue;
        i2.topChildren && this.eachFind(i2.topChildren, false), this.eachFind(i2.children, i2.__onlyHitMask), i2.isBranchLeaf && this.hitChild(i2, o2);
      }
    } else s2 && this.hitChild(i2, o2);
  }
  hitChild(t2, e2, i2) {
    if ((!this.exclude || !this.exclude.has(t2)) && t2.__hitWorld(e2)) {
      const { parent: s2 } = t2;
      if (s2 && s2.__hasMask && !t2.__.mask) {
        let i3, n2 = [];
        const { children: o2 } = s2;
        for (let s3 = 0, r2 = o2.length; s3 < r2; s3++) if (i3 = o2[s3], i3.__.mask && n2.push(i3), i3 === t2) {
          if (n2 && !n2.every((t3) => t3.__hitWorld(e2))) return;
          break;
        }
      }
      this.findList.add(i2 || t2);
    }
  }
  clear() {
    this.point = null, this.findList = null, this.exclude = null;
  }
  destroy() {
    this.clear();
  }
};
var St4 = class {
  constructor(t2, e2) {
    this.config = {}, e2 && (this.config = _.default(e2, this.config)), this.picker = new bt4(this.target = t2, this), this.finder = le.finder && le.finder();
  }
  getByPoint(t2, e2, s2) {
    const { target: n2, picker: o2 } = this;
    return $t.backgrounder && n2 && n2.updateLayout(), o2.getByPoint(t2, e2, s2);
  }
  hitPoint(t2, e2, i2) {
    return this.picker.hitPoint(t2, e2, i2);
  }
  getBy(t2, e2, i2, s2) {
    return this.finder ? this.finder.getBy(t2, e2, i2, s2) : he.need("find");
  }
  destroy() {
    this.picker.destroy(), this.finder && this.finder.destroy();
  }
};
Object.assign(le, { watcher: (t2, e2) => new ot3(t2, e2), layouter: (t2, e2) => new _t3(t2, e2), renderer: (t2, e2, i2) => new mt4(t2, e2, i2), selector: (t2, e2) => new St4(t2, e2) }), $t.layout = _t3.fullLayout, $t.render = function(t2, e2, i2) {
  const s2 = Object.assign(Object.assign({}, i2), { topRendering: true });
  i2.topList = new Bh(), t2.__render(e2, i2), i2.topList.length && i2.topList.forEach((t3) => t3.__render(e2, s2));
};
var Lt4 = { convert(t2, e2) {
  const i2 = _t2.getBase(t2), { x: s2, y: n2 } = e2, o2 = Object.assign(Object.assign({}, i2), { x: s2, y: n2, width: t2.width, height: t2.height, pointerType: t2.pointerType, pressure: t2.pressure });
  return "pen" === o2.pointerType && (o2.tangentialPressure = t2.tangentialPressure, o2.tiltX = t2.tiltX, o2.tiltY = t2.tiltY, o2.twist = t2.twist), o2;
}, convertMouse(t2, e2) {
  const i2 = _t2.getBase(t2), { x: s2, y: n2 } = e2;
  return Object.assign(Object.assign({}, i2), { x: s2, y: n2, width: 1, height: 1, pointerType: "mouse", pressure: 0.5 });
}, convertTouch(t2, e2) {
  const i2 = Lt4.getTouch(t2), s2 = _t2.getBase(t2), { x: n2, y: o2 } = e2;
  return Object.assign(Object.assign({}, s2), { x: n2, y: o2, width: 1, height: 1, pointerType: "touch", multiTouch: t2.touches.length > 1, pressure: i2.force });
}, getTouch: (t2) => t2.targetTouches[0] || t2.changedTouches[0] };
var kt4 = { convert(t2) {
  const e2 = _t2.getBase(t2);
  return Object.assign(Object.assign({}, e2), { code: t2.code, key: t2.key });
} };
var { pathCanDrag: Bt4 } = _t2;
var Tt4 = class extends Mt3 {
  get notPointer() {
    const { p: t2 } = this;
    return "pointer" !== t2.type || t2.touch || this.useMultiTouch;
  }
  get notTouch() {
    const { p: t2 } = this;
    return "mouse" === t2.type || this.usePointer;
  }
  get notMouse() {
    return this.usePointer || this.useTouch;
  }
  __listenEvents() {
    super.__listenEvents();
    const t2 = this.view = this.canvas.view;
    this.viewEvents = { pointerdown: this.onPointerDown, mousedown: this.onMouseDown, touchstart: this.onTouchStart, pointerleave: this.onPointerLeave, contextmenu: this.onContextMenu, wheel: this.onWheel, gesturestart: this.onGesturestart, gesturechange: this.onGesturechange, gestureend: this.onGestureend }, this.windowEvents = { pointermove: this.onPointerMove, pointerup: this.onPointerUp, pointercancel: this.onPointerCancel, mousemove: this.onMouseMove, mouseup: this.onMouseUp, touchmove: this.onTouchMove, touchend: this.onTouchEnd, touchcancel: this.onTouchCancel, keydown: this.onKeyDown, keyup: this.onKeyUp, scroll: this.onScroll };
    const { viewEvents: e2, windowEvents: i2 } = this;
    for (let i3 in e2) e2[i3] = e2[i3].bind(this), t2.addEventListener(i3, e2[i3]);
    for (let t3 in i2) i2[t3] = i2[t3].bind(this), window.addEventListener(t3, i2[t3]);
  }
  __removeListenEvents() {
    super.__removeListenEvents();
    const { viewEvents: t2, windowEvents: e2 } = this;
    for (let e3 in t2) this.view.removeEventListener(e3, t2[e3]), this.viewEvents = {};
    for (let t3 in e2) window.removeEventListener(t3, e2[t3]), this.windowEvents = {};
  }
  getTouches(t2) {
    const e2 = [];
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) e2.push(t2[i2]);
    return e2;
  }
  preventDefaultPointer(t2) {
    const { pointer: e2 } = this.config;
    e2.preventDefault && t2.preventDefault();
  }
  preventDefaultWheel(t2) {
    const { wheel: e2 } = this.config;
    e2.preventDefault && t2.preventDefault();
  }
  preventWindowPointer(t2) {
    return !this.downData && t2.target !== this.view;
  }
  onKeyDown(t2) {
    this.keyDown(kt4.convert(t2));
  }
  onKeyUp(t2) {
    this.keyUp(kt4.convert(t2));
  }
  onContextMenu(t2) {
    this.config.pointer.preventDefaultMenu && t2.preventDefault(), this.menu(Lt4.convert(t2, this.getLocal(t2)));
  }
  onScroll() {
    this.canvas.updateClientBounds();
  }
  onPointerDown(t2) {
    this.preventDefaultPointer(t2), this.notPointer || (this.usePointer || (this.usePointer = true), this.pointerDown(Lt4.convert(t2, this.getLocal(t2))));
  }
  onPointerMove(t2, e2) {
    if (this.notPointer || this.preventWindowPointer(t2)) return;
    this.usePointer || (this.usePointer = true);
    const i2 = Lt4.convert(t2, this.getLocal(t2, true));
    e2 ? this.pointerHover(i2) : this.pointerMove(i2);
  }
  onPointerLeave(t2) {
    this.onPointerMove(t2, true);
  }
  onPointerUp(t2) {
    this.downData && this.preventDefaultPointer(t2), this.notPointer || this.preventWindowPointer(t2) || this.pointerUp(Lt4.convert(t2, this.getLocal(t2)));
  }
  onPointerCancel() {
    this.useMultiTouch || this.pointerCancel();
  }
  onMouseDown(t2) {
    this.preventDefaultPointer(t2), this.notMouse || this.pointerDown(Lt4.convertMouse(t2, this.getLocal(t2)));
  }
  onMouseMove(t2) {
    this.notMouse || this.preventWindowPointer(t2) || this.pointerMove(Lt4.convertMouse(t2, this.getLocal(t2, true)));
  }
  onMouseUp(t2) {
    this.downData && this.preventDefaultPointer(t2), this.notMouse || this.preventWindowPointer(t2) || this.pointerUp(Lt4.convertMouse(t2, this.getLocal(t2)));
  }
  onMouseCancel() {
    this.notMouse || this.pointerCancel();
  }
  onTouchStart(t2) {
    const e2 = Lt4.getTouch(t2), i2 = this.getLocal(e2, true), { preventDefault: s2 } = this.config.touch;
    (true === s2 || "auto" === s2 && Bt4(this.findPath(i2))) && t2.preventDefault(), this.multiTouchStart(t2), this.notTouch || (this.touchTimer && (window.clearTimeout(this.touchTimer), this.touchTimer = 0), this.useTouch = true, this.pointerDown(Lt4.convertTouch(t2, i2)));
  }
  onTouchMove(t2) {
    if (this.multiTouchMove(t2), this.notTouch || this.preventWindowPointer(t2)) return;
    const e2 = Lt4.getTouch(t2);
    this.pointerMove(Lt4.convertTouch(t2, this.getLocal(e2)));
  }
  onTouchEnd(t2) {
    if (this.multiTouchEnd(), this.notTouch || this.preventWindowPointer(t2)) return;
    this.touchTimer && clearTimeout(this.touchTimer), this.touchTimer = setTimeout(() => {
      this.useTouch = false;
    }, 500);
    const e2 = Lt4.getTouch(t2);
    this.pointerUp(Lt4.convertTouch(t2, this.getLocal(e2)));
  }
  onTouchCancel() {
    this.notTouch || this.pointerCancel();
  }
  multiTouchStart(t2) {
    this.useMultiTouch = t2.touches.length > 1, this.touches = this.useMultiTouch ? this.getTouches(t2.touches) : void 0, this.useMultiTouch && this.pointerCancel();
  }
  multiTouchMove(t2) {
    if (this.useMultiTouch && t2.touches.length > 1) {
      const e2 = this.getTouches(t2.touches), i2 = this.getKeepTouchList(this.touches, e2);
      i2.length > 1 && (this.multiTouch(_t2.getBase(t2), i2), this.touches = e2);
    }
  }
  multiTouchEnd() {
    this.touches = null, this.useMultiTouch = false, this.transformEnd();
  }
  getKeepTouchList(t2, e2) {
    let i2;
    const s2 = [];
    return t2.forEach((t3) => {
      i2 = e2.find((e3) => e3.identifier === t3.identifier), i2 && s2.push({ from: this.getLocal(t3), to: this.getLocal(i2) });
    }), s2;
  }
  getLocalTouchs(t2) {
    return t2.map((t3) => this.getLocal(t3));
  }
  onWheel(t2) {
    this.preventDefaultWheel(t2), this.wheel(Object.assign(Object.assign(Object.assign({}, _t2.getBase(t2)), this.getLocal(t2)), { deltaX: t2.deltaX, deltaY: t2.deltaY }));
  }
  onGesturestart(t2) {
    this.useMultiTouch || (this.preventDefaultWheel(t2), this.lastGestureScale = 1, this.lastGestureRotation = 0);
  }
  onGesturechange(t2) {
    if (this.useMultiTouch) return;
    this.preventDefaultWheel(t2);
    const e2 = _t2.getBase(t2);
    Object.assign(e2, this.getLocal(t2));
    const i2 = t2.scale / this.lastGestureScale, s2 = (t2.rotation - this.lastGestureRotation) / Math.PI * 180 * (I.within(this.config.wheel.rotateSpeed, 0, 1) / 4 + 0.1);
    this.zoom(Object.assign(Object.assign({}, e2), { scale: i2 * i2 })), this.rotate(Object.assign(Object.assign({}, e2), { rotation: s2 })), this.lastGestureScale = t2.scale, this.lastGestureRotation = t2.rotation;
  }
  onGestureend(t2) {
    this.useMultiTouch || (this.preventDefaultWheel(t2), this.transformEnd());
  }
  setCursor(t2) {
    super.setCursor(t2);
    const e2 = [];
    this.eachCursor(t2, e2), d(e2[e2.length - 1]) && e2.push("default"), this.canvas.view.style.cursor = e2.map((t3) => d(t3) ? `url(${t3.url}) ${t3.x || 0} ${t3.y || 0}` : t3).join(",");
  }
  eachCursor(t2, e2, i2 = 0) {
    if (i2++, l(t2)) t2.forEach((t3) => this.eachCursor(t3, e2, i2));
    else {
      const n2 = i(t2) && St3.get(t2);
      n2 && i2 < 2 ? this.eachCursor(n2, e2, i2) : e2.push(t2);
    }
  }
  destroy() {
    this.view && (super.destroy(), this.view = null, this.touches = null);
  }
};
function Et4(t2, e2, i2) {
  t2.__.__font ? Ft2.fillText(t2, e2, i2) : t2.__.windingRule ? e2.fill(t2.__.windingRule) : e2.fill();
}
function Pt4(t2, e2, i2, s2, n2) {
  const o2 = i2.__;
  d(t2) ? Ft2.drawStrokesStyle(t2, e2, false, i2, s2, n2) : (s2.setStroke(t2, o2.__strokeWidth * e2, o2), s2.stroke()), o2.__useArrow && Ft2.strokeArrow(t2, i2, s2, n2);
}
function Rt4(t2, e2, i2, s2, n2) {
  const o2 = i2.__;
  d(t2) ? Ft2.drawStrokesStyle(t2, e2, true, i2, s2, n2) : (s2.setStroke(t2, o2.__strokeWidth * e2, o2), Ft2.drawTextStroke(i2, s2, n2));
}
function Mt4(t2, e2, i2, s2, n2) {
  const o2 = s2.getSameCanvas(true, true);
  o2.font = i2.__.__font, Rt4(t2, 2, i2, o2, n2), o2.blendMode = "outside" === e2 ? "destination-out" : "destination-in", Ft2.fillText(i2, o2, n2), o2.blendMode = "normal", ho.copyCanvasByWorld(i2, s2, o2), o2.recycle(i2.__nowWorld);
}
var { getSpread: Ct4, copyAndSpread: At4, toOuterOf: Ot4, getOuterOf: Dt4, getByMove: Wt4, move: It4, getIntersectData: Ft4 } = zt;
var zt3 = {};
var jt4;
var { stintSet: Ut4 } = _;
var { hasTransparent: Gt3 } = Ct2;
function Yt4(t2, e2, i2) {
  if (!d(e2) || false === e2.visible || 0 === e2.opacity) return;
  let n2;
  const { boxBounds: o2 } = i2.__layout;
  switch (e2.type) {
    case "image":
      if (!e2.url) return;
      n2 = Wt2.image(i2, t2, e2, o2, !jt4 || !jt4[e2.url]);
      break;
    case "linear":
      n2 = Et2.linearGradient(e2, o2);
      break;
    case "radial":
      n2 = Et2.radialGradient(e2, o2);
      break;
    case "angular":
      n2 = Et2.conicGradient(e2, o2);
      break;
    case "solid":
      const { type: s2, color: a2, opacity: h2 } = e2;
      n2 = { type: s2, style: Ct2.string(a2, h2) };
      break;
    default:
      s(e2.r) || (n2 = { type: "solid", style: Ct2.string(e2) });
  }
  if (n2 && (n2.originPaint = e2, i(n2.style) && Gt3(n2.style) && (n2.isTransparent = true), e2.style)) {
    if (0 === e2.style.strokeWidth) return;
    n2.strokeStyle = e2.style;
  }
  return n2;
}
var Xt4 = { compute: function(t2, e2) {
  const i2 = e2.__, s2 = [];
  let n2, o2, r2, a2 = i2.__input[t2];
  l(a2) || (a2 = [a2]), jt4 = Wt2.recycleImage(t2, i2);
  for (let i3, n3 = 0, o3 = a2.length; n3 < o3; n3++) (i3 = Yt4(t2, a2[n3], e2)) && (s2.push(i3), i3.strokeStyle && (r2 || (r2 = 1), i3.strokeStyle.strokeWidth && (r2 = Math.max(r2, i3.strokeStyle.strokeWidth))));
  i2["_" + t2] = s2.length ? s2 : void 0, s2.length ? (s2.every((t3) => t3.isTransparent) && (s2.some((t3) => t3.image) && (n2 = true), o2 = true), "fill" === t2 ? (Ut4(i2, "__isAlphaPixelFill", n2), Ut4(i2, "__isTransparentFill", o2)) : (Ut4(i2, "__isAlphaPixelStroke", n2), Ut4(i2, "__isTransparentStroke", o2), Ut4(i2, "__hasMultiStrokeStyle", r2))) : i2.__removePaint(t2, false);
}, fill: function(t2, e2, i2, s2) {
  i2.fillStyle = t2, Et4(e2, i2, s2);
}, fills: function(t2, e2, i2, s2) {
  let n2, o2, r2;
  for (let a2 = 0, h2 = t2.length; a2 < h2; a2++) {
    if (n2 = t2[a2], o2 = n2.originPaint, n2.image) {
      if (r2 ? r2++ : r2 = 1, Wt2.checkImage(n2, !e2.__.__font, e2, i2, s2)) continue;
      if (!n2.style) {
        1 === r2 && n2.image.isPlacehold && e2.drawImagePlaceholder(n2, i2, s2);
        continue;
      }
    }
    if (i2.fillStyle = n2.style, n2.transform || o2.scaleFixed) {
      if (i2.save(), n2.transform && i2.transform(n2.transform), o2.scaleFixed) {
        const { scaleX: t3, scaleY: s3 } = e2.getRenderScaleData(true);
        (true === o2.scaleFixed || "zoom-in" === o2.scaleFixed && t3 > 1 && s3 > 1) && i2.scale(1 / t3, 1 / s3);
      }
      o2.blendMode && (i2.blendMode = o2.blendMode), Et4(e2, i2, s2), i2.restore();
    } else o2.blendMode ? (i2.saveBlendMode(o2.blendMode), Et4(e2, i2, s2), i2.restoreBlendMode()) : Et4(e2, i2, s2);
  }
}, fillPathOrText: Et4, fillText: function(t2, e2, i2) {
  const s2 = t2.__, { rows: n2, decorationY: o2 } = s2.__textDrawData;
  let r2;
  s2.__isPlacehold && s2.placeholderColor && (e2.fillStyle = s2.placeholderColor);
  for (let t3 = 0, i3 = n2.length; t3 < i3; t3++) r2 = n2[t3], r2.text ? e2.fillText(r2.text, r2.x, r2.y) : r2.data && r2.data.forEach((t4) => {
    e2.fillText(t4.char, t4.x, r2.y);
  });
  if (o2) {
    const { decorationColor: t3, decorationHeight: i3 } = s2.__textDrawData;
    t3 && (e2.fillStyle = t3), n2.forEach((t4) => o2.forEach((s3) => e2.fillRect(t4.x, t4.y + s3, t4.width, i3)));
  }
}, stroke: function(t2, e2, i2, s2) {
  const n2 = e2.__;
  if (n2.__strokeWidth) if (n2.__font) Ft2.strokeText(t2, e2, i2, s2);
  else switch (n2.strokeAlign) {
    case "center":
      Pt4(t2, 1, e2, i2, s2);
      break;
    case "inside":
      !(function(t3, e3, i3, s3) {
        i3.save(), i3.clipUI(e3), Pt4(t3, 2, e3, i3, s3), i3.restore();
      })(t2, e2, i2, s2);
      break;
    case "outside":
      !(function(t3, e3, i3, s3) {
        const n3 = e3.__;
        if (n3.__fillAfterStroke) Pt4(t3, 2, e3, i3, s3);
        else {
          const { renderBounds: o2 } = e3.__layout, r2 = i3.getSameCanvas(true, true);
          e3.__drawRenderPath(r2), Pt4(t3, 2, e3, r2, s3), r2.clipUI(n3), r2.clearWorld(o2), ho.copyCanvasByWorld(e3, i3, r2), r2.recycle(e3.__nowWorld);
        }
      })(t2, e2, i2, s2);
  }
}, strokes: function(t2, e2, i2, s2) {
  Ft2.stroke(t2, e2, i2, s2);
}, strokeText: function(t2, e2, i2, s2) {
  switch (e2.__.strokeAlign) {
    case "center":
      Rt4(t2, 1, e2, i2, s2);
      break;
    case "inside":
      Mt4(t2, "inside", e2, i2, s2);
      break;
    case "outside":
      e2.__.__fillAfterStroke ? Rt4(t2, 2, e2, i2, s2) : Mt4(t2, "outside", e2, i2, s2);
  }
}, drawTextStroke: function(t2, e2, i2) {
  let s2, n2 = t2.__.__textDrawData;
  const { rows: o2, decorationY: r2 } = n2;
  for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) s2 = o2[t3], s2.text ? e2.strokeText(s2.text, s2.x, s2.y) : s2.data && s2.data.forEach((t4) => {
    e2.strokeText(t4.char, t4.x, s2.y);
  });
  if (r2) {
    const { decorationHeight: t3 } = n2;
    o2.forEach((i3) => r2.forEach((s3) => e2.strokeRect(i3.x, i3.y + s3, i3.width, t3)));
  }
}, drawStrokesStyle: function(t2, e2, i2, s2, n2, o2) {
  let r2;
  const a2 = s2.__, { __hasMultiStrokeStyle: h2 } = a2;
  h2 || n2.setStroke(void 0, a2.__strokeWidth * e2, a2);
  for (let l2 = 0, c2 = t2.length; l2 < c2; l2++) if (r2 = t2[l2], (!r2.image || !Wt2.checkImage(r2, false, s2, n2, o2)) && r2.style) {
    if (h2) {
      const { strokeStyle: t3 } = r2;
      t3 ? n2.setStroke(r2.style, a2.__getRealStrokeWidth(t3) * e2, a2, t3) : n2.setStroke(r2.style, a2.__strokeWidth * e2, a2);
    } else n2.strokeStyle = r2.style;
    r2.originPaint.blendMode ? (n2.saveBlendMode(r2.originPaint.blendMode), i2 ? Ft2.drawTextStroke(s2, n2, o2) : n2.stroke(), n2.restoreBlendMode()) : i2 ? Ft2.drawTextStroke(s2, n2, o2) : n2.stroke();
  }
}, shape: function(t2, e2, s2) {
  const n2 = e2.getSameCanvas(), o2 = e2.bounds, r2 = t2.__nowWorld, a2 = t2.__layout, h2 = t2.__nowWorldShapeBounds || (t2.__nowWorldShapeBounds = {});
  let l2, c2, d2, u2, f2, p2;
  Ot4(a2.strokeSpread ? (At4(zt3, a2.boxBounds, a2.strokeSpread), zt3) : a2.boxBounds, r2, h2);
  let { scaleX: g2, scaleY: _2 } = t2.getRenderScaleData(true);
  if (o2.includes(h2)) p2 = n2, l2 = f2 = h2, c2 = r2;
  else {
    let n3;
    if ($t.fullImageShadow) n3 = h2;
    else {
      const t3 = a2.renderShapeSpread ? Ct4(o2, v.swapAndScale(a2.renderShapeSpread, g2, _2)) : o2;
      n3 = Ft4(t3, h2);
    }
    u2 = o2.getFitMatrix(n3);
    let { a: w2, d: m2 } = u2;
    u2.a < 1 && (p2 = e2.getSameCanvas(), t2.__renderShape(p2, s2), g2 *= w2, _2 *= m2), f2 = Dt4(h2, u2), l2 = Wt4(f2, -u2.e, -u2.f), c2 = Dt4(r2, u2), It4(c2, -u2.e, -u2.f);
    const v2 = s2.matrix;
    v2 ? (d2 = new pt(u2), d2.multiply(v2), w2 *= v2.scaleX, m2 *= v2.scaleY) : d2 = u2, d2.withScale(w2, m2), s2 = Object.assign(Object.assign({}, s2), { matrix: d2 });
  }
  return t2.__renderShape(n2, s2), { canvas: n2, matrix: d2, fitMatrix: u2, bounds: l2, renderBounds: c2, worldCanvas: p2, shapeBounds: f2, scaleX: g2, scaleY: _2 };
} };
var Vt4;
var Nt4 = new Ht();
var { isSame: qt3 } = zt;
function Ht4(t2, e2, i2, s2, n2, o2) {
  if ("fill" === e2 && !t2.__.__naturalWidth) {
    const e3 = t2.__;
    if (e3.__naturalWidth = s2.width / e3.pixelRatio, e3.__naturalHeight = s2.height / e3.pixelRatio, e3.__autoSide) return t2.forceUpdate("width"), t2.__proxyData && (t2.setProxyAttr("width", e3.width), t2.setProxyAttr("height", e3.height)), false;
  }
  return n2.data || Wt2.createData(n2, s2, i2, o2), true;
}
function Kt4(t2, e2) {
  Zt3(t2, Uo.LOAD, e2);
}
function Qt3(t2, e2) {
  Zt3(t2, Uo.LOADED, e2);
}
function $t3(t2, e2, i2) {
  e2.error = i2, t2.forceUpdate("surface"), Zt3(t2, Uo.ERROR, e2);
}
function Zt3(t2, e2, i2) {
  t2.hasEvent(e2) && t2.emitEvent(new Uo(e2, i2));
}
function Jt3(t2, e2) {
  const { leafer: i2 } = t2;
  i2 && i2.viewReady && (i2.renderer.ignore = e2);
}
var { get: te3, translate: ee3 } = q;
var ie3 = new Ht();
var se3 = {};
var ne3 = {};
function oe3(t2, e2, i2, n2) {
  const o2 = i(t2) || n2 ? (n2 ? i2 - n2 * e2 : i2 % e2) / ((n2 || Math.floor(i2 / e2)) - 1) : t2;
  return "auto" === t2 && o2 < 0 ? 0 : o2;
}
var re3 = {};
var ae3 = X();
var { get: he3, set: le3, rotateOfOuter: ce3, translate: de3, scaleOfOuter: ue3, multiplyParent: fe3, scale: pe3, rotate: ge3, skew: _e3 } = q;
function we3(t2, e2, i2, s2, n2, o2, r2, a2) {
  r2 && ge3(t2, r2), a2 && _e3(t2, a2.x, a2.y), n2 && pe3(t2, n2, o2), de3(t2, e2.x + i2, e2.y + s2);
}
function me3(t2, e2, i2, s2) {
  return new (i2 || (i2 = Promise))(function(n2, o2) {
    function r2(t3) {
      try {
        h2(s2.next(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function a2(t3) {
      try {
        h2(s2.throw(t3));
      } catch (t4) {
        o2(t4);
      }
    }
    function h2(t3) {
      var e3;
      t3.done ? n2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(r2, a2);
    }
    h2((s2 = s2.apply(t2, e2 || [])).next());
  });
}
var { get: ve3, scale: ye3, copy: xe3 } = q;
var { getFloorScale: be3 } = I;
var { abs: Se3 } = Math;
var Le3 = { image: function(t2, e2, i2, s2, n2) {
  let o2, r2;
  const a2 = en.get(i2);
  return Vt4 && i2 === Vt4.paint && qt3(s2, Vt4.boxBounds) ? o2 = Vt4.leafPaint : (o2 = { type: i2.type, image: a2 }, a2.hasAlphaPixel && (o2.isTransparent = true), Vt4 = a2.use > 1 ? { leafPaint: o2, paint: i2, boxBounds: Nt4.set(s2) } : null), (n2 || a2.loading) && (r2 = { image: a2, attrName: e2, attrValue: i2 }), a2.ready ? (Ht4(t2, e2, i2, a2, o2, s2), n2 && (Kt4(t2, r2), Qt3(t2, r2))) : a2.error ? n2 && $t3(t2, r2, a2.error) : (n2 && (Jt3(t2, true), Kt4(t2, r2)), o2.loadId = a2.load(() => {
    Jt3(t2, false), t2.destroyed || (Ht4(t2, e2, i2, a2, o2, s2) && (a2.hasAlphaPixel && (t2.__layout.hitCanvasChanged = true), t2.forceUpdate("surface")), Qt3(t2, r2)), o2.loadId = void 0;
  }, (e3) => {
    Jt3(t2, false), $t3(t2, r2, e3), o2.loadId = void 0;
  }, i2.lod && a2.getThumbSize(i2.lod)), t2.placeholderColor && (t2.placeholderDelay ? setTimeout(() => {
    a2.ready || (a2.isPlacehold = true, t2.forceUpdate("surface"));
  }, t2.placeholderDelay) : a2.isPlacehold = true)), o2;
}, checkImage: function(t2, e2, s2, n2, o2) {
  const { scaleX: r2, scaleY: h2 } = Wt2.getImageRenderScaleData(t2, s2, n2, o2), { image: l2, data: c2, originPaint: d2 } = t2, { exporting: u2, snapshot: f2 } = o2;
  return !(!c2 || t2.patternId === r2 + "-" + h2 && !u2 || f2) && (e2 && (c2.repeat ? e2 = false : d2.changeful || "miniapp" === $t.name && Jo.isResizing(s2) || u2 || (e2 = $t.image.isLarge(l2, r2, h2) || l2.width * r2 > 8096 || l2.height * h2 > 8096)), e2 ? (s2.__.__isFastShadow && (n2.fillStyle = t2.style || "#000", n2.fill()), Wt2.drawImage(t2, r2, h2, s2, n2, o2), true) : (!t2.style || d2.sync || u2 ? Wt2.createPattern(t2, s2, n2, o2) : Wt2.createPatternTask(t2, s2, n2, o2), false));
}, drawImage: function(t2, e2, i2, s2, n2, o2) {
  const { data: r2, image: a2 } = t2, { blendMode: h2 } = t2.originPaint, { opacity: l2, transform: c2 } = r2, d2 = a2.getFull(r2.filters), u2 = s2.__;
  let f2, { width: p2, height: g2 } = a2;
  (f2 = c2 && !c2.onlyScale || u2.path || u2.cornerRadius) || l2 || h2 ? (n2.save(), f2 && n2.clipUI(s2), h2 && (n2.blendMode = h2), l2 && (n2.opacity *= l2), c2 && n2.transform(c2), n2.drawImage(d2, 0, 0, p2, g2), n2.restore()) : (r2.scaleX && (p2 *= r2.scaleX, g2 *= r2.scaleY), n2.drawImage(d2, 0, 0, p2, g2));
}, getImageRenderScaleData: function(t2, e2, i2, s2) {
  const n2 = e2.getRenderScaleData(true, t2.originPaint.scaleFixed), { data: o2 } = t2;
  if (i2) {
    const { pixelRatio: t3 } = i2;
    n2.scaleX *= t3, n2.scaleY *= t3;
  }
  return o2 && o2.scaleX && (n2.scaleX *= Math.abs(o2.scaleX), n2.scaleY *= Math.abs(o2.scaleY)), n2;
}, recycleImage: function(t2, e2) {
  const i2 = e2["_" + t2];
  if (l(i2)) {
    let s2, n2, o2, r2, a2;
    for (let h2 = 0, l2 = i2.length; h2 < l2; h2++) s2 = i2[h2], n2 = s2.image, a2 = n2 && n2.url, a2 && (o2 || (o2 = {}), o2[a2] = true, en.recyclePaint(s2), n2.loading && (r2 || (r2 = e2.__input && e2.__input[t2] || [], l(r2) || (r2 = [r2])), n2.unload(i2[h2].loadId, !r2.some((t3) => t3.url === a2))));
    return o2;
  }
  return null;
}, createPatternTask: function(t2, e2, i2, s2) {
  t2.patternTask || (t2.patternTask = en.patternTasker.add(() => me3(this, void 0, void 0, function* () {
    Wt2.createPattern(t2, e2, i2, s2), e2.forceUpdate("surface");
  }), 0, () => (t2.patternTask = null, i2.bounds.hit(e2.__nowWorld))));
}, createPattern: function(t2, e2, s2, n2) {
  let { scaleX: o2, scaleY: r2 } = Wt2.getImageRenderScaleData(t2, e2, s2, n2), a2 = o2 + "-" + r2;
  if (t2.patternId !== a2 && !e2.destroyed && (!$t.image.isLarge(t2.image, o2, r2) || t2.data.repeat)) {
    const { image: s3, data: n3 } = t2, { transform: h2, gap: l2 } = n3, c2 = Wt2.getPatternFixScale(t2, o2, r2);
    let d2, u2, f2, { width: p2, height: g2 } = s3;
    c2 && (o2 *= c2, r2 *= c2), p2 *= o2, g2 *= r2, l2 && (u2 = l2.x * o2 / Se3(n3.scaleX || 1), f2 = l2.y * r2 / Se3(n3.scaleY || 1)), (h2 || 1 !== o2 || 1 !== r2) && (o2 *= be3(p2 + (u2 || 0)), r2 *= be3(g2 + (f2 || 0)), d2 = ve3(), h2 && xe3(d2, h2), ye3(d2, 1 / o2, 1 / r2));
    const _2 = s3.getCanvas(p2, g2, n3.opacity, n3.filters, u2, f2, e2.leafer && e2.leafer.config.smooth, n3.interlace), w2 = s3.getPattern(_2, n3.repeat || $t.origin.noRepeat || "no-repeat", d2, t2);
    t2.style = w2, t2.patternId = a2;
  }
}, getPatternFixScale: function(t2, e2, s2) {
  const { image: n2 } = t2;
  let o2, r2 = $t.image.maxPatternSize, a2 = n2.width * n2.height;
  return n2.isSVG ? e2 > 1 && (o2 = Math.ceil(e2) / e2) : r2 > a2 && (r2 = a2), (a2 *= e2 * s2) > r2 && (o2 = Math.sqrt(r2 / a2)), o2;
}, createData: function(t2, e2, i2, s2) {
  t2.data = Wt2.getPatternData(i2, s2, e2);
}, getPatternData: function(t2, e2, i2) {
  t2.padding && (e2 = ie3.set(e2).shrink(t2.padding)), "strench" === t2.mode && (t2.mode = "stretch");
  const { width: n2, height: o2 } = i2, { opacity: r2, mode: a2, align: h2, offset: l2, scale: c2, size: d2, rotation: u2, skew: f2, clipSize: p2, repeat: g2, gap: _2, filters: w2, interlace: m2 } = t2, v2 = e2.width === n2 && e2.height === o2, y2 = { mode: a2 }, x2 = "center" !== h2 && (u2 || 0) % 180 == 90;
  let b2, S2;
  switch (zt.set(ne3, 0, 0, x2 ? o2 : n2, x2 ? n2 : o2), a2 && "cover" !== a2 && "fit" !== a2 ? ((c2 || d2) && (I.getScaleData(c2, d2, i2, se3), b2 = se3.scaleX, S2 = se3.scaleY), (h2 || _2 || g2) && (b2 && zt.scale(ne3, b2, S2, true), h2 && kt.toPoint(h2, ne3, e2, ne3, true, true))) : v2 && !u2 || (b2 = S2 = zt.getFitScale(e2, ne3, "fit" !== a2), zt.put(e2, i2, h2, b2, false, ne3), zt.scale(ne3, b2, S2, true)), l2 && ot.move(ne3, l2), a2) {
    case "stretch":
      v2 ? b2 && (b2 = S2 = void 0) : (b2 = e2.width / n2, S2 = e2.height / o2, Wt2.stretchMode(y2, e2, b2, S2));
      break;
    case "normal":
    case "clip":
      if (ne3.x || ne3.y || b2 || p2 || u2 || f2) {
        let t3, i4;
        p2 && (t3 = e2.width / p2.width, i4 = e2.height / p2.height), Wt2.clipMode(y2, e2, ne3.x, ne3.y, b2, S2, u2, f2, t3, i4), t3 && (b2 = b2 ? b2 * t3 : t3, S2 = S2 ? S2 * i4 : i4);
      }
      break;
    case "repeat":
      (!v2 || b2 || u2 || f2) && Wt2.repeatMode(y2, e2, n2, o2, ne3.x, ne3.y, b2, S2, u2, f2, h2, t2.freeTransform), g2 || (y2.repeat = "repeat");
      const i3 = d(g2);
      (_2 || i3) && (y2.gap = (function(t3, e3, i4, s2, n3) {
        let o3, r3;
        d(t3) ? (o3 = t3.x, r3 = t3.y) : o3 = r3 = t3;
        return { x: oe3(o3, i4, n3.width, e3 && e3.x), y: oe3(r3, s2, n3.height, e3 && e3.y) };
      })(_2, i3 && g2, ne3.width, ne3.height, e2));
      break;
    default:
      b2 && Wt2.fillOrFitMode(y2, e2, ne3.x, ne3.y, b2, S2, u2);
  }
  return y2.transform || (e2.x || e2.y) && ee3(y2.transform = te3(), e2.x, e2.y), b2 && (y2.scaleX = b2, y2.scaleY = S2), r2 && r2 < 1 && (y2.opacity = r2), w2 && (y2.filters = w2), g2 && (y2.repeat = i(g2) ? "x" === g2 ? "repeat-x" : "repeat-y" : "repeat"), m2 && (y2.interlace = o(m2) || "percent" === m2.type ? { type: "x", offset: m2 } : m2), y2;
}, stretchMode: function(t2, e2, i2, s2) {
  const n2 = he3(), { x: o2, y: r2 } = e2;
  o2 || r2 ? de3(n2, o2, r2) : n2.onlyScale = true, pe3(n2, i2, s2), t2.transform = n2;
}, fillOrFitMode: function(t2, e2, i2, s2, n2, o2, r2) {
  const a2 = he3();
  de3(a2, e2.x + i2, e2.y + s2), pe3(a2, n2, o2), r2 && ce3(a2, { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 }, r2), t2.transform = a2;
}, clipMode: function(t2, e2, i2, s2, n2, o2, r2, a2, h2, l2) {
  const c2 = he3();
  we3(c2, e2, i2, s2, n2, o2, r2, a2), h2 && (r2 || a2 ? (le3(ae3), ue3(ae3, e2, h2, l2), fe3(c2, ae3)) : ue3(c2, e2, h2, l2)), t2.transform = c2;
}, repeatMode: function(t2, e2, i2, s2, n2, o2, r2, a2, h2, l2, c2, d2) {
  const u2 = he3();
  if (d2) we3(u2, e2, n2, o2, r2, a2, h2, l2);
  else {
    if (h2) if ("center" === c2) ce3(u2, { x: i2 / 2, y: s2 / 2 }, h2);
    else switch (ge3(u2, h2), h2) {
      case 90:
        de3(u2, s2, 0);
        break;
      case 180:
        de3(u2, i2, s2);
        break;
      case 270:
        de3(u2, 0, i2);
    }
    re3.x = e2.x + n2, re3.y = e2.y + o2, de3(u2, re3.x, re3.y), r2 && ue3(u2, re3, r2, a2);
  }
  t2.transform = u2;
} };
var { toPoint: ke3 } = bt;
var { hasTransparent: Be3 } = Ct2;
var Te3 = {};
var Ee3 = {};
function Pe3(t2, e2, i2, n2) {
  if (i2) {
    let o2, r2, a2, h2;
    for (let t3 = 0, l2 = i2.length; t3 < l2; t3++) o2 = i2[t3], i(o2) ? (a2 = t3 / (l2 - 1), r2 = Ct2.string(o2, n2)) : (a2 = o2.offset, r2 = Ct2.string(o2.color, n2)), e2.addColorStop(a2, r2), !h2 && Be3(r2) && (h2 = true);
    h2 && (t2.isTransparent = true);
  }
}
var { getAngle: Re3, getDistance: Me3 } = ot;
var { get: Ce3, rotateOfOuter: Ae3, scaleOfOuter: Oe3 } = q;
var { toPoint: De3 } = bt;
var We3 = {};
var Ie3 = {};
function Fe3(t2, e2, i2, s2, n2) {
  let o2;
  const { width: r2, height: a2 } = t2;
  if (r2 !== a2 || s2) {
    const t3 = Re3(e2, i2);
    o2 = Ce3(), n2 ? (Oe3(o2, e2, r2 / a2 * (s2 || 1), 1), Ae3(o2, e2, t3 + 90)) : (Oe3(o2, e2, 1, r2 / a2 * (s2 || 1)), Ae3(o2, e2, t3));
  }
  return o2;
}
var { getDistance: ze3 } = ot;
var { toPoint: je3 } = bt;
var Ue3 = {};
var Ge3 = {};
var Ye3 = { linearGradient: function(t2, e2) {
  let { from: s2, to: n2, type: o2, opacity: r2 } = t2;
  ke3(s2 || "top", e2, Te3), ke3(n2 || "bottom", e2, Ee3);
  const a2 = $t.canvas.createLinearGradient(Te3.x, Te3.y, Ee3.x, Ee3.y), h2 = { type: o2, style: a2 };
  return Pe3(h2, a2, t2.stops, r2), h2;
}, radialGradient: function(t2, e2) {
  let { from: s2, to: n2, type: o2, opacity: r2, stretch: a2 } = t2;
  De3(s2 || "center", e2, We3), De3(n2 || "bottom", e2, Ie3);
  const h2 = $t.canvas.createRadialGradient(We3.x, We3.y, 0, We3.x, We3.y, Me3(We3, Ie3)), l2 = { type: o2, style: h2 };
  Pe3(l2, h2, t2.stops, r2);
  const c2 = Fe3(e2, We3, Ie3, a2, true);
  return c2 && (l2.transform = c2), l2;
}, conicGradient: function(t2, e2) {
  let { from: s2, to: n2, type: o2, opacity: r2, stretch: a2 } = t2;
  je3(s2 || "center", e2, Ue3), je3(n2 || "bottom", e2, Ge3);
  const h2 = $t.conicGradientSupport ? $t.canvas.createConicGradient(0, Ue3.x, Ue3.y) : $t.canvas.createRadialGradient(Ue3.x, Ue3.y, 0, Ue3.x, Ue3.y, ze3(Ue3, Ge3)), l2 = { type: o2, style: h2 };
  Pe3(l2, h2, t2.stops, r2);
  const c2 = Fe3(e2, Ue3, Ge3, a2 || 1, $t.conicGradientRotate90);
  return c2 && (l2.transform = c2), l2;
}, getTransform: Fe3 };
var { copy: Xe3, move: Ve3, toOffsetOutBounds: Ne3 } = zt;
var { max: qe3, abs: He3 } = Math;
var Ke3 = {};
var Qe3 = new pt();
var $e3 = {};
function Ze3(t2, e2) {
  let i2, s2, n2, o2, r2 = 0, a2 = 0, h2 = 0, l2 = 0;
  return e2.forEach((t3) => {
    i2 = t3.x || 0, s2 = t3.y || 0, o2 = 1.5 * (t3.blur || 0), n2 = He3(t3.spread || 0), r2 = qe3(r2, n2 + o2 - s2), a2 = qe3(a2, n2 + o2 + i2), h2 = qe3(h2, n2 + o2 + s2), l2 = qe3(l2, n2 + o2 - i2);
  }), r2 === a2 && a2 === h2 && h2 === l2 ? r2 : [r2, a2, h2, l2];
}
function Je3(t2, e2, s2) {
  const { shapeBounds: n2 } = s2;
  let o2, r2;
  $t.fullImageShadow ? (Xe3(Ke3, t2.bounds), Ve3(Ke3, e2.x - n2.x, e2.y - n2.y), o2 = t2.bounds, r2 = Ke3) : (o2 = n2, r2 = e2), t2.copyWorld(s2.canvas, o2, r2);
}
var { toOffsetOutBounds: ti3 } = zt;
var ei3 = {};
var ii3 = Ze3;
var si3 = { shadow: function(t2, e2, i2) {
  let s2, n2;
  const { __nowWorld: o2 } = t2, { shadow: r2 } = t2.__, { worldCanvas: a2, bounds: h2, renderBounds: l2, shapeBounds: c2, scaleX: d2, scaleY: u2 } = i2, f2 = e2.getSameCanvas(), p2 = r2.length - 1;
  Ne3(h2, $e3, l2), r2.forEach((r3, g2) => {
    let _2 = 1;
    if (r3.scaleFixed) {
      const t3 = Math.abs(o2.scaleX);
      t3 > 1 && (_2 = 1 / t3);
    }
    f2.setWorldShadow($e3.offsetX + (r3.x || 0) * d2 * _2, $e3.offsetY + (r3.y || 0) * u2 * _2, (r3.blur || 0) * d2 * _2, Ct2.string(r3.color)), n2 = Dt2.getShadowTransform(t2, f2, i2, r3, $e3, _2), n2 && f2.setTransform(n2), Je3(f2, $e3, i2), n2 && f2.resetTransform(), s2 = l2, r3.box && (f2.restore(), f2.save(), a2 && (f2.copyWorld(f2, l2, o2, "copy"), s2 = o2), a2 ? f2.copyWorld(a2, o2, o2, "destination-out") : f2.copyWorld(i2.canvas, c2, h2, "destination-out")), ho.copyCanvasByWorld(t2, e2, f2, s2, r3.blendMode), p2 && g2 < p2 && f2.clearWorld(s2);
  }), f2.recycle(s2);
}, innerShadow: function(t2, e2, i2) {
  let s2, n2;
  const { __nowWorld: o2 } = t2, { innerShadow: r2 } = t2.__, { worldCanvas: a2, bounds: h2, renderBounds: l2, shapeBounds: c2, scaleX: d2, scaleY: u2 } = i2, f2 = e2.getSameCanvas(), p2 = r2.length - 1;
  ti3(h2, ei3, l2), r2.forEach((r3, g2) => {
    let _2 = 1;
    if (r3.scaleFixed) {
      const t3 = Math.abs(o2.scaleX);
      t3 > 1 && (_2 = 1 / t3);
    }
    f2.save(), f2.setWorldShadow(ei3.offsetX + (r3.x || 0) * d2 * _2, ei3.offsetY + (r3.y || 0) * u2 * _2, (r3.blur || 0) * d2 * _2), n2 = Dt2.getShadowTransform(t2, f2, i2, r3, ei3, _2, true), n2 && f2.setTransform(n2), Je3(f2, ei3, i2), f2.restore(), a2 ? (f2.copyWorld(f2, l2, o2, "copy"), f2.copyWorld(a2, o2, o2, "source-out"), s2 = o2) : (f2.copyWorld(i2.canvas, c2, h2, "source-out"), s2 = l2), f2.fillWorld(s2, Ct2.string(r3.color), "source-in"), ho.copyCanvasByWorld(t2, e2, f2, s2, r3.blendMode), p2 && g2 < p2 && f2.clearWorld(s2);
  }), f2.recycle(s2);
}, blur: function(t2, e2, i2) {
  const { blur: s2 } = t2.__;
  i2.setWorldBlur(s2 * t2.__nowWorld.a), i2.copyWorldToInner(e2, t2.__nowWorld, t2.__layout.renderBounds), i2.filter = "none";
}, backgroundBlur: function(t2, e2, i2) {
}, getShadowRenderSpread: Ze3, getShadowTransform: function(t2, e2, i2, s2, n2, o2, r2) {
  if (s2.spread) {
    const i3 = 2 * s2.spread * o2 * (r2 ? -1 : 1), { width: a2, height: h2 } = t2.__layout.strokeBounds;
    return Qe3.set().scaleOfOuter({ x: (n2.x + n2.width / 2) * e2.pixelRatio, y: (n2.y + n2.height / 2) * e2.pixelRatio }, 1 + i3 / a2, 1 + i3 / h2), Qe3;
  }
}, isTransformShadow(t2) {
}, getInnerShadowSpread: ii3 };
var { excludeRenderBounds: ni3 } = yo;
var oi3;
function ri3(t2, e2, i2, s2, n2, o2, r2, a2) {
  switch (e2) {
    case "grayscale":
      oi3 || (oi3 = true, n2.useGrayscaleAlpha(t2.__nowWorld));
    case "alpha":
      !(function(t3, e3, i3, s3, n3, o3) {
        const r3 = t3.__nowWorld;
        i3.resetTransform(), i3.opacity = 1, i3.useMask(s3, r3), o3 && s3.recycle(r3);
        hi3(t3, e3, i3, 1, n3, o3);
      })(t2, i2, s2, n2, r2, a2);
      break;
    case "opacity-path":
      hi3(t2, i2, s2, o2, r2, a2);
      break;
    case "path":
      a2 && i2.restore();
  }
}
function ai3(t2) {
  return t2.getSameCanvas(false, true);
}
function hi3(t2, e2, i2, s2, n2, o2) {
  const r2 = t2.__nowWorld;
  e2.resetTransform(), e2.opacity = s2, e2.copyWorld(i2, r2, void 0, n2), o2 ? i2.recycle(r2) : i2.clearWorld(r2);
}
ye2.prototype.__renderMask = function(t2, e2) {
  let i2, s2, n2, o2, r2, a2;
  const { children: h2 } = this;
  for (let l2 = 0, c2 = h2.length; l2 < c2; l2++) {
    if (i2 = h2[l2], a2 = i2.__.mask, a2) {
      r2 && (ri3(this, r2, t2, n2, s2, o2, void 0, true), s2 = n2 = null), "clipping" !== a2 && "clipping-path" !== a2 || ni3(i2, e2) || i2.__render(t2, e2), o2 = i2.__.opacity, oi3 = false, "path" === a2 || "clipping-path" === a2 ? (o2 < 1 ? (r2 = "opacity-path", n2 || (n2 = ai3(t2))) : (r2 = "path", t2.save()), i2.__clip(n2 || t2, e2)) : (r2 = "grayscale" === a2 ? "grayscale" : "alpha", s2 || (s2 = ai3(t2)), n2 || (n2 = ai3(t2)), i2.__render(s2, e2));
      continue;
    }
    const c3 = 1 === o2 && i2.__.__blendMode;
    c3 && ri3(this, r2, t2, n2, s2, o2, void 0, false), ni3(i2, e2) || i2.__render(n2 || t2, e2), c3 && ri3(this, r2, t2, n2, s2, o2, c3, false);
  }
  ri3(this, r2, t2, n2, s2, o2, void 0, true);
};
var li3 = `>)]}%!?,.:;'"`;
var ci2 = li3 + "_#~&*+\\=|";
var di3 = new RegExp([[19968, 40959], [13312, 19903], [131072, 173791], [173824, 177983], [177984, 178207], [178208, 183983], [183984, 191471], [196608, 201551], [201552, 205743], [11904, 12031], [12032, 12255], [12272, 12287], [12288, 12351], [12736, 12783], [12800, 13055], [13056, 13311], [63744, 64255], [65072, 65103], [127488, 127743], [194560, 195103]].map(([t2, e2]) => `[\\u${t2.toString(16)}-\\u${e2.toString(16)}]`).join("|"));
function ui2(t2) {
  const e2 = {};
  return t2.split("").forEach((t3) => e2[t3] = true), e2;
}
var fi2 = ui2("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz");
var pi2 = ui2(`{[(<'"`);
var gi2 = ui2(li3);
var _i3 = ui2(ci2);
var wi2 = ui2("- ");
var mi2;
!(function(t2) {
  t2[t2.Letter = 0] = "Letter", t2[t2.Single = 1] = "Single", t2[t2.Before = 2] = "Before", t2[t2.After = 3] = "After", t2[t2.Symbol = 4] = "Symbol", t2[t2.Break = 5] = "Break";
})(mi2 || (mi2 = {}));
var { Letter: vi2, Single: yi2, Before: xi2, After: bi2, Symbol: Si2, Break: Li2 } = mi2;
function ki2(t2) {
  return fi2[t2] ? vi2 : wi2[t2] ? Li2 : pi2[t2] ? xi2 : gi2[t2] ? bi2 : _i3[t2] ? Si2 : di3.test(t2) ? yi2 : vi2;
}
var Bi2 = { trimRight(t2) {
  const { words: e2 } = t2;
  let i2, s2 = 0, n2 = e2.length;
  for (let o2 = n2 - 1; o2 > -1 && (i2 = e2[o2].data[0], " " === i2.char); o2--) s2++, t2.width -= i2.width;
  s2 && e2.splice(n2 - s2, s2);
} };
function Ti2(t2, e2, i2) {
  switch (e2) {
    case "title":
      return i2 ? t2.toUpperCase() : t2;
    case "upper":
      return t2.toUpperCase();
    case "lower":
      return t2.toLowerCase();
    default:
      return t2;
  }
}
var { trimRight: Ei2 } = Bi2;
var { Letter: Pi2, Single: Ri2, Before: Mi2, After: Ci2, Symbol: Ai2, Break: Oi2 } = mi2;
var Di2;
var Wi2;
var Ii2;
var Fi2;
var zi2;
var ji2;
var Ui2;
var Gi2;
var Yi2;
var Xi2;
var Vi2;
var Ni2;
var qi2;
var Hi2;
var Ki2;
var Qi2;
var $i2;
var Zi2 = [];
function Ji2(t2, e2) {
  Yi2 && !Gi2 && (Gi2 = Yi2), Di2.data.push({ char: t2, width: e2 }), Ii2 += e2;
}
function ts2() {
  Fi2 += Ii2, Di2.width = Ii2, Wi2.words.push(Di2), Di2 = { data: [] }, Ii2 = 0;
}
function es2() {
  Hi2 && (Ki2.paraNumber++, Wi2.paraStart = true, Hi2 = false), Yi2 && (Wi2.startCharSize = Gi2, Wi2.endCharSize = Yi2, Gi2 = 0), Wi2.width = Fi2, Qi2.width ? Ei2(Wi2) : $i2 && is2(), Zi2.push(Wi2), Wi2 = { words: [] }, Fi2 = 0;
}
function is2() {
  Fi2 > (Ki2.maxWidth || 0) && (Ki2.maxWidth = Fi2);
}
var { top: ss2, right: ns2, bottom: os2, left: rs2 } = mt;
function as2(t2, e2, i2) {
  const { bounds: s2, rows: n2 } = t2;
  s2[e2] += i2;
  for (let t3 = 0; t3 < n2.length; t3++) n2[t3][e2] += i2;
}
var hs2 = { getDrawData: function(t2, e2) {
  i(t2) || (t2 = String(t2));
  let n2 = 0, o2 = 0, r2 = e2.__getInput("width") || 0, a2 = e2.__getInput("height") || 0;
  const { __padding: h2 } = e2;
  h2 && (r2 ? (n2 = h2[rs2], r2 -= h2[ns2] + h2[rs2], !r2 && (r2 = 0.01)) : e2.autoSizeAlign || (n2 = h2[rs2]), a2 ? (o2 = h2[ss2], a2 -= h2[ss2] + h2[os2], !a2 && (a2 = 0.01)) : e2.autoSizeAlign || (o2 = h2[ss2]));
  const l2 = { bounds: { x: n2, y: o2, width: r2, height: a2 }, rows: [], paraNumber: 0, font: $t.canvas.font = e2.__font };
  return (function(t3, e3, s2) {
    Ki2 = t3, Zi2 = t3.rows, Qi2 = t3.bounds, $i2 = !Qi2.width && !s2.autoSizeAlign;
    const { __letterSpacing: n3, paraIndent: o3, textCase: r3 } = s2, { canvas: a3 } = $t, { width: h3 } = Qi2;
    if (s2.__isCharMode) {
      const t4 = "none" !== s2.textWrap, i2 = "break" === s2.textWrap;
      Hi2 = true, Vi2 = null, Gi2 = Ui2 = Yi2 = Ii2 = Fi2 = 0, Di2 = { data: [] }, Wi2 = { words: [] }, n3 && (e3 = [...e3]);
      for (let s3 = 0, l3 = e3.length; s3 < l3; s3++) ji2 = e3[s3], "\n" === ji2 ? (Ii2 && ts2(), Wi2.paraEnd = true, es2(), Hi2 = true) : (Xi2 = ki2(ji2), Xi2 === Pi2 && "none" !== r3 && (ji2 = Ti2(ji2, r3, !Ii2)), Ui2 = a3.measureText(ji2).width, n3 && (n3 < 0 && (Yi2 = Ui2), Ui2 += n3), Ni2 = Xi2 === Ri2 && (Vi2 === Ri2 || Vi2 === Pi2) || Vi2 === Ri2 && Xi2 !== Ci2, qi2 = !(Xi2 !== Mi2 && Xi2 !== Ri2 || Vi2 !== Ai2 && Vi2 !== Ci2), zi2 = Hi2 && o3 ? h3 - o3 : h3, t4 && h3 && Fi2 + Ii2 + Ui2 > zi2 && (i2 ? (Ii2 && ts2(), Fi2 && es2()) : (qi2 || (qi2 = Xi2 === Pi2 && Vi2 == Ci2), Ni2 || qi2 || Xi2 === Oi2 || Xi2 === Mi2 || Xi2 === Ri2 || Ii2 + Ui2 > zi2 ? (Ii2 && ts2(), Fi2 && es2()) : Fi2 && es2())), " " === ji2 && true !== Hi2 && Fi2 + Ii2 === 0 || (Xi2 === Oi2 ? (" " === ji2 && Ii2 && ts2(), Ji2(ji2, Ui2), ts2()) : Ni2 || qi2 ? (Ii2 && ts2(), Ji2(ji2, Ui2)) : Ji2(ji2, Ui2)), Vi2 = Xi2);
      Ii2 && ts2(), Fi2 && es2(), Zi2.length > 0 && (Zi2[Zi2.length - 1].paraEnd = true);
    } else e3.split("\n").forEach((t4) => {
      Ki2.paraNumber++, Fi2 = a3.measureText(t4).width, Zi2.push({ x: o3 || 0, text: t4, width: Fi2, paraStart: true }), $i2 && is2();
    });
  })(l2, t2, e2), h2 && (function(t3, e3, i2, s2, n3) {
    if (!s2 && i2.autoSizeAlign) switch (i2.textAlign) {
      case "left":
        as2(e3, "x", t3[rs2]);
        break;
      case "right":
        as2(e3, "x", -t3[ns2]);
    }
    if (!n3 && i2.autoSizeAlign) switch (i2.verticalAlign) {
      case "top":
        as2(e3, "y", t3[ss2]);
        break;
      case "bottom":
        as2(e3, "y", -t3[os2]);
    }
  })(h2, l2, e2, r2, a2), (function(t3, e3) {
    const { rows: i2, bounds: s2 } = t3, n3 = i2.length, { __lineHeight: o3, __baseLine: r3, __letterSpacing: a3, __clipText: h3, textAlign: l3, verticalAlign: c2, paraSpacing: d2, autoSizeAlign: u2 } = e3;
    let { x: f2, y: p2, width: g2, height: _2 } = s2, w2 = o3 * n3 + (d2 ? d2 * (t3.paraNumber - 1) : 0), m2 = r3;
    if (h3 && w2 > _2) w2 = Math.max(_2, o3), n3 > 1 && (t3.overflow = n3);
    else if (_2 || u2) switch (c2) {
      case "middle":
        p2 += (_2 - w2) / 2;
        break;
      case "bottom":
        p2 += _2 - w2;
    }
    m2 += p2;
    let v2, y2, x2, b2 = g2 || u2 ? g2 : t3.maxWidth;
    for (let r4 = 0, c3 = n3; r4 < c3; r4++) {
      if (v2 = i2[r4], v2.x = f2, v2.width < g2 || v2.width > g2 && !h3) switch (l3) {
        case "center":
          v2.x += (b2 - v2.width) / 2;
          break;
        case "right":
          v2.x += b2 - v2.width;
      }
      v2.paraStart && d2 && r4 > 0 && (m2 += d2), v2.y = m2, m2 += o3, t3.overflow > r4 && m2 > w2 && (v2.isOverflow = true, t3.overflow = r4 + 1), y2 = v2.x, x2 = v2.width, a3 < 0 && (v2.width < 0 ? (x2 = -v2.width + e3.fontSize + a3, y2 -= x2, x2 += e3.fontSize) : x2 -= a3), y2 < s2.x && (s2.x = y2), x2 > s2.width && (s2.width = x2), h3 && g2 && g2 < x2 && (v2.isOverflow = true, t3.overflow || (t3.overflow = i2.length));
    }
    s2.y = p2, s2.height = w2;
  })(l2, e2), e2.__isCharMode && (function(t3, e3, i2) {
    const { rows: s2 } = t3, { textAlign: n3, paraIndent: o3, __letterSpacing: r3 } = e3, a3 = i2 && n3.includes("both"), h3 = a3 || i2 && n3.includes("justify"), l3 = h3 && n3.includes("letter");
    let c2, d2, u2, f2, p2, g2, _2, w2, m2, v2;
    s2.forEach((t4) => {
      t4.words && (p2 = o3 && t4.paraStart ? o3 : 0, w2 = t4.words.length, h3 && (v2 = !t4.paraEnd || a3, d2 = i2 - t4.width - p2, l3 ? f2 = d2 / (t4.words.reduce((t5, e4) => t5 + e4.data.length, 0) - 1) : u2 = w2 > 1 ? d2 / (w2 - 1) : 0), g2 = r3 || t4.isOverflow || l3 ? 0 : u2 ? 1 : 2, t4.isOverflow && !r3 && (t4.textMode = true), 2 === g2 ? (t4.x += p2, (function(t5) {
        t5.text = "", t5.words.forEach((e4) => {
          e4.data.forEach((e5) => {
            t5.text += e5.char;
          });
        });
      })(t4)) : (t4.x += p2, c2 = t4.x, t4.data = [], t4.words.forEach((e4, i3) => {
        1 === g2 ? (_2 = { char: "", x: c2 }, c2 = (function(t5, e5, i4) {
          return t5.forEach((t6) => {
            i4.char += t6.char, e5 += t6.width;
          }), e5;
        })(e4.data, c2, _2), (t4.isOverflow || " " !== _2.char) && t4.data.push(_2)) : c2 = (function(t5, e5, i4, s3, n4) {
          return t5.forEach((t6) => {
            (s3 || " " !== t6.char) && (t6.x = e5, i4.push(t6)), e5 += t6.width, n4 && (e5 += n4);
          }), e5;
        })(e4.data, c2, t4.data, t4.isOverflow, v2 && f2), v2 && (m2 = i3 === w2 - 1, u2 ? m2 || (c2 += u2, t4.width += u2) : f2 && (t4.width += f2 * (e4.data.length - (m2 ? 1 : 0))));
      })), t4.words = null);
    });
  })(l2, e2, r2), l2.overflow && (function(t3, e3, s2, n3) {
    if (!n3) return;
    const { rows: o3, overflow: r3 } = t3;
    let { textOverflow: a3 } = e3;
    if (o3.splice(r3), a3 && "show" !== a3) {
      let t4, h3;
      "hide" === a3 ? a3 = "" : "ellipsis" === a3 && (a3 = "...");
      const l3 = a3 ? $t.canvas.measureText(a3).width : 0, c2 = s2 + n3 - l3;
      ("none" === e3.textWrap ? o3 : [o3[r3 - 1]]).forEach((e4) => {
        if (e4.isOverflow && e4.data) {
          let i2 = e4.data.length - 1;
          for (let s3 = i2; s3 > -1 && (t4 = e4.data[s3], h3 = t4.x + t4.width, !(s3 === i2 && h3 < c2)); s3--) {
            if (h3 < c2 && " " !== t4.char || !s3) {
              e4.data.splice(s3 + 1), e4.width -= t4.width;
              break;
            }
            e4.width -= t4.width;
          }
          e4.width += l3, e4.data.push({ char: a3, x: h3 }), e4.textMode && (function(t5) {
            t5.text = "", t5.data.forEach((e5) => {
              t5.text += e5.char;
            }), t5.data = null;
          })(e4);
        }
      });
    }
  })(l2, e2, n2, r2), "none" !== e2.textDecoration && (function(t3, e3) {
    let i2, s2 = 0;
    const { fontSize: n3, textDecoration: o3 } = e3;
    switch (t3.decorationHeight = n3 / 11, d(o3) ? (i2 = o3.type, o3.color && (t3.decorationColor = Ct2.string(o3.color)), o3.offset && (s2 = Math.min(0.3 * n3, Math.max(o3.offset, 0.15 * -n3)))) : i2 = o3, i2) {
      case "under":
        t3.decorationY = [0.15 * n3 + s2];
        break;
      case "delete":
        t3.decorationY = [0.35 * -n3];
        break;
      case "under-delete":
        t3.decorationY = [0.15 * n3 + s2, 0.35 * -n3];
    }
  })(l2, e2), l2;
} };
var ls2 = { string: function(t2, e2) {
  if (!t2) return "#000";
  const i2 = o(e2) && e2 < 1;
  if (i(t2)) {
    if (!i2 || !Ct2.object) return t2;
    t2 = Ct2.object(t2);
  }
  let n2 = s(t2.a) ? 1 : t2.a;
  i2 && (n2 *= e2);
  const o2 = t2.r + "," + t2.g + "," + t2.b;
  return 1 === n2 ? "rgb(" + o2 + ")" : "rgba(" + o2 + "," + n2 + ")";
} };
Object.assign(At2, hs2), Object.assign(Ct2, ls2), Object.assign(Ft2, Xt4), Object.assign(Wt2, Le3), Object.assign(Et2, Ye3), Object.assign(Dt2, si3), Object.assign(le, { interaction: (t2, e2, i2, s2) => new Tt4(t2, e2, i2, s2), hitCanvas: (t2, e2) => new tt3(t2, e2), hitCanvasManager: () => new At3() }), st3();
export {
  kt as AlignHelper,
  t as Answer,
  N2 as App,
  bt as AroundHelper,
  Gt as AutoBounds,
  hs as BezierHelper,
  Ht as Bounds,
  jo as BoundsEvent,
  zt as BoundsHelper,
  Ae2 as Box,
  Jt2 as BoxData,
  bh as Branch,
  bo as BranchHelper,
  Da as BranchRender,
  si2 as Canvas,
  ae2 as CanvasData,
  ge as CanvasManager,
  Do as ChildEvent,
  Ct2 as ColorConvert,
  le as Creator,
  St3 as Cursor,
  _ as DataHelper,
  ee as Debug,
  mt as Direction4,
  xt as Direction9,
  tt2 as DragBoundsHelper,
  nt2 as DragEvent,
  Dt3 as Dragger,
  ht2 as DropEvent,
  Dt2 as Effect,
  We2 as Ellipse,
  Qt2 as EllipseData,
  ys as EllipseHelper,
  Yo as Event,
  pe as EventCreator,
  aa as Eventer,
  Tt2 as Export,
  Gi as FileHelper,
  It2 as Filter,
  v as FourNumberHelper,
  Ce2 as Frame,
  Gt2 as FrameData,
  ye2 as Group,
  jt2 as GroupData,
  At3 as HitCanvasManager,
  ei2 as Image,
  re2 as ImageData,
  Uo as ImageEvent,
  en as ImageManager,
  g as IncrementId,
  Tt4 as Interaction,
  Mt3 as InteractionBase,
  _t2 as InteractionHelper,
  pt2 as KeyEvent,
  W2 as Keyboard,
  $o as LayoutEvent,
  _t3 as Layouter,
  ch as Leaf,
  Aa as LeafBounds,
  yo as LeafBoundsHelper,
  f as LeafData,
  wa as LeafDataProxy,
  ma as LeafEventer,
  ho as LeafHelper,
  No as LeafLayout,
  vh as LeafLevelList,
  Bh as LeafList,
  Ta as LeafMatrix,
  Wa as LeafRender,
  we2 as Leafer,
  tt3 as LeaferCanvas,
  Ee as LeaferCanvasBase,
  qt2 as LeaferData,
  ta as LeaferEvent,
  on as LeaferImage,
  ti2 as Line,
  $t2 as LineData,
  I as MathHelper,
  pt as Matrix,
  q as MatrixHelper,
  ot2 as MoveEvent,
  rt2 as MyDragEvent,
  ii2 as MyImage,
  st2 as MyPointerEvent,
  gt2 as MyTouchEvent,
  Ne as NeedConvertToCanvasCommandMap,
  A as OneRadian,
  W as PI2,
  N as PI_2,
  Ft2 as Paint,
  Et2 as PaintGradient,
  Wt2 as PaintImage,
  di2 as Path,
  Pt2 as PathArrow,
  Ai as PathBounds,
  Cr as PathCommandDataHelper,
  Ae as PathCommandMap,
  ms as PathCommandNodeHelper,
  sr as PathConvert,
  Fi as PathCorner,
  Fr as PathCreator,
  ee2 as PathData,
  ri as PathDrawer,
  Ie as PathHelper,
  Z3 as PathNodeHandleType,
  ze as PathNumberCommandLengthMap,
  Xe as PathNumberCommandMap,
  li2 as Pen,
  ie2 as PenData,
  bt4 as Picker,
  $t as Platform,
  he as Plugin,
  ut as Point,
  ot as PointHelper,
  K2 as PointerButton,
  it2 as PointerEvent,
  Oe2 as Polygon,
  Zt2 as PolygonData,
  zo as PropertyEvent,
  xe2 as Rect,
  Kt2 as RectData,
  Fe as RectHelper,
  ue2 as RectRender,
  Ko as RenderEvent,
  mt4 as Renderer,
  Jo as ResizeEvent,
  Ki as Resource,
  lt2 as RotateEvent,
  ne as Run,
  St4 as Selector,
  je2 as Star,
  te2 as StarData,
  Lt2 as State,
  Qt as StringNumberMap,
  ct2 as SwipeEvent,
  Ji as TaskItem,
  Zi as TaskProcessor,
  hi2 as Text,
  At2 as TextConvert,
  oe2 as TextData,
  dt2 as TouchEvent,
  zt2 as Transition,
  gt as TwoPointBoundsHelper,
  ge2 as UI,
  he2 as UIBounds,
  ce as UICreator,
  Ut2 as UIData,
  V2 as UIEvent,
  le2 as UIRender,
  bt2 as UnitConvert,
  qt as UnitConvertHelper,
  To as WaitHelper,
  Zo as WatchEvent,
  ot3 as Watcher,
  ut2 as ZoomEvent,
  Tn as affectRenderBoundsType,
  kn as affectStrokeBoundsType,
  cn as attr,
  gn as autoLayoutType,
  xn as boundsType,
  Vi as canvasPatch,
  Re as canvasSizeAttrs,
  Bt2 as createAttr,
  ln as createDescriptor,
  Yn as cursorType,
  Dn as dataProcessor,
  _n as dataType,
  dn as decorateLeafAttr,
  zn as defineDataProcessor,
  an as defineKey,
  un as defineLeafAttr,
  Sn as dimType,
  bn as doBoundsType,
  Cn as doStrokeType,
  mt2 as effectType,
  e as emptyData,
  Wn as eraserType,
  Fo as extraPropertyEventMap,
  D as getBoundsData,
  hn as getDescriptor,
  X as getMatrixData,
  Y as getPointData,
  Nn as hitType,
  l as isArray,
  c as isData,
  u as isEmptyData,
  n as isFinite,
  r as isNull,
  o as isNumber,
  d as isObject,
  i as isString,
  s as isUndefined,
  Xn as layoutProcessor,
  na as leaferTransformAttrMap,
  An as maskType,
  wn as naturalBoundsType,
  Ln as opacityType,
  Ui as path,
  Bn as pathInputType,
  vn as pathType,
  ji as pen,
  pn as positionType,
  Qn as registerUI,
  Jn as registerUIEvent,
  Rt2 as resizeType,
  Hn as rewrite,
  Vn as rewriteAble,
  mn as rotationType,
  yn as scaleType,
  fn as scrollType,
  Mn as sortType,
  On as strokeType,
  Pn as surfaceType,
  Vt as tempBounds,
  ft as tempMatrix,
  _t as tempPoint,
  h as tryToNumber,
  st3 as useCanvas,
  qn as useModule,
  kh as version,
  Rn as visibleType,
  kt2 as zoomLayerType
};
//# sourceMappingURL=leafer-ui.js.map
