import { IBlendMode, IScaleFixed, IAlign, IUnitPointData, IImageLOD, IExportFileType, IFourNumber, IPointData, IOptionSizeData, ISizeData, IGap, IPointGap, IPercentData, IInterlace, IPathCommandData, IAxis, IAxisReverse, IDirection, IWindingRule, IFilter, IMatrixData, ILeaferImage, ITaskItem, INumber, IString, IBoolean, IUnitData, IAnimateOptions, IAnimateEasing, IEventer, IObject, IEventParamsMap, IAnimateEasingFunction, IAnimateEnding, ITransition, IBounds, ILeafInputData, ILeaf as ILeaf$1, ILeafComputedData, ILeafData, IBoundsData, IValue, IPathCreator, IJSONOptions, IFindCondition, IAnswer, IPathString, IPathDrawer, ILeaferCanvas, IRenderOptions, IExportOptions, IExportResult, IPickOptions, IPickResult, IAround, ICanvasContext2DSettings, ICanvasContext2D, ILeaferAttrData, IControl, ILeaferType, ILeaferConfig, ILeafRender, ILeafBounds, ILeafHit, ICachedLeaf, IScaleData as IScaleData$1, IBooleanMap, IFunction, IMatrixWithBoundsScaleData } from '@leafer/interface';
export * from '@leafer/interface';
import { IObject as IObject$1, IEditSize, IStroke as IStroke$1, IFourNumber as IFourNumber$1, IFill as IFill$1, IBoxInputData as IBoxInputData$1, IRectInputData as IRectInputData$1, IColorString as IColorString$1, IDirection4, ICursorType, IImageCursor, IAlign as IAlign$1, IUnitPointData as IUnitPointData$1, IUIInputData as IUIInputData$1, IShortcutKeysCheck, IShortcutKeys, IUI as IUI$1, IPointData as IPointData$1, IScaleData, ISkewData, IGroup as IGroup$1, ISelectorProxy, IBox as IBox$1, ILayoutBoundsData, IKeyEvent, IUIEvent, IDragEvent, IMoveEvent, IZoomEvent, IRotateEvent, ITransition as ITransition$1, ILeafList, ILeafer as ILeafer$1, ILeaf, IGroupInputData as IGroupInputData$1, IStateName as IStateName$1, IString as IString$1, IBoolean as IBoolean$1, IStateStyle as IStateStyle$1 } from '@leafer-ui/interface';

type IPercent = string;
type IColorString = string;
type ICornerRadiusString = string;
type IStrokeWidthString = string;
type IDashPatternString = string;
type IPaintString = ISolidPaintString | IGradientPaintString | IImagePaintString;
type ISolidPaintString = string;
type IGradientPaintString = string;
type IImagePaintString = string;
type IShadowString = string;

type IPaint = ISolidPaint | IGradientPaint | IImagePaint;
type IStrokePaint = IStrokeSolidPaint | IStrokeGradientPaint | IStrokeImagePaint;
type IFill = IPaint | IPaint[] | IPaintString;
type IStroke = IStrokePaint | IStrokePaint[] | IPaintString;
type IPaintAttr = 'fill' | 'stroke';
interface IPaintBase {
    type: IPaintType;
    blendMode?: IBlendMode;
    visible?: boolean;
    opacity?: number;
    style?: IStrokeStyle;
    editing?: boolean;
    scaleFixed?: IScaleFixed;
}
type IPaintType = 'image' | 'solid' | IGradientType;
type IGradientType = 'linear' | 'radial' | 'angular';
interface ISolidPaint extends IPaintBase {
    type: 'solid';
    color: IColor;
}
interface IStrokeSolidPaint extends ISolidPaint {
}
type IColor = IColorString | IRGB | IRGBA;
interface IRGB {
    r: number;
    g: number;
    b: number;
    a?: number;
}
interface IRGBA extends IRGB {
    a: number;
}
interface IGradientPaint extends IPaintBase {
    type: IGradientType;
    from?: IAlign | IUnitPointData;
    to?: IAlign | IUnitPointData;
    stretch?: number;
    stops: IColorStop[] | IColorString[];
}
interface IStrokeGradientPaint extends IGradientPaint {
}
interface IColorStop {
    offset: number;
    color: IColor;
}
interface IImagePaint extends IPaintBase {
    type: "image";
    url: string;
    lod?: IImageLOD;
    mode?: IImagePaintMode;
    format?: IExportFileType;
    filters?: IImageFilters;
    padding?: IFourNumber;
    align?: IAlign;
    offset?: IPointData;
    size?: number | IOptionSizeData;
    scale?: number | IPointData;
    rotation?: number;
    skew?: IPointData;
    freeTransform?: boolean;
    clipSize?: ISizeData;
    repeat?: IRepeat;
    gap?: IGap | IPointGap;
    interlace?: number | IPercentData | IInterlace;
    changeful?: boolean;
    sync?: boolean;
    showProgress?: boolean | IColorString;
}
interface IStrokeImagePaint extends IImagePaint {
}
interface IImageFilters {
    exposure?: number;
    contrast?: number;
    saturation?: number;
    temperature?: number;
    tint?: number;
    highlights?: number;
    shadows?: number;
}
type IImagePaintMode = 'normal' | 'cover' | 'fit' | 'stretch' | 'clip' | 'repeat';
type IRepeat = boolean | 'x' | 'y' | IPointData;
type IStrokeAlign = 'inside' | 'outside' | 'center';
type IStrokeCap = 'none' | 'round' | 'square';
type IStrokeJoin = 'bevel' | 'round' | 'miter';
type IArrowType = 'none' | 'angle' | 'angle-side' | 'arrow' | 'triangle' | 'triangle-flip' | 'circle' | 'circle-line' | 'square' | 'square-line' | 'diamond' | 'diamond-line' | 'mark' | (string & {});
type IArrowStyle = IPathDataArrow | IArrowType | IArrowTypeData;
interface IArrowTypeData {
    type: IArrowType;
    scale?: number;
}
interface IPathDataArrowMap {
    [name: string]: IPathDataArrow;
}
interface IPathDataArrow {
    connect?: IPathDataArrowOffset;
    offset?: IPathDataArrowOffset;
    path: IPathCommandData;
    dashPath?: IPathCommandData;
}
interface IPathDataArrowOffset {
    x?: number;
    bevelJoin?: number;
    roundJoin?: number;
}
type ITextAlign = 'left' | 'center' | 'right' | 'justify' | 'justify-letter' | 'both' | 'both-letter';
type IVerticalAlign = 'top' | 'middle' | 'bottom';
type ITextCase = 'upper' | 'lower' | 'title' | 'none' | 'small-caps';
type IFontWeight = IFontWeightNumer | IFontWeightString;
type IFontWeightNumer = 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
type IFontWeightString = 'thin' | 'extra-light' | 'light' | 'normal' | 'medium' | 'semi-bold' | 'bold' | 'extra-bold' | 'black';
type ITextDecoration = ITextDecorationType | ITextDecorationData;
type ITextDecorationType = 'none' | 'under' | 'delete' | 'under-delete';
interface ITextDecorationData {
    type: ITextDecorationType;
    color: IColor;
    offset?: number;
}
type ITextWrap = 'normal' | 'none' | 'break';
type IWritingMode = IAxis | IAxisReverse;
interface IVectorPath {
    rule?: IWindingRule;
    data: string | IPathCommandData;
}
interface IShadowEffect {
    x?: number;
    y?: number;
    blur?: number;
    spread?: number;
    color?: IColorString | IColor;
    blendMode?: IBlendMode;
    visible?: boolean;
    box?: boolean;
    scaleFixed?: IScaleFixed;
    skew?: IPointData;
    scale?: IPointData;
    rotation?: number;
    origin?: IDirection;
}
interface IBlurEffect {
    blur: number;
    visible?: boolean;
}
interface IGrayscaleEffect {
    grayscale: number;
    visible?: boolean;
}
interface IEffect extends IFilter {
}
type IOverflow = 'show' | 'hide' | 'scroll' | 'x-scroll' | 'y-scroll';
type ITextOverflow = 'show' | 'hide' | 'ellipsis' | (string & {});

type ILeafPaintColor = IColorString | CanvasGradient | CanvasPattern;
interface ILeafPaint {
    type?: IPaintType;
    style?: ILeafPaintColor;
    strokeStyle?: IStrokeComputedStyle;
    transform?: IMatrixData;
    image?: ILeaferImage;
    level?: number;
    drawLevel?: number;
    loadId?: number;
    patternId?: string;
    patternTask?: ITaskItem;
    progressTimer?: any;
    isTransparent?: boolean;
    data?: ILeafPaintPatternData;
    originPaint?: IPaint;
}
interface ILeafPaintPatternData {
    scaleX?: number;
    scaleY?: number;
    gap?: IPointData;
    opacity?: number;
    transform?: IMatrixData;
    filters?: IImageFilters;
    mode?: IImagePaintMode;
    repeat?: 'repeat' | 'repeat-x' | 'repeat-y';
    interlace?: IInterlace;
}
type ILeafFill = ILeafPaint;
interface ILeafStrokePaint extends ILeafPaint {
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    miterLimit?: number;
}
interface ILeafShadowEffect {
    x?: number;
    y?: number;
    blur?: number;
    spread?: number;
    color?: IColorString;
    blendMode?: IBlendMode;
    box?: boolean;
    scaleFixed?: IScaleFixed;
    skew?: IPointData;
    scale?: IPointData;
    rotation?: number;
    origin?: IDirection;
}

interface ICornerRadiusAttrData {
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
}
interface ICornerRadiusInputData {
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
}
interface ICornerRadiusComputedData {
    cornerRadius?: number;
    cornerSmoothing?: number;
}
interface IFillAttrData {
    fill?: IFill;
}
interface IFillInputData {
    fill?: IFill;
}
interface IFillComputedData {
    fill?: IColorString | ILeafPaint[];
}
interface IBorderComputedData {
    borderWidth?: number | number[];
    borderRadius?: number | number[];
}
interface IStrokeAttrData extends IStrokeStyle {
    stroke?: IStroke;
    startArrow?: IArrowStyle;
    endArrow?: IArrowStyle;
}
interface IStrokeInputData extends IStrokeStyle {
    stroke?: IStroke;
    startArrow?: IArrowStyle;
    endArrow?: IArrowStyle;
}
interface IStrokeStyle {
    strokeAlign?: IStrokeAlign;
    strokeWidth?: IFourNumber | IStrokeWidthString;
    strokeWidthFixed?: IScaleFixed;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: INumber[] | IDashPatternString;
    dashOffset?: INumber;
    miterLimit?: INumber;
}
interface IStrokeComputedData extends IStrokeComputedStyle {
    stroke?: IColorString | ILeafStrokePaint[];
    startArrow?: IArrowStyle;
    endArrow?: IArrowStyle;
}
interface IStrokeComputedStyle {
    strokeAlign?: IStrokeAlign;
    strokeWidth?: number;
    strokeWidths?: number[];
    strokeWidthFixed?: IScaleFixed;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: number[];
    dashOffset?: number;
    miterLimit?: number;
}
interface ITextStyleAttrData {
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    writingMode?: IWritingMode;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: ITextOverflow;
}
interface ITextStyleInputData {
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    writingMode?: IWritingMode;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: ITextOverflow;
}
interface ITextStyleComputedData {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: IFontWeight;
    italic?: boolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: number;
    lineHeight?: number;
    paraIndent?: number;
    paraSpacing?: number;
    writingMode?: IWritingMode;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: boolean;
    textWrap?: ITextWrap;
    textOverflow?: ITextOverflow;
}
interface IEffectAttrData {
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
}
interface IEffectInputData {
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
}
interface IEffectComputedData {
    shadow?: ILeafShadowEffect[];
    innerShadow?: ILeafShadowEffect[];
    blur?: number;
    backgroundBlur?: number;
    grayscale?: number;
}

type IAnimation = IStyleAnimation | IKeyframesAnimation;
type IAnimateType = 'all' | 'animation' | 'transition' | 'animate';
interface IStyleAnimation extends IAnimateOptions {
    style: IUIInputData;
}
interface IKeyframesAnimation extends IAnimateOptions {
    keyframes: IKeyframe[];
}
type IKeyframe = IUIInputData | IAnimateKeyframe;
type IKeyframeId = number;
interface IAnimateKeyframe {
    style: IUIInputData;
    easing?: IAnimateEasing;
    delay?: number;
    duration?: number;
    swing?: number;
    loop?: number;
    autoDelay?: number;
    autoDuration?: number;
}
interface IComputedKeyframe {
    style: IUIInputData;
    beforeStyle: IUIInputData;
    betweenStyle?: IUIInputData;
    easingFn?: IAnimateEasingFunction;
    delay?: number;
    duration?: number;
    swing?: number;
    loop?: number;
    autoDelay?: number;
    autoDuration?: number;
    totalTime?: number;
}
interface IAnimate extends IAnimateOptions, IEventer {
    target: IUI | IObject;
    parent?: IAnimateList;
    keyframes: IKeyframe[];
    config?: IAnimateOptions;
    event?: IEventParamsMap;
    readonly frames: IComputedKeyframe[];
    readonly style: IUIInputData;
    readonly fromStyle: IUIInputData;
    readonly toStyle: IUIInputData;
    readonly endingStyle: IUIInputData;
    readonly started: boolean;
    readonly running: boolean;
    readonly completed: boolean;
    readonly destroyed: boolean;
    readonly time: number;
    readonly looped: number;
    readonly realEnding: IAnimateEnding;
    init(target: IUI | IObject, keyframe: IUIInputData | IKeyframe[], options?: ITransition, isTemp?: boolean): void;
    play(): void;
    pause(): void;
    stop(): void;
    seek(time: number | IPercentData, includeDelay?: boolean): void;
    kill(complete?: boolean, killStyle?: IUIInputData): void;
    destroy(complete?: boolean): void;
}
interface IAnimateList extends IAnimate {
    list: IAnimate[];
    updateList(animation?: IAnimation[] | IAnimate[], isTemp?: boolean): void;
    onChildEvent(type: string, _animate: IAnimate): void;
}

interface IEditorBase extends IGroup$1, ISelectorProxy, ITransformTool {
    config: IEditorConfig;
    readonly mergeConfig: IEditorConfig;
    readonly mergedConfig: IEditorConfig;
    target?: IUI$1 | IUI$1[];
    hoverTarget?: IUI$1;
    dimTarget?: IGroup$1 | IGroup$1[];
    readonly list: IUI$1[];
    leafList: ILeafList;
    openedGroupList: ILeafList;
    readonly editing: boolean;
    innerEditing: boolean;
    readonly groupOpening: boolean;
    readonly multiple: boolean;
    readonly single: boolean;
    readonly dragPoint: IEditPoint;
    readonly dragging: boolean;
    readonly gesturing: boolean;
    readonly moving: boolean;
    readonly resizing: boolean;
    readonly rotating: boolean;
    readonly skewing: boolean;
    element?: IUI$1;
    buttons: IGroup$1;
    selector: IGroup$1;
    editBox: IEditBoxBase;
    editTool?: IObject$1;
    innerEditor?: IObject$1;
    editMask: IUI$1;
    readonly targetLeafer: ILeafer$1;
    select(target: IUI$1 | IUI$1[]): void;
    cancel(): void;
    hasItem(item: IUI$1): boolean;
    getItem(index?: number): IUI$1;
    shiftItem(item: IUI$1): void;
    addItem(item: IUI$1): void;
    removeItem(item: IUI$1): void;
    setDimOthers(value: boolean | number): void;
    setBright(value: boolean): void;
    update(): void;
    updateEditBox(): void;
    getEditTool(name: string): IObject$1;
    updateEditTool(): void;
    unloadEditTool(): void;
    getEditSize(ui: ILeaf): IEditSize;
    group(group?: IGroup$1 | IGroupInputData$1): IGroup$1;
    ungroup(): IUI$1[];
    openGroup(group: IGroup$1): void;
    closeGroup(group: IGroup$1): void;
    getInnerEditor(name: string): IObject$1;
    openInnerEditor(target?: IUI$1, nameOrSelect?: string | boolean, select?: boolean): void;
    closeInnerEditor(onlyInnerEditor?: boolean): void;
    lock(): void;
    unlock(): void;
    toTop(): void;
    toBottom(): void;
}
interface ITransformTool {
    editBox: IEditBoxBase;
    editTool?: IObject$1;
    onMove(e: IDragEvent | IMoveEvent): void;
    onScale(e: IDragEvent | IZoomEvent): void;
    onRotate(e: IDragEvent | IRotateEvent): void;
    onSkew(e: IDragEvent): void;
    move(x: number | IPointData$1, y?: number, transition?: ITransition$1): void;
    scaleOf(origin: IPointData$1 | IAlign$1, scaleX: number, scaleY?: number | ITransition$1, resize?: boolean, transition?: ITransition$1): void;
    rotateOf(origin: IPointData$1 | IAlign$1, rotation: number, transition?: ITransition$1): void;
    skewOf(origin: IPointData$1 | IAlign$1, skewX: number, skewY?: number, resize?: boolean, transition?: ITransition$1): void;
}
interface IEditorConfig extends IObject$1 {
    editSize?: IEditSize;
    keyEvent?: boolean;
    stroke?: IStroke$1;
    strokeWidth?: number;
    spread?: IFourNumber$1;
    pointFill?: IFill$1;
    pointSize?: number;
    pointRadius?: number;
    point?: IEditPointInputData | IEditPointInputData[];
    middlePoint?: IEditPointInputData | IEditPointInputData[];
    resizeLine?: IEditPointInputData | IEditPointInputData[];
    rect?: IBoxInputData$1;
    rectThrough?: boolean;
    area?: IRectInputData$1;
    mask?: boolean | IColorString$1;
    dimOthers?: boolean | number;
    bright?: boolean;
    circle?: IEditPointInputData;
    circleDirection?: IDirection4;
    circleMargin?: number;
    rotatePoint?: IEditPointInputData;
    buttonsDirection?: IDirection4;
    buttonsFixed?: boolean | 'AABB' | 'OBB';
    buttonsMargin?: number;
    hideOnMove?: boolean;
    hideOnSmall?: boolean | number;
    hideRotatePoints?: boolean;
    hideResizeLines?: boolean;
    moveCursor?: ICursorType;
    resizeCursor?: IImageCursor;
    rotateCursor?: IImageCursor;
    skewCursor?: IImageCursor;
    around?: IAlign$1 | IUnitPointData$1;
    rotateAround?: IAlign$1 | IUnitPointData$1;
    rotateGap?: number;
    lockRatio?: boolean | 'corner';
    dragLimitAnimate?: boolean | number;
    ignorePixelSnap?: boolean;
    selector?: boolean;
    editBox?: boolean;
    hover?: boolean;
    hoverStyle?: IUIInputData$1;
    select?: 'press' | 'tap';
    selectKeep?: boolean;
    selectedStyle?: IUIInputData$1;
    selectedPathType?: 'path' | 'render-path';
    multipleSelect?: boolean;
    boxSelect?: boolean;
    continuousSelect?: boolean;
    openInner?: 'double' | 'long';
    moveable?: boolean | 'gesture' | 'move';
    resizeable?: boolean | 'gesture' | 'zoom';
    flipable?: boolean;
    rotateable?: boolean | 'gesture' | 'rotate';
    skewable?: boolean;
    multipleSelectKey?: IShortcutKeysCheck | IShortcutKeys;
    rotateKey?: IShortcutKeysCheck | IShortcutKeys;
    diagonalRotateKey?: IShortcutKeysCheck | IShortcutKeys;
    beforeSelect?: IEditorBeforeSelect;
    beforeEditOuter?: IEditorBeforeEditOuter;
    beforeEditInner?: IEditorBeforeEditInner;
    beforeMove?: IEditorBeforeMove;
    beforeScale?: IEditorBeforeScale;
    beforeRotate?: IEditorBeforeRotate;
    beforeSkew?: IEditorBeforeSkew;
    preventEditInner?: boolean;
    textEditor?: IObject$1;
    pathEditor?: IObject$1;
}
interface IEditorSelectData {
    target: IUI$1 | IUI$1[];
}
interface IEditorEditOuterData {
    target: IUI$1;
    name: string;
}
type IEditorEditInnerData = IEditorEditOuterData;
interface IEditorMoveData extends IPointData$1, IObject$1 {
    target: IUI$1;
}
interface IEditorScaleData extends IScaleData, IObject$1 {
    target: IUI$1;
    origin: IPointData$1 | IAlign$1;
}
interface IEditorRotationData extends IObject$1 {
    target: IUI$1;
    origin: IPointData$1 | IAlign$1;
    rotation: number;
}
interface IEditorSkewData extends ISkewData, IObject$1 {
    target: IUI$1;
    origin: IPointData$1 | IAlign$1;
}
interface IEditorBeforeSelect {
    (data: IEditorSelectData): IUI$1 | IUI$1[] | boolean | void;
}
interface IEditorBeforeEditOuter {
    (data: IEditorEditOuterData): string | boolean | void;
}
interface IEditorBeforeEditInner {
    (data: IEditorEditInnerData): string | boolean | void;
}
interface IEditorBeforeMove {
    (data: IEditorMoveData): IPointData$1 | boolean | void;
}
interface IEditorBeforeScale {
    (data: IEditorScaleData): IScaleData | boolean | void;
}
interface IEditorBeforeRotate {
    (data: IEditorRotationData): number | boolean | void;
}
interface IEditorBeforeSkew {
    (data: IEditorSkewData): ISkewData | boolean | void;
}
interface IEditPointInputData extends IBoxInputData$1 {
    direction?: number;
    pointType?: IEditPointType;
}
interface IEditPoint extends IBox$1 {
    direction: number;
    pointType: IEditPointType;
}
type IEditPointType = 'move' | 'resize' | 'rotate' | 'skew' | 'resize-rotate' | 'button';
interface IEditBoxBase extends IGroup$1 {
    editor: IEditorBase;
    dragging: boolean;
    gesturing: boolean;
    moving: boolean;
    resizing: boolean;
    rotating: boolean;
    skewing: boolean;
    view: IGroup$1;
    circle: IEditPoint;
    rect: IEditPoint;
    buttons: IGroup$1;
    resizePoints: IEditPoint[];
    rotatePoints: IEditPoint[];
    resizeLines: IEditPoint[];
    enterPoint: IEditPoint;
    dragPoint: IEditPoint;
    dragStartData: IEditorDragStartData;
    config: IEditorConfig;
    readonly mergeConfig: IEditorConfig;
    readonly mergedConfig: IEditorConfig;
    target: IUI$1;
    single: boolean;
    transformTool: ITransformTool;
    readonly flipped: boolean;
    readonly flippedX: boolean;
    readonly flippedY: boolean;
    readonly flippedOne: boolean;
    readonly canUse: boolean;
    readonly canGesture: boolean;
    getPointStyle(userStyle?: IBoxInputData$1): IBoxInputData$1;
    getPointsStyle(): IBoxInputData$1[];
    getMiddlePointsStyle(): IBoxInputData$1[];
    load(): void;
    update(): void;
    unload(): void;
    onArrow(e: IKeyEvent): void;
    isHoldRotateKey(e: IUIEvent): boolean;
}
interface IEditorDragStartData {
    x: number;
    y: number;
    totalOffset: IPointData$1;
    point: IPointData$1;
    bounds: ILayoutBoundsData;
    rotation: number;
}
interface IEditorConfigFunction {
    (ui: any): IEditorConfig;
}
interface IEditToolFunction {
    (ui: any): string;
}

interface IScrollConfig {
    theme?: IScrollTheme;
    style?: IBoxInputData;
    size?: number;
    cornerRadius?: number;
    endsMargin?: number;
    sideMargin?: number;
    minSize?: number;
    scaleFixed?: IScaleFixed;
    scrollType?: 'drag' | 'move' | 'both';
    stopDefault?: boolean;
    hideOnActionEnd?: boolean | 'hover' | 'scroll';
}
type IScrollTheme = 'light' | 'dark' | (string & {});
interface IScroller extends IGroup {
    config: IScrollConfig;
    mergedConfig: IScrollConfig;
    scrollXBar: IBox;
    scrollYBar: IBox;
    scrollXBounds: IBounds;
    scrollYBounds: IBounds;
    scrollRatioX: number;
    scrollRatioY: number;
    ratioX: number;
    ratioY: number;
    dragScrolling: boolean;
    updateConfig(): void;
    update(check?: boolean): void;
}

interface ILine extends ILineAttrData, IUI {
    __: ILineData;
}
interface ILineAttrData {
    toPoint?: IPointData;
    points?: number[] | IPointData[];
    curve?: boolean | number;
}
interface ILineData extends ILineAttrData, IUIData {
}
interface ILineInputData extends ILineAttrData, IUIBaseInputData {
}
interface IArrow extends ILine {
    __: IArrowData;
}
interface IArrowAttrData {
}
interface IArrowData extends IArrowAttrData, ILineData {
}
interface IArrowInputData extends IArrowAttrData, ILineInputData {
}
interface ILinker extends IArrow {
    __: ILinkerData;
}
interface ILinkerPointData {
    id: string | IUI;
    point?: IAround;
}
interface ILinkerAttrData {
    startPoint?: ILinkerPointData | IUI | string;
    endPoint?: ILinkerPointData | IUI | string;
}
interface ILinkerData extends ILinkerAttrData, IArrowData {
}
interface ILinkerInputData extends ILinkerAttrData, IArrowInputData {
}
interface IFlow extends IBox {
    __: IFlowData;
}
interface IFlowAttrData {
}
interface IFlowData extends IFlowAttrData, IBoxData {
}
interface IFlowInputData extends IFlowAttrData, IBoxInputData {
}
interface IVideo extends IPlayerMethods, IRect {
    __: IVideoData;
}
interface IPlayerMethods {
    play(): void;
    pause(): void;
    stop(): void;
}
interface IVideoAttrData {
    url?: string;
}
interface IVideoData extends IVideoAttrData, IRectData {
}
interface IVideoInputData extends IVideoAttrData, IRectInputData {
}
interface IGIF extends IPlayerMethods, IRect {
    __: IGIFData;
}
interface IGIFAttrData {
    url?: string;
}
interface IGIFData extends IGIFAttrData, IRectData {
}
interface IGIFInputData extends IGIFAttrData, IRectInputData {
}
interface IRobot extends IRobotAttrData, IPlayerMethods, IRect {
    __: IRobotData;
    readonly running: boolean;
    readonly nowFrame?: IRobotComputedKeyframe;
    readonly robotFrames?: IRobotComputedKeyframe[];
    __updateRobot(): void;
    __updateAction(): void;
}
interface IRobotAttrData {
    robot?: IRobotKeyframe | IRobotKeyframe[];
    actions?: IRobotActions;
    action?: IRobotActionName;
    now?: number;
    FPS?: number;
    loop?: boolean | number;
}
interface IRobotActions {
    [name: string]: IKeyframeId | IKeyframeId[] | IRobotAnimation;
}
interface IRobotAnimation {
    keyframes: IKeyframeId[];
    loop?: boolean | number;
    FPS?: number;
}
type IRobotActionName = string;
interface IRobotKeyframe {
    mode?: 'normal' | 'clip';
    url: string;
    offset?: IPointData;
    size?: number | ISizeData;
    total?: number;
}
interface IRobotComputedKeyframe extends IBoundsData {
    view: any;
}
interface IRobotData extends IRobotAttrData, IRectData {
}
interface IRobotInputData extends IRobotAttrData, IRectInputData {
}
interface IRect extends IUI {
    __: IRectData;
}
interface IRectData extends IUIData {
}
interface IRectInputData extends IUIBaseInputData {
}
interface IEllipse extends IUI, IEllipseAttrData {
    __: IEllipseData;
}
interface IEllipseAttrData {
    startAngle?: number;
    endAngle?: number;
    innerRadius?: number;
}
interface IEllipseData extends IEllipseAttrData, IUIData {
}
interface IEllipseInputData extends IEllipseAttrData, IUIBaseInputData {
}
interface IPolygon extends IPolygonAttrData, IUI {
    __: IPolygonData;
}
interface IPolygonAttrData {
    sides?: number;
    points?: number[] | IPointData[];
    curve?: boolean | number;
}
interface IPolygonData extends IPolygonAttrData, IUIData {
}
interface IPolygonInputData extends IPolygonAttrData, IUIBaseInputData {
}
interface IStar extends IStarAttrData, IUI {
    __: IStarData;
}
interface IStarAttrData {
    corners?: number;
    innerRadius?: number;
}
interface IStarData extends IStarAttrData, IUIData {
}
interface IStarInputData extends IStarAttrData, IUIBaseInputData {
}
interface IPath extends IUI {
    __: IPathData;
}
interface IPathData extends IUIData {
}
interface IPathInputData extends IUIBaseInputData {
}
interface IPen extends IGroup, IPathCreator {
    __: IPenData;
    pathElement: IPath;
    pathStyle: IPathInputData;
    path: IPathCommandData;
    paint(): void;
}
interface IPenData extends IGroupData {
}
interface IPenInputData extends IGroupInputData {
}
interface IText extends ITextAttrData, ITextStyleAttrData, IUI {
    __: ITextData;
}
interface ITextAttrData {
    text?: string | number;
    placeholder?: string;
    padding?: IFourNumber;
    resizeFontSize?: boolean;
    boxStyle?: IBackgroundBoxStyle;
    textEditing?: boolean;
}
interface IBackgroundBoxStyle extends IRectInputData {
}
interface ITextData extends ITextAttrData, ITextStyleComputedData, IUIData {
    __baseLine?: number;
    __lineHeight?: number;
    __letterSpacing?: number;
    __padding?: number[];
    __clipText?: boolean;
    __isCharMode?: boolean;
    __isPlacehold?: boolean;
    __textBoxBounds?: IBoundsData;
}
interface ITextInputData extends ITextAttrData, ITextStyleInputData, IUIBaseInputData {
}
interface ITextRowData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    text?: string;
    data?: ITextCharData[];
    words?: ITextWordData[];
    startCharSize?: number;
    endCharSize?: number;
    paraStart?: boolean;
    paraEnd?: boolean;
    isOverflow?: boolean;
    textMode?: boolean;
}
interface ITextWordData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    data?: ITextCharData[];
}
interface ITextCharData {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    char?: string;
}
interface ITextDrawData {
    bounds: IBoundsData;
    rows: ITextRowData[];
    paraNumber: number;
    font: string;
    maxWidth?: number;
    decorationY?: number[];
    decorationColor?: string;
    decorationHeight?: number;
    overflow?: number;
}
interface IImage extends IImageAttrData, IRect {
    __: IImageData;
    readonly ready: boolean;
    readonly image?: ILeaferImage;
}
interface IImageAttrData {
    url?: string;
}
interface IImageData extends IImageAttrData, IRectData {
    __setImageFill(value: string): void;
}
interface IImageInputData extends IImageAttrData, IUIBaseInputData {
}
interface ICanvas extends ICanvasAttrData, IRect {
    __: ICanvasData;
    canvas?: ILeaferCanvas;
    readonly context?: ICanvasContext2D;
    __updateSize(): void;
}
interface ICanvasAttrData {
    smooth?: boolean;
    safeResize?: boolean;
    contextSettings?: ICanvasContext2DSettings;
    url?: string;
}
interface ICanvasData extends ICanvasAttrData, IRectData {
}
interface ICanvasInputData extends ICanvasAttrData, IUIBaseInputData {
}
interface ILeaferData extends IGroupData {
}
interface ILeaferInputData extends IGroupInputData {
}
interface IAppData extends ILeaferData {
}
interface IAppInputData extends ILeaferInputData {
}
interface IFrame extends IBox {
    __: IFrameData;
}
interface IFrameData extends IBoxData {
}
interface IFrameInputData extends IBoxInputData {
}
interface IBox extends IBoxAttrData, IGroup {
    __: IBoxData;
    scroller?: IScroller;
    hasScroller?: boolean;
    __checkScroll(isScrollMode: boolean): void;
    __updateRectRenderBounds(): void;
    __renderGroup(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
interface IBoxAttrData {
    overflow?: IOverflow;
    scrollConfig?: IScrollConfig;
    resizeChildren?: IBoolean;
    textBox?: IBoolean;
}
interface IBoxData extends IBoxAttrData, IGroupData {
}
interface IBoxInputData extends IBoxAttrData, IGroupInputData {
}
interface IGroup extends IUI {
    __: IGroupData;
    children: IUI[];
    childlessJSON?: boolean;
    pick(hitPoint: IPointData, options?: IPickOptions): IPickResult;
    add(child: IUI | IUI[] | IUIInputData | IUIInputData[], index?: number): void;
    addAt(child: IUI | IUI[] | IUIInputData | IUIInputData[], index: number): void;
    addAfter(child: IUI | IUI[] | IUIInputData | IUIInputData[], after: IUI): void;
    addBefore(child: IUI | IUI[] | IUIInputData | IUIInputData[], before: IUI): void;
    addMany(...children: ILeaf$1[] | IUIInputData[]): void;
    remove(child?: IUI | number | string | IFindCondition | IFindUIMethod): void;
    removeAll(): void;
    clear(): void;
}
interface IGroupData extends IUIData {
}
interface IGroupInputData extends IUIBaseInputData {
}
interface IUI extends IUIAttrData, IFillAttrData, IStrokeAttrData, ICornerRadiusAttrData, IEffectAttrData, ILeaf$1 {
    __: IUIData;
    readonly app: ILeafer;
    leafer?: ILeafer;
    parent?: IGroup;
    zoomLayer?: IGroup;
    readonly isFrame?: boolean;
    isOverflow?: boolean;
    useFastShadow?: boolean;
    proxyData?: IUIInputData;
    __proxyData?: IUIInputData;
    animation?: IAnimation | IAnimation[];
    animationOut?: IAnimation | IAnimation[];
    children?: IUI[];
    __box?: IUI;
    __animate?: IAnimate;
    readonly pen: IPathCreator;
    reset(data?: IUIInputData): void;
    set(data: IUIInputData, transition?: ITransition | 'temp'): void;
    toJSON(options?: IJSONOptions): IUIJSONData;
    get<K extends keyof this>(name: K): this[K];
    get<K extends keyof this>(name?: K[] | IUIInputData): IUIInputData;
    createProxyData(): IUIInputData;
    find(condition: number | string | IFindCondition | IFindUIMethod, options?: any): IUI[];
    findTag(tag: string | string[]): IUI[];
    findOne(condition: number | string | IFindCondition | IFindUIMethod, options?: any): IUI | undefined;
    findId(id: number | string): IUI | undefined;
    getPath(curve?: boolean, pathForRender?: boolean): IPathCommandData;
    getPathString(curve?: boolean, pathForRender?: boolean): IPathString;
    load(): void;
    __drawPathByData(drawer: IPathDrawer, data: IPathCommandData, ignoreCornerRadius?: boolean): void;
    __drawPathByBox(drawer: IPathDrawer, ignoreCornerRadius?: boolean): void;
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    drawImagePlaceholder(image: ILeafPaint, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    animate(keyframe?: IUIInputData | IKeyframe[] | IAnimation | IAnimation[], options?: ITransition, type?: IAnimateType, isTemp?: boolean): IAnimate;
    killAnimate(type?: IAnimateType, nextStyle?: IUIInputData): void;
    export(filename: string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
    syncExport(filename: string, options?: IExportOptions | number | boolean): IExportResult;
    clone(data?: IUIInputData): IUI;
}
interface IStateStyle extends IUIInputData {
}
interface IStates {
    [name: string]: IStateStyle;
}
type IStateName = string;
interface IUIAttrData {
    animation?: IAnimation | IAnimation[];
    animationOut?: IAnimation | IAnimation[];
    transition?: ITransition;
    transitionOut?: ITransition;
    states?: IStates;
    state?: IStateName;
    hoverStyle?: IStateStyle;
    pressStyle?: IStateStyle;
    focusStyle?: IStateStyle;
    selectedStyle?: IStateStyle;
    disabledStyle?: IStateStyle;
    placeholderStyle?: IStateStyle;
    placeholderColor?: IColorString;
    placeholderDelay?: number;
    editConfig?: IEditorConfig;
    editOuter?: string;
    editInner?: string;
}
interface IFindUIMethod {
    (leaf: IUI, options?: any): IAnswer;
}
interface IUIData extends IUIAttrData, IUIComputedData, ILeafData {
    readonly scale: number | IPointData;
    __isFills?: boolean;
    __isStrokes?: boolean;
    readonly __strokeWidth: number;
    readonly __maxStrokeWidth: number;
    __hasMultiStrokeStyle?: number;
    readonly __hasMultiPaint?: boolean;
    __isAlphaPixelFill?: boolean;
    __isAlphaPixelStroke?: boolean;
    __isTransparentFill?: boolean;
    __isTransparentStroke?: boolean;
    __isHitPixel?: boolean;
    __isCanvas?: boolean;
    __isFastShadow?: boolean;
    __fillAfterStroke?: boolean;
    __drawAfterFill?: boolean;
    readonly __clipAfterFill?: boolean;
    readonly __hasSurface?: boolean;
    __blendLayer?: boolean;
    __boxStroke?: boolean;
    __font?: string;
    __textDrawData?: ITextDrawData;
    __needComputePaint?: boolean;
    __computePaint(): void;
    __getRealStrokeWidth(childStyle?: IStrokeComputedStyle): number;
    __setPaint(attrName: 'fill' | 'stroke', value: IValue): void;
    __removePaint(attrName: 'fill' | 'stroke', removeInput?: boolean): void;
}
interface IUIComputedData extends IUIAttrData, IFillComputedData, IBorderComputedData, IStrokeComputedData, ITextStyleComputedData, ICornerRadiusComputedData, IEffectComputedData, ILeafComputedData {
}
interface IUIBaseInputData extends IUIAttrData, IFillInputData, IStrokeInputData, ITextStyleInputData, ICornerRadiusInputData, IEffectInputData, ILeafInputData {
    children?: IUIInputData[];
}
type IUITag = 'App' | 'Leafer' | 'Rect' | 'Ellipse' | 'Polygon' | 'Star' | 'Line' | 'Path' | 'Pen' | 'Text' | 'Image' | 'Canvas' | 'Group' | 'Frame' | 'Box' | 'Arrow' | 'Robot' | 'GIF' | 'Video';
interface IUIInputData extends IRectInputData, IEllipseInputData, IPolygonInputData, IStarInputData, ILineInputData, IPathInputData, ITextInputData, IImageInputData, IGroupInputData, IBoxInputData, IFrameInputData, IFlowInputData, IArrowInputData, IGIFInputData, IVideoInputData, IRobotInputData, IUIBaseInputData, IObject {
    children?: IUIInputData[];
}
interface IUIJSONData extends IUIInputData {
    matrix?: IMatrixData;
}

interface ILeafer extends IGroup, ILeaferAttrData, IControl {
    readonly isApp: boolean;
    readonly app: ILeafer;
    parentApp?: IApp;
    parent?: IApp;
    zoomLayer: IGroup;
    editor: IEditorBase;
    ground?: ILeafer;
    tree?: ILeafer;
    sky?: ILeafer;
    onInit(): void;
    initType(type: ILeaferType): void;
    destroy(sync?: boolean): void;
}

interface IApp extends ILeafer {
    children: ILeafer[];
    realCanvas: boolean;
    forEach(fn: IAppForEachFunction): void;
}
interface IAppConfig extends ILeaferConfig {
    ground?: ILeaferConfig;
    tree?: ILeaferConfig;
    sky?: ILeaferConfig;
    editor?: IEditorConfig;
}
interface IAppForEachFunction {
    (value: ILeafer, index: number, array: ILeafer[]): void;
}

type IUIRenderModule = IUIRender & ThisType<IUI>;
interface IUIRender extends ILeafRender {
    __drawAfterFill?(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent?(canvas: ILeaferCanvas, options: IRenderOptions): void;
}
type IRectRenderModule = IRectRender & ThisType<IRect>;
interface IRectRender extends IUIRender {
}
type IImageRenderModule = IImageRender & ThisType<IImage>;
interface IImageRender extends IUIRender {
}
type ITextRenderModule = ITextRender & ThisType<IText>;
interface ITextRender extends IUIRender {
}
type IGroupRenderModule = IGroupRender & ThisType<IGroup>;
interface IGroupRender extends IUIRender {
}
type IFrameRenderModule = IFrameRender & ThisType<IFrame>;
interface IFrameRender extends IGroupRender {
}

type IUIBoundsModule = IUIBounds & ThisType<IUI>;
interface IUIBounds extends ILeafBounds {
}

type IUIHitModule = ILeafHit & ThisType<IUI>;

interface IPathArrowModule {
    list: IPathDataArrowMap;
    addArrows(ui: IUI): void;
    register(name: string, data: IPathDataArrow): void;
    get(name: string): IPathDataArrow;
}

interface ITransitionModule {
    list: ITransitionMap;
    register(attrName: string, fn: ITransitionFunction): void;
    get(attrName: string): ITransitionFunction;
    setBetweenStyle(betweenStyle: IObject, fromStyle: IObject, toStyle: IObject, bothStyle: IObject, t: number, target: any, attrs?: IObject): void;
    value(from: any, to: any, t: number, target?: IObject): any;
    number(from: number, to: number, t: number, roundValue?: number): number;
    color(from: IColor, to: IColor, t: number): string;
    gradient(from: IGradientPaint, to: IGradientPaint, t: number, target: IObject): IGradientPaint;
}
interface ITransitionMap {
    [name: string]: ITransitionFunction;
}
interface ITransitionFunction {
    (from: any, to: any, t: number, target?: any): any;
}

interface ITextConvertModule {
    getDrawData(content: string | number, style: ITextData): ITextDrawData;
}

interface IColorConvertModule {
    string(color: IColor, opacity?: number): string;
    object(color: IColor, opacity?: number): IRGBA;
    hasTransparent(color: string): boolean;
}

interface IExportModule {
    running?: boolean;
    export(leaf: ILeaf$1, filename: IExportFileType | string, options?: IExportOptions | number | boolean): Promise<IExportResult>;
    syncExport(leaf: ILeaf$1, filename: string, options?: IExportOptions | number | boolean): IExportResult;
}

interface IStateModule {
    canAnimate: boolean;
    animateExcludes: IObject$1;
    isState(state: IStateName$1, leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isSelected(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isDisabled(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isFocus(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isHover(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isPress(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isPlacehold(leaf: ILeaf, button?: ILeaf | boolean): boolean;
    isDrag(leaf: ILeaf, button?: boolean | ILeaf): boolean;
    setStyleName(leaf: ILeaf, styleName: IString$1, value: IBoolean$1): void;
    set(leaf: ILeaf, stateName: IString$1): void;
    getStyle(leaf: ILeaf): IStateStyle$1;
    updateStyle(leaf: ILeaf, style?: IStateStyle$1, type?: 'in' | 'out'): void;
    updateEventStyle(leaf: ILeaf, eventType: string): void;
}

interface ICachedShape extends ICachedLeaf {
    worldCanvas?: ILeaferCanvas;
    shapeBounds: IBoundsData;
    renderBounds: IBoundsData;
    scaleX: number;
    scaleY: number;
}

interface IPaintModule {
    compute(attrName: IPaintAttr, ui: IUI): void;
    fill(fill: string, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    fills(fills: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    fillPathOrText(ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    fillText(ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    stroke(stroke: string, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokes(strokes: ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokeText(stroke: string | ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    strokeArrow?(stroke: string | ILeafPaint[], ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    drawStrokesStyle(strokes: ILeafStrokePaint[], strokeWidthScale: number, isText: boolean, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    drawTextStroke(ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    shape(ui: IUI, current: ILeaferCanvas, renderOptions: IRenderOptions): ICachedShape;
}
interface IPaintImageModule {
    image(ui: IUI, attrName: string, paint: IImagePaint, boxBounds: IBoundsData, firstUse: boolean): ILeafPaint;
    checkImage(paint: ILeafPaint, allowDraw: boolean, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): boolean;
    drawImage(paint: ILeafPaint, imageScaleX: number, imageScaleY: number, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    getImageRenderScaleData(paint: ILeafPaint, ui: IUI, canvas?: ILeaferCanvas, renderOptions?: IRenderOptions): IScaleData$1;
    recycleImage(attrName: IPaintAttr, data: IUIData): IBooleanMap;
    createPatternTask(paint: ILeafPaint, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    createPattern(paint: ILeafPaint, ui: IUI, canvas: ILeaferCanvas, renderOptions: IRenderOptions, resolve?: IFunction, task?: ITaskItem): void;
    getPatternFixScale(paint: ILeafPaint, imageScaleX: number, imageScaleY: number): number;
    createData(leafPaint: ILeafPaint, image: ILeaferImage, paint: IImagePaint, box: IBoundsData): void;
    getPatternData(paint: IImagePaint, box: IBoundsData, image: ILeaferImage): ILeafPaintPatternData;
    stretchMode(data: ILeafPaintPatternData, box: IBoundsData, scaleX: number, scaleY: number): void;
    fillOrFitMode(data: ILeafPaintPatternData, box: IBoundsData, x: number, y: number, scaleX: number, scaleY: number, rotation: number): void;
    clipMode(data: ILeafPaintPatternData, box: IBoundsData, x: number, y: number, scaleX: number, scaleY: number, rotation: number, skew: IPointData, clipScaleX?: number, clipScaleY?: number): void;
    repeatMode(data: ILeafPaintPatternData, box: IBoundsData, width: number, height: number, x: number, y: number, scaleX: number, scaleY: number, rotation: number, skew: IPointData, align: IAlign, freeTransform?: boolean): void;
}
interface IPaintGradientModule {
    linearGradient(paint: IGradientPaint, box: IBoundsData): ILeafPaint;
    radialGradient(paint: IGradientPaint, box: IBoundsData): ILeafPaint;
    conicGradient(paint: IGradientPaint, box: IBoundsData): ILeafPaint;
    getTransform(box: IBoundsData, from: IPointData, to: IPointData, stretch: number, rotate90: boolean): IMatrixData;
}

interface IEffectModule {
    shadow(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
    innerShadow(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
    blur(ui: IUI, current: ILeaferCanvas, origin: ILeaferCanvas): void;
    backgroundBlur(ui: IUI, current: ILeaferCanvas, shape: ICachedShape): void;
    getShadowRenderSpread(ui: IUI, shadow: ILeafShadowEffect[], spreadSign?: 1 | -1): IFourNumber;
    getShadowTransform(ui: IUI, canvas: ILeaferCanvas, shape: ICachedShape, shadow: ILeafShadowEffect, outBounds: IBoundsData, otherScale: number, isInnerShaodw?: boolean): IMatrixData;
    isTransformShadow(shadow: ILeafShadowEffect): boolean;
    getInnerShadowSpread(ui: IUI, innerShadow: ILeafShadowEffect[]): IFourNumber;
}

interface IFilterModule {
    list: IFilterProcessorMap;
    register(name: string, filterProcessor: IFilterProcessor): void;
    apply(filters: IFilter[], ui: IUI, bounds: IMatrixWithBoundsScaleData, currentCanvas: ILeaferCanvas, originCanvas: ILeaferCanvas, shape: ICachedShape): void;
    getSpread(filters: IFilter[]): number;
}
interface IFilterProcessorMap {
    [name: string]: IFilterProcessor;
}
interface IFilterProcessor {
    apply: IFilterFunction;
    getSpread(filter: IFilter): number;
}
interface IFilterFunction {
    (filter: IFilter, ui: IUI, bounds: IMatrixWithBoundsScaleData, currentCanvas: ILeaferCanvas, originCanvas: ILeaferCanvas, shape: ICachedShape): void;
}

export type { IAnimate, IAnimateKeyframe, IAnimateList, IAnimateType, IAnimation, IApp, IAppConfig, IAppData, IAppForEachFunction, IAppInputData, IArrow, IArrowData, IArrowInputData, IArrowStyle, IArrowType, IArrowTypeData, IBackgroundBoxStyle, IBlurEffect, IBox, IBoxData, IBoxInputData, ICachedShape, ICanvas, ICanvasData, ICanvasInputData, IColor, IColorConvertModule, IColorStop, IColorString, IComputedKeyframe, ICornerRadiusString, IDashPatternString, IEditBoxBase, IEditPoint, IEditPointInputData, IEditPointType, IEditToolFunction, IEditorBase, IEditorBeforeEditInner, IEditorBeforeEditOuter, IEditorBeforeMove, IEditorBeforeRotate, IEditorBeforeScale, IEditorBeforeSelect, IEditorBeforeSkew, IEditorConfig, IEditorConfigFunction, IEditorDragStartData, IEditorEditInnerData, IEditorEditOuterData, IEditorMoveData, IEditorRotationData, IEditorScaleData, IEditorSelectData, IEditorSkewData, IEffect, IEffectAttrData, IEffectComputedData, IEffectInputData, IEffectModule, IEllipse, IEllipseData, IEllipseInputData, IExportModule, IFill, IFilterFunction, IFilterModule, IFilterProcessor, IFindUIMethod, IFlow, IFlowData, IFlowInputData, IFontWeight, IFontWeightNumer, IFontWeightString, IFrame, IFrameData, IFrameInputData, IFrameRenderModule, IGIF, IGIFData, IGIFInputData, IGradientPaint, IGradientType, IGrayscaleEffect, IGroup, IGroupData, IGroupInputData, IGroupRenderModule, IImage, IImageData, IImageFilters, IImageInputData, IImagePaint, IImagePaintMode, IImageRenderModule, IKeyframe, IKeyframeId, IKeyframesAnimation, ILeafFill, ILeafPaint, ILeafPaintColor, ILeafPaintPatternData, ILeafShadowEffect, ILeafStrokePaint, ILeafer, ILeaferData, ILeaferInputData, ILine, ILineData, ILineInputData, ILinker, ILinkerData, ILinkerInputData, ILinkerPointData, IOverflow, IPaint, IPaintAttr, IPaintBase, IPaintGradientModule, IPaintImageModule, IPaintModule, IPaintString, IPaintType, IPath, IPathArrowModule, IPathData, IPathDataArrow, IPathDataArrowMap, IPathDataArrowOffset, IPathInputData, IPen, IPenData, IPenInputData, IPercent, IPolygon, IPolygonData, IPolygonInputData, IRGB, IRGBA, IRect, IRectData, IRectInputData, IRectRenderModule, IRepeat, IRobot, IRobotActionName, IRobotActions, IRobotAnimation, IRobotComputedKeyframe, IRobotData, IRobotInputData, IRobotKeyframe, IScrollConfig, IScrollTheme, IScroller, IShadowEffect, IShadowString, ISolidPaint, IStar, IStarData, IStarInputData, IStateModule, IStateName, IStateStyle, IStates, IStroke, IStrokeAlign, IStrokeAttrData, IStrokeCap, IStrokeComputedData, IStrokeComputedStyle, IStrokeGradientPaint, IStrokeImagePaint, IStrokeInputData, IStrokeJoin, IStrokePaint, IStrokeSolidPaint, IStrokeStyle, IStrokeWidthString, IStyleAnimation, IText, ITextAlign, ITextCase, ITextCharData, ITextConvertModule, ITextData, ITextDecoration, ITextDecorationData, ITextDecorationType, ITextDrawData, ITextInputData, ITextOverflow, ITextRenderModule, ITextRowData, ITextStyleAttrData, ITextStyleComputedData, ITextStyleInputData, ITextWordData, ITextWrap, ITransformTool, ITransitionFunction, ITransitionMap, ITransitionModule, IUI, IUIBaseInputData, IUIBoundsModule, IUIData, IUIHitModule, IUIInputData, IUIJSONData, IUIRenderModule, IUITag, IVectorPath, IVerticalAlign, IVideo, IVideoData, IVideoInputData, IWritingMode };
