import { IString, INumber, IBoolean, IMaskType, IEraserType, IScaleFixed, IAlign, IUnitPointData, IFourNumber, IPathCommandData, IPathCommandNode, IPathCommandObject, IPathString, IWindingRule, IFlowType, IGap, IPointGap, IFlowAlign, IFlowAxisAlign, IFlowWrap, IFlowBoxType, IAutoSize, IAutoBoxData, IConstraint, IRangeSize, IAxis, IBoundsData, IDragBoundsType, IHitType, ICursorType, IFilter, ITransition, IUnitData, IObject, IPointData, IPathCreator, IFindCondition, ILeaferCanvas, IPathDrawer, IRenderOptions, IExportFileType, IJSONOptions, IPickOptions, IPickResult, ILeaferMode, IRenderer, IWatcher, ILayouter, ISelector, IInteraction, ICanvasManager, IHitCanvasManager, ILeaferConfig, IAutoBounds, IBounds, IEventListenerId, ITimer, IControl, ILeaferType, IScreenSizeData, IResizeEvent, IValue, ICanvasSizeAttr, IZoomType, IZoomOptions, IClientPointData, ILeaferImage, ICanvasContext2DSettings, ICanvasContext2D } from '@leafer/interface';
import { Leaf, LeafList } from '@leafer/core';
import { IUIInputData, IUI, IUIData, ILeafer, IGroup, IBlendMode, IFill, IStroke, IStrokeAlign, IStrokeWidthString, IStrokeCap, IStrokeJoin, IDashPatternString, IArrowStyle, ICornerRadiusString, IShadowEffect, IShadowString, IBlurEffect, IGrayscaleEffect, IAnimation, IStates, IStateName, IStateStyle, IColorString, IEditorConfig, IAnimate, IAnimateList, IFindUIMethod, ILeafPaint, IKeyframe, IAnimateType, IExportOptions, IExportResult, IEditorConfigFunction, IEditToolFunction, IGroupInputData, IGroupData, IUIJSONData, IFindCondition as IFindCondition$1, ILeaferData, IApp, IEditorBase, IFunction, ILeaferInputData, IBoxInputData, IBox, IBoxData, IOverflow, IScrollConfig, IScroller, IFrameInputData, IFrame, IFrameData, IRectInputData, IRect, IRectData, IEllipseInputData, IEllipse, IEllipseData, IPolygonInputData, IPolygon, IPolygonData, IStarInputData, IStar, IStarData, ILineInputData, ILine, ILineData, IImageInputData, IImage, IImageData, ICanvasInputData, ICanvas, ICanvasData, ITextInputData, IText, ITextData, IBackgroundBoxStyle, IHitType as IHitType$1, IFontWeight, ITextCase, ITextDecoration, IWritingMode, ITextAlign, IVerticalAlign, ITextWrap, ITextOverflow, ITextDrawData, IPathInputData, IPath, IPathData, IPenInputData, IPen, IPenData, IPathCommandData as IPathCommandData$1, IPointData as IPointData$1 } from '@leafer-ui/interface';

declare class UI<TInputData = IUIInputData> extends Leaf<TInputData> implements IUI {
    __: IUIData;
    proxyData?: IUIInputData;
    __proxyData?: IUIInputData;
    get app(): ILeafer;
    leafer?: ILeafer;
    parent?: IGroup;
    zoomLayer: IGroup;
    get isFrame(): boolean;
    children?: IUI[];
    id?: IString;
    name?: IString;
    className?: IString;
    blendMode?: IBlendMode;
    opacity?: INumber;
    visible?: IBoolean | 0;
    locked?: IBoolean;
    dim?: IBoolean | INumber;
    dimskip?: IBoolean;
    bright?: IBoolean;
    zIndex?: INumber;
    mask?: IBoolean | IMaskType;
    eraser?: IBoolean | IEraserType;
    x?: INumber;
    y?: INumber;
    width?: INumber;
    height?: INumber;
    scaleX?: INumber;
    scaleY?: INumber;
    scaleFixed?: IScaleFixed;
    rotation?: INumber;
    skewX?: INumber;
    skewY?: INumber;
    offsetX?: INumber;
    offsetY?: INumber;
    scrollX?: INumber;
    scrollY?: INumber;
    origin?: IAlign | IUnitPointData;
    around?: IAlign | IUnitPointData;
    lazy?: IBoolean;
    pixelRatio?: INumber;
    renderSpread?: IFourNumber;
    path?: IPathCommandData | IPathCommandNode[] | IPathCommandObject[] | IPathString;
    windingRule?: IWindingRule;
    closed?: boolean;
    flow?: IFlowType;
    padding?: IFourNumber;
    gap?: IGap | IPointGap;
    flowAlign?: IFlowAlign | IFlowAxisAlign;
    flowWrap?: IFlowWrap;
    itemBox?: IFlowBoxType;
    inFlow?: IBoolean;
    autoWidth?: IAutoSize;
    autoHeight?: IAutoSize;
    lockRatio?: IBoolean;
    autoBox?: IAutoBoxData | IConstraint;
    widthRange?: IRangeSize;
    heightRange?: IRangeSize;
    draggable?: IBoolean | IAxis;
    dragBounds?: IBoundsData | 'parent';
    dragBoundsType?: IDragBoundsType;
    editable?: IBoolean;
    hittable?: IBoolean;
    hitFill?: IHitType;
    hitStroke?: IHitType;
    hitBox?: IBoolean;
    hitChildren?: IBoolean;
    hitSelf?: IBoolean;
    hitRadius?: INumber;
    cursor?: ICursorType | ICursorType[];
    fill?: IFill;
    stroke?: IStroke;
    strokeAlign?: IStrokeAlign;
    strokeWidth?: IFourNumber | IStrokeWidthString;
    strokeWidthFixed?: IScaleFixed;
    strokeCap?: IStrokeCap;
    strokeJoin?: IStrokeJoin;
    dashPattern?: INumber[] | IDashPatternString;
    dashOffset?: INumber;
    miterLimit?: INumber;
    startArrow?: IArrowStyle;
    endArrow?: IArrowStyle;
    cornerRadius?: IFourNumber | ICornerRadiusString;
    cornerSmoothing?: INumber;
    shadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    innerShadow?: IShadowEffect | IShadowEffect[] | IShadowString;
    blur?: INumber | IBlurEffect;
    backgroundBlur?: INumber | IBlurEffect;
    grayscale?: INumber | IGrayscaleEffect;
    filter?: IFilter | IFilter[];
    animation?: IAnimation | IAnimation[];
    animationOut?: IAnimation | IAnimation[];
    transition?: ITransition;
    transitionOut?: ITransition;
    motionPath?: boolean;
    motionPrecision?: INumber;
    motion?: INumber | IUnitData;
    motionRotation?: INumber | IBoolean;
    states?: IStates;
    state?: IStateName;
    selected?: IBoolean;
    disabled?: IBoolean;
    normalStyle?: IStateStyle;
    hoverStyle?: IStateStyle;
    pressStyle?: IStateStyle;
    focusStyle?: IStateStyle;
    selectedStyle?: IStateStyle;
    disabledStyle?: IStateStyle;
    placeholderStyle?: IStateStyle;
    placeholderColor?: IColorString;
    placeholderDelay?: INumber;
    button?: IBoolean;
    editConfig: IEditorConfig;
    editOuter: string;
    editInner: string;
    data: IObject;
    set scale(value: INumber | IPointData);
    get scale(): INumber | IPointData;
    get isAutoWidth(): boolean;
    get isAutoHeight(): boolean;
    useFastShadow?: boolean;
    __box?: IUI;
    __animate?: IAnimate | IAnimateList;
    get pen(): IPathCreator;
    reset(_data?: IUIInputData): void;
    set(data: IUIInputData, _transition?: ITransition | 'temp'): void;
    get<K extends keyof this>(name?: K | K[] | IUIInputData): IUIInputData | this[K];
    createProxyData(): IUIInputData;
    find(_condition: number | string | IFindCondition | IFindUIMethod, _options?: any): IUI[];
    findTag(tag: string | string[]): IUI[];
    findOne(_condition: number | string | IFindCondition | IFindUIMethod, _options?: any): IUI | undefined;
    findId(id: number | string): IUI | undefined;
    getPath(curve?: boolean, pathForRender?: boolean): IPathCommandData;
    getPathString(curve?: boolean, pathForRender?: boolean, floatLength?: number): IPathString;
    load(): void;
    __onUpdateSize(): void;
    __updateRenderPath(): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __drawPath(canvas: ILeaferCanvas): void;
    __drawPathByData(drawer: IPathDrawer, data: IPathCommandData, ignoreCornerRadius?: boolean): void;
    __drawPathByBox(drawer: IPathDrawer, ignoreCornerRadius?: boolean): void;
    drawImagePlaceholder(_paint: ILeafPaint, canvas: ILeaferCanvas, renderOptions: IRenderOptions): void;
    animate(keyframe?: IUIInputData | IKeyframe[] | IAnimation | IAnimation[], _options?: ITransition, _type?: IAnimateType, _isTemp?: boolean): IAnimate;
    killAnimate(_type?: IAnimateType, _nextStyle?: IUIInputData): void;
    export(_filename: IExportFileType | string, _options?: IExportOptions | number | boolean): Promise<IExportResult>;
    syncExport(_filename: IExportFileType | string, _options?: IExportOptions | number | boolean): IExportResult;
    clone(data?: IUIInputData): this;
    static one<T extends UI>(this: new (...args: any[]) => T, data: IUIInputData, x?: number, y?: number, width?: number, height?: number): T;
    static registerUI(): void;
    static registerData(data: IUIData): void;
    static setEditConfig(_config: IEditorConfig | IEditorConfigFunction): void;
    static setEditOuter(_toolName: string | IEditToolFunction): void;
    static setEditInner(_editorName: string | IEditToolFunction): void;
    destroy(): void;
}

declare class Group<TInputData = IGroupInputData> extends UI<TInputData> implements IGroup {
    get __tag(): string;
    get isBranch(): boolean;
    __: IGroupData;
    width?: INumber;
    height?: INumber;
    children: IUI[];
    topChildren?: IUI[];
    childlessJSON?: boolean;
    reset(data?: IGroupInputData): void;
    __setBranch(): void;
    set(data: IUIInputData, transition?: ITransition | 'temp'): void;
    toJSON(options?: IJSONOptions): IUIJSONData;
    pick(_hitPoint: IPointData, _options?: IPickOptions): IPickResult;
    addAt(child: IUI | IUI[] | IUIInputData | IUIInputData[], index: number): void;
    addAfter(child: IUI | IUI[] | IUIInputData | IUIInputData[], after: IUI): void;
    addBefore(child: IUI | IUI[] | IUIInputData | IUIInputData[], before: IUI): void;
    add(_child: IUI | IUI[] | IUIInputData | IUIInputData[], _index?: number): void;
    addMany(..._children: IUI[] | IUIInputData[]): void;
    remove(_child?: IUI | number | string | IFindCondition$1 | IFindUIMethod, _destroy?: boolean): void;
    removeAll(_destroy?: boolean): void;
    clear(): void;
}

declare class Leafer extends Group implements ILeafer {
    static list: LeafList;
    get __tag(): string;
    __: ILeaferData;
    pixelRatio?: INumber;
    mode: ILeaferMode;
    get isApp(): boolean;
    get app(): ILeafer;
    get isLeafer(): boolean;
    parentApp?: IApp;
    parent?: IApp;
    running: boolean;
    created: boolean;
    ready: boolean;
    viewReady: boolean;
    viewCompleted: boolean;
    get imageReady(): boolean;
    get layoutLocked(): boolean;
    transforming: boolean;
    get view(): unknown;
    canvas: ILeaferCanvas;
    renderer: IRenderer;
    watcher: IWatcher;
    layouter: ILayouter;
    selector?: ISelector;
    interaction?: IInteraction;
    canvasManager: ICanvasManager;
    hitCanvasManager?: IHitCanvasManager;
    editor: IEditorBase;
    userConfig: ILeaferConfig;
    config: ILeaferConfig;
    autoLayout?: IAutoBounds;
    lazyBounds: IBounds;
    get FPS(): number;
    get cursorPoint(): IPointData;
    get clientBounds(): IBoundsData;
    leafs: number;
    __eventIds: IEventListenerId[];
    protected __startTimer: ITimer;
    protected __controllers: IControl[];
    protected __initWait: IFunction[];
    protected __readyWait: IFunction[];
    protected __viewReadyWait: IFunction[];
    protected __viewCompletedWait: IFunction[];
    __nextRenderWait: IFunction[];
    constructor(userConfig?: ILeaferConfig, data?: ILeaferInputData);
    init(userConfig?: ILeaferConfig, parentApp?: IApp): void;
    onInit(): void;
    initType(_type: ILeaferType): void;
    set(data: IUIInputData, transition?: ITransition | 'temp'): void;
    start(): void;
    stop(): void;
    unlockLayout(): void;
    lockLayout(): void;
    resize(size: IScreenSizeData): void;
    forceRender(bounds?: IBoundsData, sync?: boolean): void;
    requestRender(change?: boolean): void;
    updateCursor(cursor?: ICursorType): void;
    updateLazyBounds(): void;
    protected __doResize(size: IScreenSizeData): void;
    protected __onResize(event: IResizeEvent): void;
    protected __setApp(): void;
    protected __bindApp(app: IApp): void;
    __setLeafer(leafer: ILeafer): void;
    protected __checkAutoLayout(): void;
    __setAttr(attrName: string, newValue: IValue): boolean;
    __getAttr(attrName: string): IValue;
    protected __changeCanvasSize(attrName: ICanvasSizeAttr, newValue: number): void;
    protected __changeFill(newValue: string): void;
    protected __onCreated(): void;
    protected __onReady(): void;
    protected __onViewReady(): void;
    protected __onLayoutEnd(): void;
    protected __onNextRender(): void;
    protected __checkViewCompleted(emit?: boolean): void;
    protected __onWatchData(): void;
    waitInit(item: IFunction, bind?: IObject): void;
    waitReady(item: IFunction, bind?: IObject): void;
    waitViewReady(item: IFunction, bind?: IObject): void;
    waitViewCompleted(item: IFunction, bind?: IObject): void;
    nextRender(item: IFunction, bind?: IObject, off?: 'off'): void;
    zoom(_zoomType: IZoomType, _optionsOrPadding?: IZoomOptions | IFourNumber, _scroll?: 'x' | 'y' | boolean, _transition?: ITransition): IBoundsData;
    getValidMove(moveX: number, moveY: number, _checkLimit?: boolean): IPointData;
    getValidScale(changeScale: number): number;
    getWorldPointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    getPagePointByClient(clientPoint: IClientPointData, updateClient?: boolean): IPointData;
    getClientPointByWorld(worldPoint: IPointData): IPointData;
    updateClientBounds(): void;
    receiveEvent(_event: any): void;
    protected emitLeafer(type: string): void;
    protected __listenEvents(): void;
    protected __removeListenEvents(): void;
    destroy(sync?: boolean): void;
}

declare class Box<TInputData = IBoxInputData> extends Group<TInputData> implements IBox {
    get __tag(): string;
    get isBranchLeaf(): boolean;
    __: IBoxData;
    width?: INumber;
    height?: INumber;
    resizeChildren?: IBoolean;
    textBox?: IBoolean;
    overflow?: IOverflow;
    isOverflow?: boolean;
    scrollConfig?: IScrollConfig;
    scroller?: IScroller;
    hasScroller?: boolean;
    constructor(data?: TInputData);
    __updateStrokeSpread(): IFourNumber;
    __updateRectRenderSpread(): IFourNumber;
    __updateRenderSpread(): IFourNumber;
    __updateRectBoxBounds(): void;
    __updateBoxBounds(_secondLayout?: boolean): void;
    __updateStrokeBounds(): void;
    __updateRenderBounds(): void;
    __updateRectRenderBounds(): void;
    __checkScroll(_isScrollMode: boolean): void;
    __updateRectChange(): void;
    __updateChange(): void;
    __renderRect(_canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __renderGroup(_canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __render(canvas: ILeaferCanvas, options: IRenderOptions): void;
    __drawContent(canvas: ILeaferCanvas, options: IRenderOptions): void;
}

declare class Frame<TInputData = IFrameInputData> extends Box<TInputData> implements IFrame {
    get __tag(): string;
    get isFrame(): boolean;
    __: IFrameData;
    fill?: IFill;
    overflow?: IOverflow;
}

declare class Rect<TInputData = IRectInputData> extends UI<TInputData> implements IRect {
    get __tag(): string;
    __: IRectData;
}

declare class Ellipse<TInputData = IEllipseInputData> extends UI<TInputData> implements IEllipse {
    get __tag(): string;
    __: IEllipseData;
    innerRadius?: INumber;
    startAngle?: INumber;
    endAngle?: INumber;
    __updatePath(): void;
}

declare class Polygon<TInputData = IPolygonInputData> extends UI<TInputData> implements IPolygon {
    get __tag(): string;
    __: IPolygonData;
    sides?: INumber;
    points?: number[] | IPointData[];
    curve?: boolean | number;
    __updatePath(): void;
}

declare class Star<TInputData = IStarInputData> extends UI<TInputData> implements IStar {
    get __tag(): string;
    __: IStarData;
    corners?: INumber;
    innerRadius?: INumber;
    __updatePath(): void;
}

declare class Line<TInputData = ILineInputData> extends UI<TInputData> implements ILine {
    get __tag(): string;
    __: ILineData;
    strokeAlign?: IStrokeAlign;
    height?: INumber;
    points?: number[] | IPointData[];
    curve?: boolean | number;
    closed?: boolean;
    get toPoint(): IPointData;
    set toPoint(value: IPointData);
    __updatePath(): void;
}

declare class Image<TInputData = IImageInputData> extends Rect<TInputData> implements IImage {
    get __tag(): string;
    __: IImageData;
    url: IString;
    get ready(): boolean;
    get image(): ILeaferImage;
}
declare const MyImage: typeof Image;

declare class Canvas<TInputData = ICanvasInputData> extends Rect<TInputData> implements ICanvas {
    get __tag(): string;
    __: ICanvasData;
    width?: INumber;
    height?: INumber;
    pixelRatio?: INumber;
    smooth?: boolean;
    safeResize?: boolean;
    contextSettings?: ICanvasContext2DSettings;
    canvas?: ILeaferCanvas;
    get context(): ICanvasContext2D;
    get ready(): boolean;
    url?: string;
    constructor(data?: TInputData);
    drawImage(url: string): void;
    draw(ui: IUI, offset?: IPointData, scale?: number | IPointData, rotation?: number): void;
    paint(): void;
    __drawContent(canvas: ILeaferCanvas, _options: IRenderOptions): void;
    __updateSize(): void;
    destroy(): void;
}

declare class Text<TConstructorData = ITextInputData> extends UI<TConstructorData> implements IText {
    get __tag(): string;
    __: ITextData;
    width?: INumber;
    height?: INumber;
    boxStyle: IBackgroundBoxStyle;
    resizeFontSize?: IBoolean;
    fill?: IFill;
    strokeAlign?: IStrokeAlign;
    hitFill?: IHitType$1;
    text?: IString | INumber;
    placeholder?: IString;
    fontFamily?: IString;
    fontSize?: INumber;
    fontWeight?: IFontWeight;
    italic?: IBoolean;
    textCase?: ITextCase;
    textDecoration?: ITextDecoration;
    letterSpacing?: INumber | IUnitData;
    lineHeight?: INumber | IUnitData;
    paraIndent?: INumber;
    paraSpacing?: INumber;
    writingMode?: IWritingMode;
    textAlign?: ITextAlign;
    verticalAlign?: IVerticalAlign;
    autoSizeAlign?: IBoolean;
    textWrap?: ITextWrap;
    textOverflow?: ITextOverflow;
    textEditing: boolean;
    isOverflow: boolean;
    get textDrawData(): ITextDrawData;
    __updateTextDrawData(): void;
    __updateBoxBounds(): void;
    __updateRenderSpread(): IFourNumber;
    __updateRenderBounds(): void;
    __updateChange(): void;
    __drawRenderPath(canvas: ILeaferCanvas): void;
    __draw(canvas: ILeaferCanvas, options: IRenderOptions, originCanvas?: ILeaferCanvas): void;
    __drawShape(canvas: ILeaferCanvas, options: IRenderOptions): void;
    destroy(): void;
}

declare class Path<TInputData = IPathInputData> extends UI<TInputData> implements IPath {
    get __tag(): string;
    __: IPathData;
    strokeAlign?: IStrokeAlign;
}

declare class Pen<TInputData = IPenInputData> extends Group<TInputData> implements IPen {
    get __tag(): string;
    __: IPenData;
    pathElement: IPath;
    pathStyle: IPathInputData;
    path: IPathCommandData$1;
    __path: IPathCommandData$1;
    setStyle(data: IPathInputData): Pen;
    beginPath(): Pen;
    moveTo(_x: number, _y: number): Pen;
    lineTo(_x: number, _y: number): Pen;
    bezierCurveTo(_x1: number, _y1: number, _x2: number, _y2: number, _x: number, _y: number): Pen;
    quadraticCurveTo(_x1: number, _y1: number, _x: number, _y: number): Pen;
    closePath(): Pen;
    rect(_x: number, _y: number, _width: number, _height: number): Pen;
    roundRect(_x: number, _y: number, _width: number, _height: number, _cornerRadius: number | number[]): Pen;
    ellipse(_x: number, _y: number, _radiusX: number, _radiusY: number, _rotation?: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    arc(_x: number, _y: number, _radius: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    arcTo(_x1: number, _y1: number, _x2: number, _y2: number, _radius: number): Pen;
    drawEllipse(_x: number, _y: number, _radiusX: number, _radiusY: number, _rotation?: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    drawArc(_x: number, _y: number, _radius: number, _startAngle?: number, _endAngle?: number, _anticlockwise?: boolean): Pen;
    drawPoints(_points: number[] | IPointData$1[], _curve?: boolean | number, _close?: boolean): Pen;
    clearPath(): Pen;
    paint(): void;
}

export { Box, Canvas, Ellipse, Frame, Group, Image, Leafer, Line, MyImage, Path, Pen, Polygon, Rect, Star, Text, UI };
