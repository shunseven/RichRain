import { Debug, LeaferCanvasBase, Platform, isString, DataHelper, canvasSizeAttrs, isUndefined, ResizeEvent, canvasPatch, FileHelper, Creator, LeaferImage, defineKey, LeafList, RenderEvent, ChildEvent, WatchEvent, PropertyEvent, LeafHelper, BranchHelper, LeafBoundsHelper, Bounds, isArray, LeafLevelList, LayoutEvent, Run, ImageManager, PointHelper, BoundsHelper, Plugin, MathHelper, isObject, FourNumberHelper, Matrix, ImageEvent, MatrixHelper, AlignHelper, isNumber, getMatrixData, AroundHelper, Direction4 } from "@leafer/core";

export * from "@leafer/core";

export { LeaferImage } from "@leafer/core";

import { InteractionHelper, InteractionBase, Cursor, HitCanvasManager } from "@leafer-ui/core";

export * from "@leafer-ui/core";

import { Paint, PaintImage, ColorConvert, PaintGradient, Effect, Group, TextConvert } from "@leafer-ui/draw";

var PathNodeHandleType;

(function(PathNodeHandleType) {
    PathNodeHandleType[PathNodeHandleType["none"] = 1] = "none";
    PathNodeHandleType[PathNodeHandleType["free"] = 2] = "free";
    PathNodeHandleType[PathNodeHandleType["mirrorAngle"] = 3] = "mirrorAngle";
    PathNodeHandleType[PathNodeHandleType["mirror"] = 4] = "mirror";
})(PathNodeHandleType || (PathNodeHandleType = {}));

const debug$2 = Debug.get("LeaferCanvas");

class LeaferCanvas extends LeaferCanvasBase {
    set zIndex(zIndex) {
        const {style: style} = this.view;
        style.zIndex = zIndex;
        this.setAbsolute(this.view);
    }
    set childIndex(index) {
        const {view: view, parentView: parentView} = this;
        if (view && parentView) {
            const beforeNode = parentView.children[index];
            if (beforeNode) {
                this.setAbsolute(beforeNode);
                parentView.insertBefore(view, beforeNode);
            } else {
                parentView.appendChild(beforeNode);
            }
        }
    }
    init() {
        const {config: config} = this;
        const view = config.view || config.canvas;
        view ? this.__createViewFrom(view) : this.__createView();
        const {style: style} = this.view;
        style.display || (style.display = "block");
        this.parentView = this.view.parentElement;
        if (this.parentView) {
            const pStyle = this.parentView.style;
            pStyle.webkitUserSelect = pStyle.userSelect = "none";
            this.view.classList.add("leafer-canvas-view");
        }
        if (Platform.syncDomFont && !this.parentView) {
            style.display = "none";
            if (document.body) document.body.appendChild(this.view);
        }
        this.__createContext();
        if (!this.autoLayout) this.resize(config);
    }
    set backgroundColor(color) {
        this.view.style.backgroundColor = color;
    }
    get backgroundColor() {
        return this.view.style.backgroundColor;
    }
    set hittable(hittable) {
        this.view.style.pointerEvents = hittable ? "auto" : "none";
    }
    get hittable() {
        return this.view.style.pointerEvents !== "none";
    }
    __createView() {
        this.view = document.createElement("canvas");
    }
    __createViewFrom(inputView) {
        let find = isString(inputView) ? document.getElementById(inputView) : inputView;
        if (find) {
            if (find instanceof HTMLCanvasElement) {
                this.view = find;
            } else {
                let parent = find;
                if (find === window || find === document) {
                    const div = document.createElement("div");
                    const {style: style} = div;
                    style.position = "absolute";
                    style.top = style.bottom = style.left = style.right = "0px";
                    document.body.appendChild(div);
                    parent = div;
                }
                this.__createView();
                const view = this.view;
                if (parent.hasChildNodes()) {
                    this.setAbsolute(view);
                    parent.style.position || (parent.style.position = "relative");
                }
                parent.appendChild(view);
            }
        } else {
            debug$2.error(`no id: ${inputView}`);
            this.__createView();
        }
    }
    setAbsolute(view) {
        const {style: style} = view;
        style.position = "absolute";
        style.top = style.left = "0px";
    }
    updateViewSize() {
        const {width: width, height: height, pixelRatio: pixelRatio} = this;
        const {style: style} = this.view;
        style.width = width + "px";
        style.height = height + "px";
        if (!this.unreal) {
            this.view.width = Math.ceil(width * pixelRatio);
            this.view.height = Math.ceil(height * pixelRatio);
        }
    }
    updateClientBounds() {
        if (this.view.parentElement) this.clientBounds = this.view.getBoundingClientRect();
    }
    startAutoLayout(autoBounds, listener) {
        this.resizeListener = listener;
        if (autoBounds) {
            this.autoBounds = autoBounds;
            if (this.resizeObserver) return;
            try {
                this.resizeObserver = new ResizeObserver(entries => {
                    this.updateClientBounds();
                    for (const entry of entries) this.checkAutoBounds(entry.contentRect);
                });
                const parent = this.parentView;
                if (parent) {
                    this.resizeObserver.observe(parent);
                    this.checkAutoBounds(parent.getBoundingClientRect());
                } else {
                    this.checkAutoBounds(this.view);
                    debug$2.warn("no parent");
                }
            } catch (_a) {
                this.imitateResizeObserver();
            }
            this.stopListenPixelRatio();
        } else {
            this.listenPixelRatio();
            if (this.unreal) this.updateViewSize();
        }
    }
    imitateResizeObserver() {
        if (this.autoLayout) {
            if (this.parentView) this.checkAutoBounds(this.parentView.getBoundingClientRect());
            Platform.requestRender(this.imitateResizeObserver.bind(this));
        }
    }
    listenPixelRatio() {
        if (!this.windowListener) window.addEventListener("resize", this.windowListener = () => {
            const pixelRatio = Platform.devicePixelRatio;
            if (!this.config.pixelRatio && this.pixelRatio !== pixelRatio) {
                const {width: width, height: height} = this;
                this.emitResize({
                    width: width,
                    height: height,
                    pixelRatio: pixelRatio
                });
            }
        });
    }
    stopListenPixelRatio() {
        if (this.windowListener) {
            window.removeEventListener("resize", this.windowListener);
            this.windowListener = null;
        }
    }
    checkAutoBounds(parentSize) {
        const view = this.view;
        const {x: x, y: y, width: width, height: height} = this.autoBounds.getBoundsFrom(parentSize);
        const size = {
            width: width,
            height: height,
            pixelRatio: this.config.pixelRatio ? this.pixelRatio : Platform.devicePixelRatio
        };
        if (!this.isSameSize(size)) {
            const {style: style} = view;
            style.marginLeft = x + "px";
            style.marginTop = y + "px";
            this.emitResize(size);
        }
    }
    stopAutoLayout() {
        this.autoLayout = false;
        if (this.resizeObserver) this.resizeObserver.disconnect();
        this.resizeListener = this.resizeObserver = null;
    }
    emitResize(size) {
        const oldSize = {};
        DataHelper.copyAttrs(oldSize, this, canvasSizeAttrs);
        this.resize(size);
        if (this.resizeListener && !isUndefined(this.width)) this.resizeListener(new ResizeEvent(size, oldSize));
    }
    unrealCanvas() {
        if (!this.unreal && this.parentView) {
            let view = this.view;
            if (view) view.remove();
            view = this.view = document.createElement("div");
            this.parentView.appendChild(this.view);
            view.classList.add("leafer-app-view");
            this.unreal = true;
        }
    }
    destroy() {
        const {view: view} = this;
        if (view) {
            this.stopAutoLayout();
            this.stopListenPixelRatio();
            if (view.parentElement) view.remove();
            super.destroy();
        }
    }
}

canvasPatch(CanvasRenderingContext2D.prototype);

canvasPatch(Path2D.prototype);

const {mineType: mineType, fileType: fileType} = FileHelper;

Object.assign(Creator, {
    canvas: (options, manager) => new LeaferCanvas(options, manager),
    image: options => new LeaferImage(options)
});

function useCanvas(_canvasType, _power) {
    Platform.origin = {
        createCanvas(width, height) {
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            return canvas;
        },
        canvasToDataURL: (canvas, type, quality) => {
            const imageType = mineType(type), url = canvas.toDataURL(imageType, quality);
            return imageType === "image/bmp" ? url.replace("image/png;", "image/bmp;") : url;
        },
        canvasToBolb: (canvas, type, quality) => new Promise(resolve => canvas.toBlob(resolve, mineType(type), quality)),
        canvasSaveAs: (canvas, filename, quality) => {
            const url = canvas.toDataURL(mineType(fileType(filename)), quality);
            return Platform.origin.download(url, filename);
        },
        download(url, filename) {
            return new Promise(resolve => {
                let el = document.createElement("a");
                el.href = url;
                el.download = filename;
                document.body.appendChild(el);
                el.click();
                document.body.removeChild(el);
                resolve();
            });
        },
        loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Platform.origin.Image;
                const {crossOrigin: crossOrigin} = Platform.image;
                if (crossOrigin) {
                    img.setAttribute("crossOrigin", crossOrigin);
                    img.crossOrigin = crossOrigin;
                }
                img.onload = () => {
                    resolve(img);
                };
                img.onerror = e => {
                    reject(e);
                };
                img.src = Platform.image.getRealURL(src);
            });
        },
        Image: Image,
        PointerEvent: PointerEvent,
        DragEvent: DragEvent
    };
    Platform.event = {
        stopDefault(origin) {
            origin.preventDefault();
        },
        stopNow(origin) {
            origin.stopImmediatePropagation();
        },
        stop(origin) {
            origin.stopPropagation();
        }
    };
    Platform.canvas = Creator.canvas();
    Platform.conicGradientSupport = !!Platform.canvas.context.createConicGradient;
}

Platform.name = "web";

Platform.isMobile = "ontouchstart" in window;

Platform.requestRender = function(render) {
    window.requestAnimationFrame(render);
};

defineKey(Platform, "devicePixelRatio", {
    get() {
        return devicePixelRatio;
    }
});

const {userAgent: userAgent} = navigator;

if (userAgent.indexOf("Firefox") > -1) {
    Platform.conicGradientRotate90 = true;
    Platform.intWheelDeltaY = true;
    Platform.syncDomFont = true;
} else if (/iPhone|iPad|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && /Version\/[\d.]+.*Safari/.test(navigator.userAgent)) {
    Platform.fullImageShadow = true;
}

if (userAgent.indexOf("Windows") > -1) {
    Platform.os = "Windows";
    Platform.intWheelDeltaY = true;
} else if (userAgent.indexOf("Mac") > -1) {
    Platform.os = "Mac";
} else if (userAgent.indexOf("Linux") > -1) {
    Platform.os = "Linux";
}

class Watcher {
    get childrenChanged() {
        return this.hasAdd || this.hasRemove || this.hasVisible;
    }
    get updatedList() {
        if (this.hasRemove && this.config.usePartLayout) {
            const updatedList = new LeafList;
            this.__updatedList.list.forEach(item => {
                if (item.leafer) updatedList.add(item);
            });
            return updatedList;
        } else {
            return this.__updatedList;
        }
    }
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {};
        this.__updatedList = new LeafList;
        this.target = target;
        if (userConfig) this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled) return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    update() {
        this.changed = true;
        if (this.running) this.target.emit(RenderEvent.REQUEST);
    }
    __onAttrChange(event) {
        if (this.config.usePartLayout) this.__updatedList.add(event.target);
        this.update();
    }
    __onChildEvent(event) {
        if (this.config.usePartLayout) {
            if (event.type === ChildEvent.ADD) {
                this.hasAdd = true;
                this.__pushChild(event.child);
            } else {
                this.hasRemove = true;
                this.__updatedList.add(event.parent);
            }
        }
        this.update();
    }
    __pushChild(child) {
        this.__updatedList.add(child);
        if (child.isBranch) this.__loopChildren(child);
    }
    __loopChildren(parent) {
        const {children: children} = parent;
        for (let i = 0, len = children.length; i < len; i++) this.__pushChild(children[i]);
    }
    __onRquestData() {
        this.target.emitEvent(new WatchEvent(WatchEvent.DATA, {
            updatedList: this.updatedList
        }));
        this.__updatedList = new LeafList;
        this.totalTimes++;
        this.changed = this.hasVisible = this.hasRemove = this.hasAdd = false;
    }
    __listenEvents() {
        this.__eventIds = [ this.target.on_([ [ PropertyEvent.CHANGE, this.__onAttrChange, this ], [ [ ChildEvent.ADD, ChildEvent.REMOVE ], this.__onChildEvent, this ], [ WatchEvent.REQUEST, this.__onRquestData, this ] ]) ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = this.__updatedList = null;
        }
    }
}

const {updateAllMatrix: updateAllMatrix$1, updateBounds: updateOneBounds, updateChange: updateOneChange} = LeafHelper;

const {pushAllChildBranch: pushAllChildBranch, pushAllParent: pushAllParent} = BranchHelper;

function updateMatrix(updateList, levelList) {
    let layout;
    updateList.list.forEach(leaf => {
        layout = leaf.__layout;
        if (levelList.without(leaf) && !layout.proxyZoom) {
            if (layout.matrixChanged) {
                updateAllMatrix$1(leaf, true);
                levelList.add(leaf);
                if (leaf.isBranch) pushAllChildBranch(leaf, levelList);
                pushAllParent(leaf, levelList);
            } else if (layout.boundsChanged) {
                levelList.add(leaf);
                if (leaf.isBranch) leaf.__tempNumber = 0;
                pushAllParent(leaf, levelList);
            }
        }
    });
}

function updateBounds(boundsList) {
    let list, branch, children;
    boundsList.sort(true);
    boundsList.levels.forEach(level => {
        list = boundsList.levelMap[level];
        for (let i = 0, len = list.length; i < len; i++) {
            branch = list[i];
            if (branch.isBranch && branch.__tempNumber) {
                children = branch.children;
                for (let j = 0, jLen = children.length; j < jLen; j++) {
                    if (!children[j].isBranch) {
                        updateOneBounds(children[j]);
                    }
                }
            }
            updateOneBounds(branch);
        }
    });
}

function updateChange(updateList) {
    updateList.list.forEach(updateOneChange);
}

const {worldBounds: worldBounds} = LeafBoundsHelper;

class LayoutBlockData {
    constructor(list) {
        this.updatedBounds = new Bounds;
        this.beforeBounds = new Bounds;
        this.afterBounds = new Bounds;
        if (isArray(list)) list = new LeafList(list);
        this.updatedList = list;
    }
    setBefore() {
        this.beforeBounds.setListWithFn(this.updatedList.list, worldBounds);
    }
    setAfter() {
        this.afterBounds.setListWithFn(this.updatedList.list, worldBounds);
        this.updatedBounds.setList([ this.beforeBounds, this.afterBounds ]);
    }
    merge(data) {
        this.updatedList.addList(data.updatedList.list);
        this.beforeBounds.add(data.beforeBounds);
        this.afterBounds.add(data.afterBounds);
        this.updatedBounds.add(data.updatedBounds);
    }
    destroy() {
        this.updatedList = null;
    }
}

const {updateAllMatrix: updateAllMatrix, updateAllChange: updateAllChange} = LeafHelper;

const debug$1 = Debug.get("Layouter");

class Layouter {
    constructor(target, userConfig) {
        this.totalTimes = 0;
        this.config = {
            usePartLayout: true
        };
        this.__levelList = new LeafLevelList;
        this.target = target;
        if (userConfig) this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        if (this.disabled) return;
        this.running = true;
    }
    stop() {
        this.running = false;
    }
    disable() {
        this.stop();
        this.__removeListenEvents();
        this.disabled = true;
    }
    layout() {
        if (this.layouting || !this.running) return;
        const {target: target} = this;
        this.times = 0;
        try {
            target.emit(LayoutEvent.START);
            this.layoutOnce();
            target.emitEvent(new LayoutEvent(LayoutEvent.END, this.layoutedBlocks, this.times));
        } catch (e) {
            debug$1.error(e);
        }
        this.layoutedBlocks = null;
    }
    layoutAgain() {
        if (this.layouting) {
            this.waitAgain = true;
        } else {
            this.layoutOnce();
        }
    }
    layoutOnce() {
        if (this.layouting) return debug$1.warn("layouting");
        if (this.times > 3) return debug$1.warn("layout max times");
        this.times++;
        this.totalTimes++;
        this.layouting = true;
        this.target.emit(WatchEvent.REQUEST);
        if (this.totalTimes > 1 && this.config.usePartLayout) {
            this.partLayout();
        } else {
            this.fullLayout();
        }
        this.layouting = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.layoutOnce();
        }
    }
    partLayout() {
        var _a;
        if (!((_a = this.__updatedList) === null || _a === void 0 ? void 0 : _a.length)) return;
        const t = Run.start("PartLayout");
        const {target: target, __updatedList: updateList} = this;
        const {BEFORE: BEFORE, LAYOUT: LAYOUT, AFTER: AFTER} = LayoutEvent;
        const blocks = this.getBlocks(updateList);
        blocks.forEach(item => item.setBefore());
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        this.extraBlock = null;
        updateList.sort();
        updateMatrix(updateList, this.__levelList);
        updateBounds(this.__levelList);
        updateChange(updateList);
        if (this.extraBlock) blocks.push(this.extraBlock);
        blocks.forEach(item => item.setAfter());
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        this.__levelList.reset();
        this.__updatedList = null;
        Run.end(t);
    }
    fullLayout() {
        const t = Run.start("FullLayout");
        const {target: target} = this;
        const {BEFORE: BEFORE, LAYOUT: LAYOUT, AFTER: AFTER} = LayoutEvent;
        const blocks = this.getBlocks(new LeafList(target));
        target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
        Layouter.fullLayout(target);
        blocks.forEach(item => {
            item.setAfter();
        });
        target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
        target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
        this.addBlocks(blocks);
        Run.end(t);
    }
    static fullLayout(target) {
        updateAllMatrix(target, true);
        if (target.isBranch) BranchHelper.updateBounds(target); else LeafHelper.updateBounds(target);
        updateAllChange(target);
    }
    addExtra(leaf) {
        if (!this.__updatedList.has(leaf)) {
            const {updatedList: updatedList, beforeBounds: beforeBounds} = this.extraBlock || (this.extraBlock = new LayoutBlockData([]));
            updatedList.length ? beforeBounds.add(leaf.__world) : beforeBounds.set(leaf.__world);
            updatedList.add(leaf);
        }
    }
    createBlock(data) {
        return new LayoutBlockData(data);
    }
    getBlocks(list) {
        return [ this.createBlock(list) ];
    }
    addBlocks(current) {
        this.layoutedBlocks ? this.layoutedBlocks.push(...current) : this.layoutedBlocks = current;
    }
    __onReceiveWatchData(event) {
        this.__updatedList = event.data.updatedList;
    }
    __listenEvents() {
        this.__eventIds = [ this.target.on_([ [ LayoutEvent.REQUEST, this.layout, this ], [ LayoutEvent.AGAIN, this.layoutAgain, this ], [ WatchEvent.DATA, this.__onReceiveWatchData, this ] ]) ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.target = this.config = null;
        }
    }
}

const debug = Debug.get("Renderer");

class Renderer {
    get needFill() {
        return !!(!this.canvas.allowBackgroundColor && this.config.fill);
    }
    constructor(target, canvas, userConfig) {
        this.FPS = 60;
        this.totalTimes = 0;
        this.times = 0;
        this.config = {
            usePartRender: true,
            ceilPartPixel: true,
            maxFPS: 120
        };
        this.frames = [];
        this.target = target;
        this.canvas = canvas;
        if (userConfig) this.config = DataHelper.default(userConfig, this.config);
        this.__listenEvents();
    }
    start() {
        this.running = true;
        this.update(false);
    }
    stop() {
        this.running = false;
    }
    update(change = true) {
        if (!this.changed) this.changed = change;
        if (!this.requestTime) this.__requestRender();
    }
    requestLayout() {
        this.target.emit(LayoutEvent.REQUEST);
    }
    checkRender() {
        if (this.running) {
            const {target: target} = this;
            if (target.isApp) {
                target.emit(RenderEvent.CHILD_START, target);
                target.children.forEach(leafer => {
                    leafer.renderer.FPS = this.FPS;
                    leafer.renderer.checkRender();
                });
                target.emit(RenderEvent.CHILD_END, target);
            }
            if (this.changed && this.canvas.view) this.render();
            this.target.emit(RenderEvent.NEXT);
        }
    }
    render(callback) {
        if (!(this.running && this.canvas.view)) return this.update();
        const {target: target} = this;
        this.times = 0;
        this.totalBounds = new Bounds;
        debug.log(target.innerName, "---\x3e");
        try {
            this.emitRender(RenderEvent.START);
            this.renderOnce(callback);
            this.emitRender(RenderEvent.END, this.totalBounds);
            ImageManager.clearRecycled();
        } catch (e) {
            this.rendering = false;
            debug.error(e);
        }
        debug.log("-------------|");
    }
    renderAgain() {
        if (this.rendering) {
            this.waitAgain = true;
        } else {
            this.renderOnce();
        }
    }
    renderOnce(callback) {
        if (this.rendering) return debug.warn("rendering");
        if (this.times > 3) return debug.warn("render max times");
        this.times++;
        this.totalTimes++;
        this.rendering = true;
        this.changed = false;
        this.renderBounds = new Bounds;
        this.renderOptions = {};
        if (callback) {
            this.emitRender(RenderEvent.BEFORE);
            callback();
        } else {
            this.requestLayout();
            if (this.ignore) {
                this.ignore = this.rendering = false;
                return;
            }
            this.emitRender(RenderEvent.BEFORE);
            if (this.config.usePartRender && this.totalTimes > 1) {
                this.partRender();
            } else {
                this.fullRender();
            }
        }
        this.emitRender(RenderEvent.RENDER, this.renderBounds, this.renderOptions);
        this.emitRender(RenderEvent.AFTER, this.renderBounds, this.renderOptions);
        this.updateBlocks = null;
        this.rendering = false;
        if (this.waitAgain) {
            this.waitAgain = false;
            this.renderOnce();
        }
    }
    partRender() {
        const {canvas: canvas, updateBlocks: list} = this;
        if (!list) return;
        this.mergeBlocks();
        list.forEach(block => {
            if (canvas.bounds.hit(block) && !block.isEmpty()) this.clipRender(block);
        });
    }
    clipRender(block) {
        const t = Run.start("PartRender");
        const {canvas: canvas} = this, bounds = block.getIntersect(canvas.bounds), realBounds = new Bounds(bounds);
        canvas.save();
        bounds.spread(Renderer.clipSpread).ceil();
        const {ceilPartPixel: ceilPartPixel} = this.config;
        canvas.clipWorld(bounds, ceilPartPixel);
        canvas.clearWorld(bounds, ceilPartPixel);
        this.__render(bounds, realBounds);
        canvas.restore();
        Run.end(t);
    }
    fullRender() {
        const t = Run.start("FullRender");
        const {canvas: canvas} = this;
        canvas.save();
        canvas.clear();
        this.__render(canvas.bounds);
        canvas.restore();
        Run.end(t);
    }
    __render(bounds, realBounds) {
        const {canvas: canvas, target: target} = this, includes = bounds.includes(target.__world), options = includes ? {
            includes: includes
        } : {
            bounds: bounds,
            includes: includes
        };
        if (this.needFill) canvas.fillWorld(bounds, this.config.fill);
        if (Debug.showRepaint) Debug.drawRepaint(canvas, bounds);
        if (this.config.useCellRender) options.cellList = this.getCellList();
        Platform.render(target, canvas, options);
        this.renderBounds = realBounds = realBounds || bounds;
        this.renderOptions = options;
        this.totalBounds.isEmpty() ? this.totalBounds = realBounds : this.totalBounds.add(realBounds);
        canvas.updateRender(realBounds);
    }
    getCellList() {
        return undefined;
    }
    addBlock(block) {
        if (!this.updateBlocks) this.updateBlocks = [];
        this.updateBlocks.push(block);
    }
    mergeBlocks() {
        const {updateBlocks: list} = this;
        if (list) {
            const bounds = new Bounds;
            bounds.setList(list);
            list.length = 0;
            list.push(bounds);
        }
    }
    __requestRender() {
        const target = this.target;
        if (this.requestTime || !target) return;
        if (target.parentApp) return target.parentApp.requestRender(false);
        this.requestTime = this.frameTime || Date.now();
        const render = () => {
            const nowFPS = 1e3 / ((this.frameTime = Date.now()) - this.requestTime);
            const {maxFPS: maxFPS} = this.config;
            if (maxFPS && nowFPS > maxFPS) return Platform.requestRender(render);
            const {frames: frames} = this;
            if (frames.length > 30) frames.shift();
            frames.push(nowFPS);
            this.FPS = Math.round(frames.reduce((a, b) => a + b, 0) / frames.length);
            this.requestTime = 0;
            this.checkRender();
        };
        Platform.requestRender(render);
    }
    __onResize(e) {
        if (this.canvas.unreal) return;
        if (e.bigger || !e.samePixelRatio) {
            const {width: width, height: height} = e.old;
            const bounds = new Bounds(0, 0, width, height);
            if (!bounds.includes(this.target.__world) || this.needFill || !e.samePixelRatio) {
                this.addBlock(this.canvas.bounds);
                this.target.forceUpdate("surface");
                return;
            }
        }
        this.addBlock(new Bounds(0, 0, 1, 1));
        this.update();
    }
    __onLayoutEnd(event) {
        if (event.data) event.data.map(item => {
            let empty;
            if (item.updatedList) item.updatedList.list.some(leaf => {
                empty = !leaf.__world.width || !leaf.__world.height;
                if (empty) {
                    if (!leaf.isLeafer) debug.tip(leaf.innerName, ": empty");
                    empty = !leaf.isBranch || leaf.isBranchLeaf;
                }
                return empty;
            });
            this.addBlock(empty ? this.canvas.bounds : item.updatedBounds);
        });
    }
    emitRender(type, bounds, options) {
        this.target.emitEvent(new RenderEvent(type, this.times, bounds, options));
    }
    __listenEvents() {
        this.__eventIds = [ this.target.on_([ [ RenderEvent.REQUEST, this.update, this ], [ LayoutEvent.END, this.__onLayoutEnd, this ], [ RenderEvent.AGAIN, this.renderAgain, this ], [ ResizeEvent.RESIZE, this.__onResize, this ] ]) ];
    }
    __removeListenEvents() {
        this.target.off_(this.__eventIds);
    }
    destroy() {
        if (this.target) {
            this.stop();
            this.__removeListenEvents();
            this.config = {};
            this.target = this.canvas = null;
        }
    }
}

Renderer.clipSpread = 10;

const tempPoint = {};

const {copyRadiusPoint: copyRadiusPoint} = PointHelper;

const {hitRadiusPoint: hitRadiusPoint} = BoundsHelper;

class Picker {
    constructor(target, selector) {
        this.target = target;
        this.selector = selector;
    }
    getByPoint(hitPoint, hitRadius, options) {
        if (!hitRadius) hitRadius = 0;
        if (!options) options = {};
        const through = options.through || false;
        const ignoreHittable = options.ignoreHittable || false;
        const target = options.target || this.target;
        this.exclude = options.exclude || null;
        this.point = {
            x: hitPoint.x,
            y: hitPoint.y,
            radiusX: hitRadius,
            radiusY: hitRadius
        };
        this.findList = new LeafList(options.findList);
        if (!options.findList) this.hitBranch(target.isBranchLeaf ? {
            children: [ target ]
        } : target);
        const {list: list} = this.findList;
        const leaf = this.getBestMatchLeaf(list, options.bottomList, ignoreHittable, !!options.findList);
        const path = ignoreHittable ? this.getPath(leaf) : this.getHitablePath(leaf);
        this.clear();
        return through ? {
            path: path,
            target: leaf,
            throughPath: list.length ? this.getThroughPath(list) : path
        } : {
            path: path,
            target: leaf
        };
    }
    hitPoint(hitPoint, hitRadius, options) {
        return !!this.getByPoint(hitPoint, hitRadius, options).target;
    }
    getBestMatchLeaf(list, bottomList, ignoreHittable, allowNull) {
        const findList = this.findList = new LeafList;
        if (list.length) {
            let find;
            const {x: x, y: y} = this.point;
            const point = {
                x: x,
                y: y,
                radiusX: 0,
                radiusY: 0
            };
            for (let i = 0, len = list.length; i < len; i++) {
                find = list[i];
                if (ignoreHittable || LeafHelper.worldHittable(find)) {
                    this.hitChild(find, point);
                    if (findList.length) {
                        if (find.isBranchLeaf && list.some(item => item !== find && LeafHelper.hasParent(item, find))) {
                            findList.reset();
                            break;
                        }
                        return findList.list[0];
                    }
                }
            }
        }
        if (bottomList) {
            for (let i = 0, len = bottomList.length; i < len; i++) {
                this.hitChild(bottomList[i].target, this.point, bottomList[i].proxy);
                if (findList.length) return findList.list[0];
            }
        }
        if (allowNull) return null;
        return ignoreHittable ? list[0] : list.find(item => LeafHelper.worldHittable(item));
    }
    getPath(leaf) {
        const path = new LeafList, syncList = [], {target: target} = this;
        while (leaf) {
            if (leaf.syncEventer) syncList.push(leaf.syncEventer);
            path.add(leaf);
            leaf = leaf.parent;
            if (leaf === target) break;
        }
        if (syncList.length) {
            syncList.forEach(item => {
                while (item) {
                    if (item.__.hittable) path.add(item);
                    item = item.parent;
                    if (item === target) break;
                }
            });
        }
        if (target) path.add(target);
        return path;
    }
    getHitablePath(leaf) {
        const path = this.getPath(leaf && leaf.hittable ? leaf : null);
        let item, hittablePath = new LeafList;
        for (let i = path.list.length - 1; i > -1; i--) {
            item = path.list[i];
            if (!item.__.hittable) break;
            hittablePath.addAt(item, 0);
            if (!item.__.hitChildren || item.isLeafer && item.mode === "draw") break;
        }
        return hittablePath;
    }
    getThroughPath(list) {
        const throughPath = new LeafList;
        const pathList = [];
        for (let i = list.length - 1; i > -1; i--) {
            pathList.push(this.getPath(list[i]));
        }
        let path, nextPath, leaf;
        for (let i = 0, len = pathList.length; i < len; i++) {
            path = pathList[i], nextPath = pathList[i + 1];
            for (let j = 0, jLen = path.length; j < jLen; j++) {
                leaf = path.list[j];
                if (nextPath && nextPath.has(leaf)) break;
                throughPath.add(leaf);
            }
        }
        return throughPath;
    }
    hitBranch(branch) {
        this.eachFind(branch.children, branch.__onlyHitMask);
    }
    eachFind(children, hitMask) {
        let child, hit, data;
        const {point: point} = this, len = children.length;
        for (let i = len - 1; i > -1; i--) {
            child = children[i], data = child.__;
            if (!data.visible || hitMask && !data.mask) continue;
            hit = hitRadiusPoint(child.__world, data.hitRadius ? copyRadiusPoint(tempPoint, point, data.hitRadius) : point);
            if (child.isBranch) {
                if (hit || child.__ignoreHitWorld) {
                    if (child.isBranchLeaf && data.__clipAfterFill && !child.__hitWorld(point, true)) continue;
                    if (child.topChildren) this.eachFind(child.topChildren, false);
                    this.eachFind(child.children, child.__onlyHitMask);
                    if (child.isBranchLeaf) this.hitChild(child, point);
                }
            } else {
                if (hit) this.hitChild(child, point);
            }
        }
    }
    hitChild(child, point, proxy) {
        if (this.exclude && this.exclude.has(child)) return;
        if (child.__hitWorld(point)) {
            const {parent: parent} = child;
            if (parent && parent.__hasMask && !child.__.mask) {
                let findMasks = [], item;
                const {children: children} = parent;
                for (let i = 0, len = children.length; i < len; i++) {
                    item = children[i];
                    if (item.__.mask) findMasks.push(item);
                    if (item === child) {
                        if (findMasks && !findMasks.every(value => value.__hitWorld(point))) return;
                        break;
                    }
                }
            }
            this.findList.add(proxy || child);
        }
    }
    clear() {
        this.point = null;
        this.findList = null;
        this.exclude = null;
    }
    destroy() {
        this.clear();
    }
}

class Selector {
    constructor(target, userConfig) {
        this.config = {};
        if (userConfig) this.config = DataHelper.default(userConfig, this.config);
        this.picker = new Picker(this.target = target, this);
        this.finder = Creator.finder && Creator.finder();
    }
    getByPoint(hitPoint, hitRadius, options) {
        const {target: target, picker: picker} = this;
        if (Platform.backgrounder) target && target.updateLayout();
        return picker.getByPoint(hitPoint, hitRadius, options);
    }
    hitPoint(hitPoint, hitRadius, options) {
        return this.picker.hitPoint(hitPoint, hitRadius, options);
    }
    getBy(condition, branch, one, options) {
        return this.finder ? this.finder.getBy(condition, branch, one, options) : Plugin.need("find");
    }
    destroy() {
        this.picker.destroy();
        if (this.finder) this.finder.destroy();
    }
}

Object.assign(Creator, {
    watcher: (target, options) => new Watcher(target, options),
    layouter: (target, options) => new Layouter(target, options),
    renderer: (target, canvas, options) => new Renderer(target, canvas, options),
    selector: (target, options) => new Selector(target, options)
});

Platform.layout = Layouter.fullLayout;

Platform.render = function(target, canvas, options) {
    const topOptions = Object.assign(Object.assign({}, options), {
        topRendering: true
    });
    options.topList = new LeafList;
    target.__render(canvas, options);
    if (options.topList.length) options.topList.forEach(item => item.__render(canvas, topOptions));
};

const PointerEventHelper = {
    convert(e, local) {
        const base = InteractionHelper.getBase(e), {x: x, y: y} = local;
        const data = Object.assign(Object.assign({}, base), {
            x: x,
            y: y,
            width: e.width,
            height: e.height,
            pointerType: e.pointerType,
            pressure: e.pressure
        });
        if (data.pointerType === "pen") {
            data.tangentialPressure = e.tangentialPressure;
            data.tiltX = e.tiltX;
            data.tiltY = e.tiltY;
            data.twist = e.twist;
        }
        return data;
    },
    convertMouse(e, local) {
        const base = InteractionHelper.getBase(e), {x: x, y: y} = local;
        return Object.assign(Object.assign({}, base), {
            x: x,
            y: y,
            width: 1,
            height: 1,
            pointerType: "mouse",
            pressure: .5
        });
    },
    convertTouch(e, local) {
        const touch = PointerEventHelper.getTouch(e);
        const base = InteractionHelper.getBase(e), {x: x, y: y} = local;
        return Object.assign(Object.assign({}, base), {
            x: x,
            y: y,
            width: 1,
            height: 1,
            pointerType: "touch",
            multiTouch: e.touches.length > 1,
            pressure: touch.force
        });
    },
    getTouch(e) {
        return e.targetTouches[0] || e.changedTouches[0];
    }
};

const KeyEventHelper = {
    convert(e) {
        const base = InteractionHelper.getBase(e);
        const data = Object.assign(Object.assign({}, base), {
            code: e.code,
            key: e.key
        });
        return data;
    }
};

const {pathCanDrag: pathCanDrag} = InteractionHelper;

class Interaction extends InteractionBase {
    get notPointer() {
        const {p: p} = this;
        return p.type !== "pointer" || p.touch || this.useMultiTouch;
    }
    get notTouch() {
        const {p: p} = this;
        return p.type === "mouse" || this.usePointer;
    }
    get notMouse() {
        return this.usePointer || this.useTouch;
    }
    __listenEvents() {
        super.__listenEvents();
        const view = this.view = this.canvas.view;
        this.viewEvents = {
            pointerdown: this.onPointerDown,
            mousedown: this.onMouseDown,
            touchstart: this.onTouchStart,
            pointerleave: this.onPointerLeave,
            contextmenu: this.onContextMenu,
            wheel: this.onWheel,
            gesturestart: this.onGesturestart,
            gesturechange: this.onGesturechange,
            gestureend: this.onGestureend
        };
        this.windowEvents = {
            pointermove: this.onPointerMove,
            pointerup: this.onPointerUp,
            pointercancel: this.onPointerCancel,
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            touchmove: this.onTouchMove,
            touchend: this.onTouchEnd,
            touchcancel: this.onTouchCancel,
            keydown: this.onKeyDown,
            keyup: this.onKeyUp,
            scroll: this.onScroll
        };
        const {viewEvents: viewEvents, windowEvents: windowEvents} = this;
        for (let name in viewEvents) {
            viewEvents[name] = viewEvents[name].bind(this);
            view.addEventListener(name, viewEvents[name]);
        }
        for (let name in windowEvents) {
            windowEvents[name] = windowEvents[name].bind(this);
            window.addEventListener(name, windowEvents[name]);
        }
    }
    __removeListenEvents() {
        super.__removeListenEvents();
        const {viewEvents: viewEvents, windowEvents: windowEvents} = this;
        for (let name in viewEvents) {
            this.view.removeEventListener(name, viewEvents[name]);
            this.viewEvents = {};
        }
        for (let name in windowEvents) {
            window.removeEventListener(name, windowEvents[name]);
            this.windowEvents = {};
        }
    }
    getTouches(touches) {
        const list = [];
        for (let i = 0, len = touches.length; i < len; i++) {
            list.push(touches[i]);
        }
        return list;
    }
    preventDefaultPointer(e) {
        const {pointer: pointer} = this.config;
        if (pointer.preventDefault) e.preventDefault();
    }
    preventDefaultWheel(e) {
        const {wheel: wheel} = this.config;
        if (wheel.preventDefault) e.preventDefault();
    }
    preventWindowPointer(e) {
        return !this.downData && e.target !== this.view;
    }
    onKeyDown(e) {
        this.keyDown(KeyEventHelper.convert(e));
    }
    onKeyUp(e) {
        this.keyUp(KeyEventHelper.convert(e));
    }
    onContextMenu(e) {
        if (this.config.pointer.preventDefaultMenu) e.preventDefault();
        this.menu(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onScroll() {
        this.canvas.updateClientBounds();
    }
    onPointerDown(e) {
        this.preventDefaultPointer(e);
        if (this.notPointer) return;
        this.usePointer || (this.usePointer = true);
        this.pointerDown(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerMove(e, isLeave) {
        if (this.notPointer || this.preventWindowPointer(e)) return;
        this.usePointer || (this.usePointer = true);
        const data = PointerEventHelper.convert(e, this.getLocal(e, true));
        isLeave ? this.pointerHover(data) : this.pointerMove(data);
    }
    onPointerLeave(e) {
        this.onPointerMove(e, true);
    }
    onPointerUp(e) {
        if (this.downData) this.preventDefaultPointer(e);
        if (this.notPointer || this.preventWindowPointer(e)) return;
        this.pointerUp(PointerEventHelper.convert(e, this.getLocal(e)));
    }
    onPointerCancel() {
        if (this.useMultiTouch) return;
        this.pointerCancel();
    }
    onMouseDown(e) {
        this.preventDefaultPointer(e);
        if (this.notMouse) return;
        this.pointerDown(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseMove(e) {
        if (this.notMouse || this.preventWindowPointer(e)) return;
        this.pointerMove(PointerEventHelper.convertMouse(e, this.getLocal(e, true)));
    }
    onMouseUp(e) {
        if (this.downData) this.preventDefaultPointer(e);
        if (this.notMouse || this.preventWindowPointer(e)) return;
        this.pointerUp(PointerEventHelper.convertMouse(e, this.getLocal(e)));
    }
    onMouseCancel() {
        if (this.notMouse) return;
        this.pointerCancel();
    }
    onTouchStart(e) {
        const touch = PointerEventHelper.getTouch(e);
        const local = this.getLocal(touch, true);
        const {preventDefault: preventDefault} = this.config.touch;
        if (preventDefault === true || preventDefault === "auto" && pathCanDrag(this.findPath(local))) e.preventDefault();
        this.multiTouchStart(e);
        if (this.notTouch) return;
        if (this.touchTimer) {
            window.clearTimeout(this.touchTimer);
            this.touchTimer = 0;
        }
        this.useTouch = true;
        this.pointerDown(PointerEventHelper.convertTouch(e, local));
    }
    onTouchMove(e) {
        this.multiTouchMove(e);
        if (this.notTouch || this.preventWindowPointer(e)) return;
        const touch = PointerEventHelper.getTouch(e);
        this.pointerMove(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchEnd(e) {
        this.multiTouchEnd();
        if (this.notTouch || this.preventWindowPointer(e)) return;
        if (this.touchTimer) clearTimeout(this.touchTimer);
        this.touchTimer = setTimeout(() => {
            this.useTouch = false;
        }, 500);
        const touch = PointerEventHelper.getTouch(e);
        this.pointerUp(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
    }
    onTouchCancel() {
        if (this.notTouch) return;
        this.pointerCancel();
    }
    multiTouchStart(e) {
        this.useMultiTouch = e.touches.length > 1;
        this.touches = this.useMultiTouch ? this.getTouches(e.touches) : undefined;
        if (this.useMultiTouch) this.pointerCancel();
    }
    multiTouchMove(e) {
        if (!this.useMultiTouch) return;
        if (e.touches.length > 1) {
            const touches = this.getTouches(e.touches);
            const list = this.getKeepTouchList(this.touches, touches);
            if (list.length > 1) {
                this.multiTouch(InteractionHelper.getBase(e), list);
                this.touches = touches;
            }
        }
    }
    multiTouchEnd() {
        this.touches = null;
        this.useMultiTouch = false;
        this.transformEnd();
    }
    getKeepTouchList(old, touches) {
        let to;
        const list = [];
        old.forEach(from => {
            to = touches.find(touch => touch.identifier === from.identifier);
            if (to) list.push({
                from: this.getLocal(from),
                to: this.getLocal(to)
            });
        });
        return list;
    }
    getLocalTouchs(points) {
        return points.map(point => this.getLocal(point));
    }
    onWheel(e) {
        this.preventDefaultWheel(e);
        this.wheel(Object.assign(Object.assign(Object.assign({}, InteractionHelper.getBase(e)), this.getLocal(e)), {
            deltaX: e.deltaX,
            deltaY: e.deltaY
        }));
    }
    onGesturestart(e) {
        if (this.useMultiTouch) return;
        this.preventDefaultWheel(e);
        this.lastGestureScale = 1;
        this.lastGestureRotation = 0;
    }
    onGesturechange(e) {
        if (this.useMultiTouch) return;
        this.preventDefaultWheel(e);
        const eventBase = InteractionHelper.getBase(e);
        Object.assign(eventBase, this.getLocal(e));
        const scale = e.scale / this.lastGestureScale;
        const rotation = (e.rotation - this.lastGestureRotation) / Math.PI * 180 * (MathHelper.within(this.config.wheel.rotateSpeed, 0, 1) / 4 + .1);
        this.zoom(Object.assign(Object.assign({}, eventBase), {
            scale: scale * scale
        }));
        this.rotate(Object.assign(Object.assign({}, eventBase), {
            rotation: rotation
        }));
        this.lastGestureScale = e.scale;
        this.lastGestureRotation = e.rotation;
    }
    onGestureend(e) {
        if (this.useMultiTouch) return;
        this.preventDefaultWheel(e);
        this.transformEnd();
    }
    setCursor(cursor) {
        super.setCursor(cursor);
        const list = [];
        this.eachCursor(cursor, list);
        if (isObject(list[list.length - 1])) list.push("default");
        this.canvas.view.style.cursor = list.map(item => isObject(item) ? `url(${item.url}) ${item.x || 0} ${item.y || 0}` : item).join(",");
    }
    eachCursor(cursor, list, level = 0) {
        level++;
        if (isArray(cursor)) {
            cursor.forEach(item => this.eachCursor(item, list, level));
        } else {
            const custom = isString(cursor) && Cursor.get(cursor);
            if (custom && level < 2) {
                this.eachCursor(custom, list, level);
            } else {
                list.push(cursor);
            }
        }
    }
    destroy() {
        if (this.view) {
            super.destroy();
            this.view = null;
            this.touches = null;
        }
    }
}

function fill(fill, ui, canvas, renderOptions) {
    canvas.fillStyle = fill;
    fillPathOrText(ui, canvas, renderOptions);
}

function fills(fills, ui, canvas, renderOptions) {
    let item, originPaint, countImage;
    for (let i = 0, len = fills.length; i < len; i++) {
        item = fills[i], originPaint = item.originPaint;
        if (item.image) {
            countImage ? countImage++ : countImage = 1;
            if (PaintImage.checkImage(item, !ui.__.__font, ui, canvas, renderOptions)) continue;
            if (!item.style) {
                if (countImage === 1 && item.image.isPlacehold) ui.drawImagePlaceholder(item, canvas, renderOptions);
                continue;
            }
        }
        canvas.fillStyle = item.style;
        if (item.transform || originPaint.scaleFixed) {
            canvas.save();
            if (item.transform) canvas.transform(item.transform);
            if (originPaint.scaleFixed) {
                const {scaleX: scaleX, scaleY: scaleY} = ui.getRenderScaleData(true);
                if (originPaint.scaleFixed === true || originPaint.scaleFixed === "zoom-in" && scaleX > 1 && scaleY > 1) canvas.scale(1 / scaleX, 1 / scaleY);
            }
            if (originPaint.blendMode) canvas.blendMode = originPaint.blendMode;
            fillPathOrText(ui, canvas, renderOptions);
            canvas.restore();
        } else {
            if (originPaint.blendMode) {
                canvas.saveBlendMode(originPaint.blendMode);
                fillPathOrText(ui, canvas, renderOptions);
                canvas.restoreBlendMode();
            } else fillPathOrText(ui, canvas, renderOptions);
        }
    }
}

function fillPathOrText(ui, canvas, renderOptions) {
    ui.__.__font ? Paint.fillText(ui, canvas, renderOptions) : ui.__.windingRule ? canvas.fill(ui.__.windingRule) : canvas.fill();
}

function fillText(ui, canvas, _renderOptions) {
    const data = ui.__, {rows: rows, decorationY: decorationY} = data.__textDrawData;
    if (data.__isPlacehold && data.placeholderColor) canvas.fillStyle = data.placeholderColor;
    let row;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text) canvas.fillText(row.text, row.x, row.y); else if (row.data) row.data.forEach(charData => {
            canvas.fillText(charData.char, charData.x, row.y);
        });
    }
    if (decorationY) {
        const {decorationColor: decorationColor, decorationHeight: decorationHeight} = data.__textDrawData;
        if (decorationColor) canvas.fillStyle = decorationColor;
        rows.forEach(row => decorationY.forEach(value => canvas.fillRect(row.x, row.y + value, row.width, decorationHeight)));
    }
}

function stroke(stroke, ui, canvas, renderOptions) {
    const data = ui.__;
    if (!data.__strokeWidth) return;
    if (data.__font) {
        Paint.strokeText(stroke, ui, canvas, renderOptions);
    } else {
        switch (data.strokeAlign) {
          case "center":
            drawCenter$1(stroke, 1, ui, canvas, renderOptions);
            break;

          case "inside":
            drawInside(stroke, ui, canvas, renderOptions);
            break;

          case "outside":
            drawOutside(stroke, ui, canvas, renderOptions);
            break;
        }
    }
}

function strokes(strokes, ui, canvas, renderOptions) {
    Paint.stroke(strokes, ui, canvas, renderOptions);
}

function drawCenter$1(stroke, strokeWidthScale, ui, canvas, renderOptions) {
    const data = ui.__;
    if (isObject(stroke)) {
        Paint.drawStrokesStyle(stroke, strokeWidthScale, false, ui, canvas, renderOptions);
    } else {
        canvas.setStroke(stroke, data.__strokeWidth * strokeWidthScale, data);
        canvas.stroke();
    }
    if (data.__useArrow) Paint.strokeArrow(stroke, ui, canvas, renderOptions);
}

function drawInside(stroke, ui, canvas, renderOptions) {
    canvas.save();
    canvas.clipUI(ui);
    drawCenter$1(stroke, 2, ui, canvas, renderOptions);
    canvas.restore();
}

function drawOutside(stroke, ui, canvas, renderOptions) {
    const data = ui.__;
    if (data.__fillAfterStroke) {
        drawCenter$1(stroke, 2, ui, canvas, renderOptions);
    } else {
        const {renderBounds: renderBounds} = ui.__layout;
        const out = canvas.getSameCanvas(true, true);
        ui.__drawRenderPath(out);
        drawCenter$1(stroke, 2, ui, out, renderOptions);
        out.clipUI(data);
        out.clearWorld(renderBounds);
        LeafHelper.copyCanvasByWorld(ui, canvas, out);
        out.recycle(ui.__nowWorld);
    }
}

function strokeText(stroke, ui, canvas, renderOptions) {
    switch (ui.__.strokeAlign) {
      case "center":
        drawCenter(stroke, 1, ui, canvas, renderOptions);
        break;

      case "inside":
        drawAlign(stroke, "inside", ui, canvas, renderOptions);
        break;

      case "outside":
        ui.__.__fillAfterStroke ? drawCenter(stroke, 2, ui, canvas, renderOptions) : drawAlign(stroke, "outside", ui, canvas, renderOptions);
        break;
    }
}

function drawCenter(stroke, strokeWidthScale, ui, canvas, renderOptions) {
    const data = ui.__;
    if (isObject(stroke)) {
        Paint.drawStrokesStyle(stroke, strokeWidthScale, true, ui, canvas, renderOptions);
    } else {
        canvas.setStroke(stroke, data.__strokeWidth * strokeWidthScale, data);
        Paint.drawTextStroke(ui, canvas, renderOptions);
    }
}

function drawAlign(stroke, align, ui, canvas, renderOptions) {
    const out = canvas.getSameCanvas(true, true);
    out.font = ui.__.__font;
    drawCenter(stroke, 2, ui, out, renderOptions);
    out.blendMode = align === "outside" ? "destination-out" : "destination-in";
    Paint.fillText(ui, out, renderOptions);
    out.blendMode = "normal";
    LeafHelper.copyCanvasByWorld(ui, canvas, out);
    out.recycle(ui.__nowWorld);
}

function drawTextStroke(ui, canvas, _renderOptions) {
    let row, data = ui.__.__textDrawData;
    const {rows: rows, decorationY: decorationY} = data;
    for (let i = 0, len = rows.length; i < len; i++) {
        row = rows[i];
        if (row.text) canvas.strokeText(row.text, row.x, row.y); else if (row.data) row.data.forEach(charData => {
            canvas.strokeText(charData.char, charData.x, row.y);
        });
    }
    if (decorationY) {
        const {decorationHeight: decorationHeight} = data;
        rows.forEach(row => decorationY.forEach(value => canvas.strokeRect(row.x, row.y + value, row.width, decorationHeight)));
    }
}

function drawStrokesStyle(strokes, strokeWidthScale, isText, ui, canvas, renderOptions) {
    let item;
    const data = ui.__, {__hasMultiStrokeStyle: __hasMultiStrokeStyle} = data;
    __hasMultiStrokeStyle || canvas.setStroke(undefined, data.__strokeWidth * strokeWidthScale, data);
    for (let i = 0, len = strokes.length; i < len; i++) {
        item = strokes[i];
        if (item.image && PaintImage.checkImage(item, false, ui, canvas, renderOptions)) continue;
        if (item.style) {
            if (__hasMultiStrokeStyle) {
                const {strokeStyle: strokeStyle} = item;
                strokeStyle ? canvas.setStroke(item.style, data.__getRealStrokeWidth(strokeStyle) * strokeWidthScale, data, strokeStyle) : canvas.setStroke(item.style, data.__strokeWidth * strokeWidthScale, data);
            } else canvas.strokeStyle = item.style;
            if (item.originPaint.blendMode) {
                canvas.saveBlendMode(item.originPaint.blendMode);
                isText ? Paint.drawTextStroke(ui, canvas, renderOptions) : canvas.stroke();
                canvas.restoreBlendMode();
            } else {
                isText ? Paint.drawTextStroke(ui, canvas, renderOptions) : canvas.stroke();
            }
        }
    }
}

const {getSpread: getSpread, copyAndSpread: copyAndSpread, toOuterOf: toOuterOf, getOuterOf: getOuterOf, getByMove: getByMove, move: move$1, getIntersectData: getIntersectData} = BoundsHelper;

const tempBounds$1 = {};

function shape(ui, current, options) {
    const canvas = current.getSameCanvas();
    const currentBounds = current.bounds, nowWorld = ui.__nowWorld, layout = ui.__layout;
    const nowWorldShapeBounds = ui.__nowWorldShapeBounds || (ui.__nowWorldShapeBounds = {});
    toOuterOf(layout.strokeSpread ? (copyAndSpread(tempBounds$1, layout.boxBounds, layout.strokeSpread), 
    tempBounds$1) : layout.boxBounds, nowWorld, nowWorldShapeBounds);
    let bounds, renderBounds, matrix, fitMatrix, shapeBounds, worldCanvas;
    let {scaleX: scaleX, scaleY: scaleY} = ui.getRenderScaleData(true);
    if (currentBounds.includes(nowWorldShapeBounds)) {
        worldCanvas = canvas;
        bounds = shapeBounds = nowWorldShapeBounds;
        renderBounds = nowWorld;
    } else {
        let worldClipBounds;
        if (Platform.fullImageShadow) {
            worldClipBounds = nowWorldShapeBounds;
        } else {
            const spreadBounds = layout.renderShapeSpread ? getSpread(currentBounds, FourNumberHelper.swapAndScale(layout.renderShapeSpread, scaleX, scaleY)) : currentBounds;
            worldClipBounds = getIntersectData(spreadBounds, nowWorldShapeBounds);
        }
        fitMatrix = currentBounds.getFitMatrix(worldClipBounds);
        let {a: fitScaleX, d: fitScaleY} = fitMatrix;
        if (fitMatrix.a < 1) {
            worldCanvas = current.getSameCanvas();
            ui.__renderShape(worldCanvas, options);
            scaleX *= fitScaleX;
            scaleY *= fitScaleY;
        }
        shapeBounds = getOuterOf(nowWorldShapeBounds, fitMatrix);
        bounds = getByMove(shapeBounds, -fitMatrix.e, -fitMatrix.f);
        renderBounds = getOuterOf(nowWorld, fitMatrix);
        move$1(renderBounds, -fitMatrix.e, -fitMatrix.f);
        const userMatrix = options.matrix;
        if (userMatrix) {
            matrix = new Matrix(fitMatrix);
            matrix.multiply(userMatrix);
            fitScaleX *= userMatrix.scaleX;
            fitScaleY *= userMatrix.scaleY;
        } else matrix = fitMatrix;
        matrix.withScale(fitScaleX, fitScaleY);
        options = Object.assign(Object.assign({}, options), {
            matrix: matrix
        });
    }
    ui.__renderShape(canvas, options);
    return {
        canvas: canvas,
        matrix: matrix,
        fitMatrix: fitMatrix,
        bounds: bounds,
        renderBounds: renderBounds,
        worldCanvas: worldCanvas,
        shapeBounds: shapeBounds,
        scaleX: scaleX,
        scaleY: scaleY
    };
}

let recycleMap;

const {stintSet: stintSet} = DataHelper, {hasTransparent: hasTransparent$1} = ColorConvert;

function compute(attrName, ui) {
    const data = ui.__, leafPaints = [];
    let paints = data.__input[attrName], isAlphaPixel, isTransparent;
    if (!isArray(paints)) paints = [ paints ];
    recycleMap = PaintImage.recycleImage(attrName, data);
    let maxChildStrokeWidth;
    for (let i = 0, len = paints.length, item; i < len; i++) {
        if (item = getLeafPaint(attrName, paints[i], ui)) {
            leafPaints.push(item);
            if (item.strokeStyle) {
                maxChildStrokeWidth || (maxChildStrokeWidth = 1);
                if (item.strokeStyle.strokeWidth) maxChildStrokeWidth = Math.max(maxChildStrokeWidth, item.strokeStyle.strokeWidth);
            }
        }
    }
    data["_" + attrName] = leafPaints.length ? leafPaints : undefined;
    if (leafPaints.length) {
        if (leafPaints.every(item => item.isTransparent)) {
            if (leafPaints.some(item => item.image)) isAlphaPixel = true;
            isTransparent = true;
        }
        if (attrName === "fill") {
            stintSet(data, "__isAlphaPixelFill", isAlphaPixel);
            stintSet(data, "__isTransparentFill", isTransparent);
        } else {
            stintSet(data, "__isAlphaPixelStroke", isAlphaPixel);
            stintSet(data, "__isTransparentStroke", isTransparent);
            stintSet(data, "__hasMultiStrokeStyle", maxChildStrokeWidth);
        }
    } else {
        data.__removePaint(attrName, false);
    }
}

function getLeafPaint(attrName, paint, ui) {
    if (!isObject(paint) || paint.visible === false || paint.opacity === 0) return undefined;
    let leafPaint;
    const {boxBounds: boxBounds} = ui.__layout;
    switch (paint.type) {
      case "image":
        if (!paint.url) return undefined;
        leafPaint = PaintImage.image(ui, attrName, paint, boxBounds, !recycleMap || !recycleMap[paint.url]);
        break;

      case "linear":
        leafPaint = PaintGradient.linearGradient(paint, boxBounds);
        break;

      case "radial":
        leafPaint = PaintGradient.radialGradient(paint, boxBounds);
        break;

      case "angular":
        leafPaint = PaintGradient.conicGradient(paint, boxBounds);
        break;

      case "solid":
        const {type: type, color: color, opacity: opacity} = paint;
        leafPaint = {
            type: type,
            style: ColorConvert.string(color, opacity)
        };
        break;

      default:
        if (!isUndefined(paint.r)) leafPaint = {
            type: "solid",
            style: ColorConvert.string(paint)
        };
    }
    if (leafPaint) {
        leafPaint.originPaint = paint;
        if (isString(leafPaint.style) && hasTransparent$1(leafPaint.style)) leafPaint.isTransparent = true;
        if (paint.style) {
            if (paint.style.strokeWidth === 0) return undefined;
            leafPaint.strokeStyle = paint.style;
        }
    }
    return leafPaint;
}

const PaintModule = {
    compute: compute,
    fill: fill,
    fills: fills,
    fillPathOrText: fillPathOrText,
    fillText: fillText,
    stroke: stroke,
    strokes: strokes,
    strokeText: strokeText,
    drawTextStroke: drawTextStroke,
    drawStrokesStyle: drawStrokesStyle,
    shape: shape
};

let cache, box = new Bounds;

const {isSame: isSame} = BoundsHelper;

function image(ui, attrName, paint, boxBounds, firstUse) {
    let leafPaint, event;
    const image = ImageManager.get(paint);
    if (cache && paint === cache.paint && isSame(boxBounds, cache.boxBounds)) {
        leafPaint = cache.leafPaint;
    } else {
        leafPaint = {
            type: paint.type,
            image: image
        };
        if (image.hasAlphaPixel) leafPaint.isTransparent = true;
        cache = image.use > 1 ? {
            leafPaint: leafPaint,
            paint: paint,
            boxBounds: box.set(boxBounds)
        } : null;
    }
    if (firstUse || image.loading) event = {
        image: image,
        attrName: attrName,
        attrValue: paint
    };
    if (image.ready) {
        checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds);
        if (firstUse) {
            onLoad(ui, event);
            onLoadSuccess(ui, event);
        }
    } else if (image.error) {
        if (firstUse) onLoadError(ui, event, image.error);
    } else {
        if (firstUse) {
            ignoreRender(ui, true);
            onLoad(ui, event);
        }
        leafPaint.loadId = image.load(() => {
            ignoreRender(ui, false);
            if (!ui.destroyed) {
                if (checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds)) {
                    if (image.hasAlphaPixel) ui.__layout.hitCanvasChanged = true;
                    ui.forceUpdate("surface");
                }
                onLoadSuccess(ui, event);
            }
            leafPaint.loadId = undefined;
        }, error => {
            ignoreRender(ui, false);
            onLoadError(ui, event, error);
            leafPaint.loadId = undefined;
        }, paint.lod && image.getThumbSize(paint.lod));
        if (ui.placeholderColor) {
            if (!ui.placeholderDelay) image.isPlacehold = true; else setTimeout(() => {
                if (!image.ready) {
                    image.isPlacehold = true;
                    ui.forceUpdate("surface");
                }
            }, ui.placeholderDelay);
        }
    }
    return leafPaint;
}

function checkSizeAndCreateData(ui, attrName, paint, image, leafPaint, boxBounds) {
    if (attrName === "fill" && !ui.__.__naturalWidth) {
        const data = ui.__;
        data.__naturalWidth = image.width / data.pixelRatio;
        data.__naturalHeight = image.height / data.pixelRatio;
        if (data.__autoSide) {
            ui.forceUpdate("width");
            if (ui.__proxyData) {
                ui.setProxyAttr("width", data.width);
                ui.setProxyAttr("height", data.height);
            }
            return false;
        }
    }
    if (!leafPaint.data) PaintImage.createData(leafPaint, image, paint, boxBounds);
    return true;
}

function onLoad(ui, event) {
    emit(ui, ImageEvent.LOAD, event);
}

function onLoadSuccess(ui, event) {
    emit(ui, ImageEvent.LOADED, event);
}

function onLoadError(ui, event, error) {
    event.error = error;
    ui.forceUpdate("surface");
    emit(ui, ImageEvent.ERROR, event);
}

function emit(ui, type, data) {
    if (ui.hasEvent(type)) ui.emitEvent(new ImageEvent(type, data));
}

function ignoreRender(ui, value) {
    const {leafer: leafer} = ui;
    if (leafer && leafer.viewReady) leafer.renderer.ignore = value;
}

const {get: get$3, translate: translate$1} = MatrixHelper;

const tempBox = new Bounds;

const tempScaleData = {};

const tempImage = {};

function createData(leafPaint, image, paint, box) {
    leafPaint.data = PaintImage.getPatternData(paint, box, image);
}

function getPatternData(paint, box, image) {
    if (paint.padding) box = tempBox.set(box).shrink(paint.padding);
    if (paint.mode === "strench") paint.mode = "stretch";
    const {width: width, height: height} = image;
    const {opacity: opacity, mode: mode, align: align, offset: offset, scale: scale, size: size, rotation: rotation, skew: skew, clipSize: clipSize, repeat: repeat, gap: gap, filters: filters, interlace: interlace} = paint;
    const sameBox = box.width === width && box.height === height;
    const data = {
        mode: mode
    };
    const swapSize = align !== "center" && (rotation || 0) % 180 === 90;
    BoundsHelper.set(tempImage, 0, 0, swapSize ? height : width, swapSize ? width : height);
    let scaleX, scaleY;
    if (!mode || mode === "cover" || mode === "fit") {
        if (!sameBox || rotation) {
            scaleX = scaleY = BoundsHelper.getFitScale(box, tempImage, mode !== "fit");
            BoundsHelper.put(box, image, align, scaleX, false, tempImage);
            BoundsHelper.scale(tempImage, scaleX, scaleY, true);
        }
    } else {
        if (scale || size) {
            MathHelper.getScaleData(scale, size, image, tempScaleData);
            scaleX = tempScaleData.scaleX;
            scaleY = tempScaleData.scaleY;
        }
        if (align || gap || repeat) {
            if (scaleX) BoundsHelper.scale(tempImage, scaleX, scaleY, true);
            if (align) AlignHelper.toPoint(align, tempImage, box, tempImage, true, true);
        }
    }
    if (offset) PointHelper.move(tempImage, offset);
    switch (mode) {
      case "stretch":
        if (!sameBox) {
            scaleX = box.width / width, scaleY = box.height / height;
            PaintImage.stretchMode(data, box, scaleX, scaleY);
        } else if (scaleX) scaleX = scaleY = undefined;
        break;

      case "normal":
      case "clip":
        if (tempImage.x || tempImage.y || scaleX || clipSize || rotation || skew) {
            let clipScaleX, clipScaleY;
            if (clipSize) clipScaleX = box.width / clipSize.width, clipScaleY = box.height / clipSize.height;
            PaintImage.clipMode(data, box, tempImage.x, tempImage.y, scaleX, scaleY, rotation, skew, clipScaleX, clipScaleY);
            if (clipScaleX) scaleX = scaleX ? scaleX * clipScaleX : clipScaleX, scaleY = scaleY ? scaleY * clipScaleY : clipScaleY;
        }
        break;

      case "repeat":
        if (!sameBox || scaleX || rotation || skew) PaintImage.repeatMode(data, box, width, height, tempImage.x, tempImage.y, scaleX, scaleY, rotation, skew, align, paint.freeTransform);
        if (!repeat) data.repeat = "repeat";
        const count = isObject(repeat);
        if (gap || count) data.gap = getGapData(gap, count && repeat, tempImage.width, tempImage.height, box);
        break;

      case "fit":
      case "cover":
      default:
        if (scaleX) PaintImage.fillOrFitMode(data, box, tempImage.x, tempImage.y, scaleX, scaleY, rotation);
    }
    if (!data.transform) {
        if (box.x || box.y) translate$1(data.transform = get$3(), box.x, box.y);
    }
    if (scaleX) {
        data.scaleX = scaleX;
        data.scaleY = scaleY;
    }
    if (opacity && opacity < 1) data.opacity = opacity;
    if (filters) data.filters = filters;
    if (repeat) data.repeat = isString(repeat) ? repeat === "x" ? "repeat-x" : "repeat-y" : "repeat";
    if (interlace) data.interlace = isNumber(interlace) || interlace.type === "percent" ? {
        type: "x",
        offset: interlace
    } : interlace;
    return data;
}

function getGapData(gap, repeat, width, height, box) {
    let xGap, yGap;
    if (isObject(gap)) xGap = gap.x, yGap = gap.y; else xGap = yGap = gap;
    return {
        x: getGapValue(xGap, width, box.width, repeat && repeat.x),
        y: getGapValue(yGap, height, box.height, repeat && repeat.y)
    };
}

function getGapValue(gap, size, totalSize, rows) {
    const auto = isString(gap) || rows;
    const remain = rows ? totalSize - rows * size : totalSize % size;
    const value = auto ? remain / ((rows || Math.floor(totalSize / size)) - 1) : gap;
    return gap === "auto" ? value < 0 ? 0 : value : value;
}

let origin = {}, tempMatrix$1 = getMatrixData();

const {get: get$2, set: set, rotateOfOuter: rotateOfOuter$1, translate: translate, scaleOfOuter: scaleOfOuter$1, multiplyParent: multiplyParent, scale: scaleHelper, rotate: rotate, skew: skewHelper} = MatrixHelper;

function stretchMode(data, box, scaleX, scaleY) {
    const transform = get$2(), {x: x, y: y} = box;
    if (x || y) translate(transform, x, y); else transform.onlyScale = true;
    scaleHelper(transform, scaleX, scaleY);
    data.transform = transform;
}

function fillOrFitMode(data, box, x, y, scaleX, scaleY, rotation) {
    const transform = get$2();
    translate(transform, box.x + x, box.y + y);
    scaleHelper(transform, scaleX, scaleY);
    if (rotation) rotateOfOuter$1(transform, {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
    }, rotation);
    data.transform = transform;
}

function clipMode(data, box, x, y, scaleX, scaleY, rotation, skew, clipScaleX, clipScaleY) {
    const transform = get$2();
    layout(transform, box, x, y, scaleX, scaleY, rotation, skew);
    if (clipScaleX) {
        if (rotation || skew) {
            set(tempMatrix$1);
            scaleOfOuter$1(tempMatrix$1, box, clipScaleX, clipScaleY);
            multiplyParent(transform, tempMatrix$1);
        } else scaleOfOuter$1(transform, box, clipScaleX, clipScaleY);
    }
    data.transform = transform;
}

function repeatMode(data, box, width, height, x, y, scaleX, scaleY, rotation, skew, align, freeTransform) {
    const transform = get$2();
    if (freeTransform) {
        layout(transform, box, x, y, scaleX, scaleY, rotation, skew);
    } else {
        if (rotation) {
            if (align === "center") {
                rotateOfOuter$1(transform, {
                    x: width / 2,
                    y: height / 2
                }, rotation);
            } else {
                rotate(transform, rotation);
                switch (rotation) {
                  case 90:
                    translate(transform, height, 0);
                    break;

                  case 180:
                    translate(transform, width, height);
                    break;

                  case 270:
                    translate(transform, 0, width);
                    break;
                }
            }
        }
        origin.x = box.x + x;
        origin.y = box.y + y;
        translate(transform, origin.x, origin.y);
        if (scaleX) scaleOfOuter$1(transform, origin, scaleX, scaleY);
    }
    data.transform = transform;
}

function layout(transform, box, x, y, scaleX, scaleY, rotation, skew) {
    if (rotation) rotate(transform, rotation);
    if (skew) skewHelper(transform, skew.x, skew.y);
    if (scaleX) scaleHelper(transform, scaleX, scaleY);
    translate(transform, box.x + x, box.y + y);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const {get: get$1, scale: scale, copy: copy$1} = MatrixHelper;

const {getFloorScale: getFloorScale} = MathHelper, {abs: abs$1} = Math;

function createPatternTask(paint, ui, canvas, renderOptions) {
    if (!paint.patternTask) {
        paint.patternTask = ImageManager.patternTasker.add(() => __awaiter(this, void 0, void 0, function*() {
            PaintImage.createPattern(paint, ui, canvas, renderOptions);
            ui.forceUpdate("surface");
        }), 0, () => {
            paint.patternTask = null;
            return canvas.bounds.hit(ui.__nowWorld);
        });
    }
}

function createPattern(paint, ui, canvas, renderOptions) {
    let {scaleX: scaleX, scaleY: scaleY} = PaintImage.getImageRenderScaleData(paint, ui, canvas, renderOptions), id = scaleX + "-" + scaleY;
    if (paint.patternId !== id && !ui.destroyed) {
        if (!(Platform.image.isLarge(paint.image, scaleX, scaleY) && !paint.data.repeat)) {
            const {image: image, data: data} = paint, {transform: transform, gap: gap} = data, fixScale = PaintImage.getPatternFixScale(paint, scaleX, scaleY);
            let imageMatrix, xGap, yGap, {width: width, height: height} = image;
            if (fixScale) scaleX *= fixScale, scaleY *= fixScale;
            width *= scaleX;
            height *= scaleY;
            if (gap) {
                xGap = gap.x * scaleX / abs$1(data.scaleX || 1);
                yGap = gap.y * scaleY / abs$1(data.scaleY || 1);
            }
            if (transform || scaleX !== 1 || scaleY !== 1) {
                scaleX *= getFloorScale(width + (xGap || 0));
                scaleY *= getFloorScale(height + (yGap || 0));
                imageMatrix = get$1();
                if (transform) copy$1(imageMatrix, transform);
                scale(imageMatrix, 1 / scaleX, 1 / scaleY);
            }
            const imageCanvas = image.getCanvas(width, height, data.opacity, data.filters, xGap, yGap, ui.leafer && ui.leafer.config.smooth, data.interlace);
            const pattern = image.getPattern(imageCanvas, data.repeat || (Platform.origin.noRepeat || "no-repeat"), imageMatrix, paint);
            paint.style = pattern;
            paint.patternId = id;
        }
    }
}

function getPatternFixScale(paint, imageScaleX, imageScaleY) {
    const {image: image} = paint;
    let fixScale, maxSize = Platform.image.maxPatternSize, imageSize = image.width * image.height;
    if (image.isSVG) {
        if (imageScaleX > 1) fixScale = Math.ceil(imageScaleX) / imageScaleX;
    } else {
        if (maxSize > imageSize) maxSize = imageSize;
    }
    if ((imageSize *= imageScaleX * imageScaleY) > maxSize) fixScale = Math.sqrt(maxSize / imageSize);
    return fixScale;
}

function checkImage(paint, drawImage, ui, canvas, renderOptions) {
    const {scaleX: scaleX, scaleY: scaleY} = PaintImage.getImageRenderScaleData(paint, ui, canvas, renderOptions);
    const {image: image, data: data, originPaint: originPaint} = paint, {exporting: exporting, snapshot: snapshot} = renderOptions;
    if (!data || paint.patternId === scaleX + "-" + scaleY && !exporting || snapshot) {
        return false;
    } else {
        if (drawImage) {
            if (data.repeat) {
                drawImage = false;
            } else if (!(originPaint.changeful || Platform.name === "miniapp" && ResizeEvent.isResizing(ui) || exporting)) {
                drawImage = Platform.image.isLarge(image, scaleX, scaleY) || image.width * scaleX > 8096 || image.height * scaleY > 8096;
            }
        }
        if (drawImage) {
            if (ui.__.__isFastShadow) {
                canvas.fillStyle = paint.style || "#000";
                canvas.fill();
            }
            PaintImage.drawImage(paint, scaleX, scaleY, ui, canvas, renderOptions);
            return true;
        } else {
            if (!paint.style || originPaint.sync || exporting) PaintImage.createPattern(paint, ui, canvas, renderOptions); else PaintImage.createPatternTask(paint, ui, canvas, renderOptions);
            return false;
        }
    }
}

function drawImage(paint, _imageScaleX, _imageScaleY, ui, canvas, _renderOptions) {
    const {data: data, image: image} = paint, {blendMode: blendMode} = paint.originPaint, {opacity: opacity, transform: transform} = data, view = image.getFull(data.filters), u = ui.__;
    let {width: width, height: height} = image, clipUI;
    if ((clipUI = transform && !transform.onlyScale || u.path || u.cornerRadius) || opacity || blendMode) {
        canvas.save();
        clipUI && canvas.clipUI(ui);
        blendMode && (canvas.blendMode = blendMode);
        opacity && (canvas.opacity *= opacity);
        transform && canvas.transform(transform);
        canvas.drawImage(view, 0, 0, width, height);
        canvas.restore();
    } else {
        if (data.scaleX) width *= data.scaleX, height *= data.scaleY;
        canvas.drawImage(view, 0, 0, width, height);
    }
}

function getImageRenderScaleData(paint, ui, canvas, _renderOptions) {
    const scaleData = ui.getRenderScaleData(true, paint.originPaint.scaleFixed), {data: data} = paint;
    if (canvas) {
        const {pixelRatio: pixelRatio} = canvas;
        scaleData.scaleX *= pixelRatio;
        scaleData.scaleY *= pixelRatio;
    }
    if (data && data.scaleX) {
        scaleData.scaleX *= Math.abs(data.scaleX);
        scaleData.scaleY *= Math.abs(data.scaleY);
    }
    return scaleData;
}

function recycleImage(attrName, data) {
    const paints = data["_" + attrName];
    if (isArray(paints)) {
        let paint, image, recycleMap, input, url;
        for (let i = 0, len = paints.length; i < len; i++) {
            paint = paints[i];
            image = paint.image;
            url = image && image.url;
            if (url) {
                if (!recycleMap) recycleMap = {};
                recycleMap[url] = true;
                ImageManager.recyclePaint(paint);
                if (image.loading) {
                    if (!input) {
                        input = data.__input && data.__input[attrName] || [];
                        if (!isArray(input)) input = [ input ];
                    }
                    image.unload(paints[i].loadId, !input.some(item => item.url === url));
                }
            }
        }
        return recycleMap;
    }
    return null;
}

const PaintImageModule = {
    image: image,
    checkImage: checkImage,
    drawImage: drawImage,
    getImageRenderScaleData: getImageRenderScaleData,
    recycleImage: recycleImage,
    createPatternTask: createPatternTask,
    createPattern: createPattern,
    getPatternFixScale: getPatternFixScale,
    createData: createData,
    getPatternData: getPatternData,
    stretchMode: stretchMode,
    fillOrFitMode: fillOrFitMode,
    clipMode: clipMode,
    repeatMode: repeatMode
};

const {toPoint: toPoint$2} = AroundHelper, {hasTransparent: hasTransparent} = ColorConvert;

const realFrom$2 = {};

const realTo$2 = {};

function linearGradient(paint, box) {
    let {from: from, to: to, type: type, opacity: opacity} = paint;
    toPoint$2(from || "top", box, realFrom$2);
    toPoint$2(to || "bottom", box, realTo$2);
    const style = Platform.canvas.createLinearGradient(realFrom$2.x, realFrom$2.y, realTo$2.x, realTo$2.y);
    const data = {
        type: type,
        style: style
    };
    applyStops(data, style, paint.stops, opacity);
    return data;
}

function applyStops(data, gradient, stops, opacity) {
    if (stops) {
        let stop, color, offset, isTransparent;
        for (let i = 0, len = stops.length; i < len; i++) {
            stop = stops[i];
            if (isString(stop)) offset = i / (len - 1), color = ColorConvert.string(stop, opacity); else offset = stop.offset, 
            color = ColorConvert.string(stop.color, opacity);
            gradient.addColorStop(offset, color);
            if (!isTransparent && hasTransparent(color)) isTransparent = true;
        }
        if (isTransparent) data.isTransparent = true;
    }
}

const {getAngle: getAngle, getDistance: getDistance$1} = PointHelper;

const {get: get, rotateOfOuter: rotateOfOuter, scaleOfOuter: scaleOfOuter} = MatrixHelper;

const {toPoint: toPoint$1} = AroundHelper;

const realFrom$1 = {};

const realTo$1 = {};

function radialGradient(paint, box) {
    let {from: from, to: to, type: type, opacity: opacity, stretch: stretch} = paint;
    toPoint$1(from || "center", box, realFrom$1);
    toPoint$1(to || "bottom", box, realTo$1);
    const style = Platform.canvas.createRadialGradient(realFrom$1.x, realFrom$1.y, 0, realFrom$1.x, realFrom$1.y, getDistance$1(realFrom$1, realTo$1));
    const data = {
        type: type,
        style: style
    };
    applyStops(data, style, paint.stops, opacity);
    const transform = getTransform(box, realFrom$1, realTo$1, stretch, true);
    if (transform) data.transform = transform;
    return data;
}

function getTransform(box, from, to, stretch, rotate90) {
    let transform;
    const {width: width, height: height} = box;
    if (width !== height || stretch) {
        const angle = getAngle(from, to);
        transform = get();
        if (rotate90) {
            scaleOfOuter(transform, from, width / height * (stretch || 1), 1);
            rotateOfOuter(transform, from, angle + 90);
        } else {
            scaleOfOuter(transform, from, 1, width / height * (stretch || 1));
            rotateOfOuter(transform, from, angle);
        }
    }
    return transform;
}

const {getDistance: getDistance} = PointHelper;

const {toPoint: toPoint} = AroundHelper;

const realFrom = {};

const realTo = {};

function conicGradient(paint, box) {
    let {from: from, to: to, type: type, opacity: opacity, stretch: stretch} = paint;
    toPoint(from || "center", box, realFrom);
    toPoint(to || "bottom", box, realTo);
    const style = Platform.conicGradientSupport ? Platform.canvas.createConicGradient(0, realFrom.x, realFrom.y) : Platform.canvas.createRadialGradient(realFrom.x, realFrom.y, 0, realFrom.x, realFrom.y, getDistance(realFrom, realTo));
    const data = {
        type: type,
        style: style
    };
    applyStops(data, style, paint.stops, opacity);
    const transform = getTransform(box, realFrom, realTo, stretch || 1, Platform.conicGradientRotate90);
    if (transform) data.transform = transform;
    return data;
}

const PaintGradientModule = {
    linearGradient: linearGradient,
    radialGradient: radialGradient,
    conicGradient: conicGradient,
    getTransform: getTransform
};

const {copy: copy, move: move, toOffsetOutBounds: toOffsetOutBounds$1} = BoundsHelper, {max: max, abs: abs} = Math;

const tempBounds = {}, tempMatrix = new Matrix;

const offsetOutBounds$1 = {};

function shadow(ui, current, shape) {
    let copyBounds, transform;
    const {__nowWorld: nowWorld} = ui;
    const {shadow: shadow} = ui.__;
    const {worldCanvas: worldCanvas, bounds: bounds, renderBounds: renderBounds, shapeBounds: shapeBounds, scaleX: scaleX, scaleY: scaleY} = shape;
    const other = current.getSameCanvas();
    const end = shadow.length - 1;
    toOffsetOutBounds$1(bounds, offsetOutBounds$1, renderBounds);
    shadow.forEach((item, index) => {
        let otherScale = 1;
        if (item.scaleFixed) {
            const sx = Math.abs(nowWorld.scaleX);
            if (sx > 1) otherScale = 1 / sx;
        }
        other.setWorldShadow(offsetOutBounds$1.offsetX + (item.x || 0) * scaleX * otherScale, offsetOutBounds$1.offsetY + (item.y || 0) * scaleY * otherScale, (item.blur || 0) * scaleX * otherScale, ColorConvert.string(item.color));
        transform = Effect.getShadowTransform(ui, other, shape, item, offsetOutBounds$1, otherScale);
        if (transform) other.setTransform(transform);
        drawWorldShadow(other, offsetOutBounds$1, shape);
        if (transform) other.resetTransform();
        copyBounds = renderBounds;
        if (item.box) {
            other.restore();
            other.save();
            if (worldCanvas) {
                other.copyWorld(other, renderBounds, nowWorld, "copy");
                copyBounds = nowWorld;
            }
            worldCanvas ? other.copyWorld(worldCanvas, nowWorld, nowWorld, "destination-out") : other.copyWorld(shape.canvas, shapeBounds, bounds, "destination-out");
        }
        LeafHelper.copyCanvasByWorld(ui, current, other, copyBounds, item.blendMode);
        if (end && index < end) other.clearWorld(copyBounds);
    });
    other.recycle(copyBounds);
}

function getShadowRenderSpread(_ui, shadow) {
    let top = 0, right = 0, bottom = 0, left = 0, x, y, spread, blur;
    shadow.forEach(item => {
        x = item.x || 0, y = item.y || 0, blur = (item.blur || 0) * 1.5, spread = abs(item.spread || 0);
        top = max(top, spread + blur - y);
        right = max(right, spread + blur + x);
        bottom = max(bottom, spread + blur + y);
        left = max(left, spread + blur - x);
    });
    return top === right && right === bottom && bottom === left ? top : [ top, right, bottom, left ];
}

function getShadowTransform(ui, canvas, _shape, shadow, outBounds, otherScale, isInnerShaodw) {
    if (shadow.spread) {
        const spread = shadow.spread * 2 * otherScale * (isInnerShaodw ? -1 : 1), {width: width, height: height} = ui.__layout.strokeBounds;
        tempMatrix.set().scaleOfOuter({
            x: (outBounds.x + outBounds.width / 2) * canvas.pixelRatio,
            y: (outBounds.y + outBounds.height / 2) * canvas.pixelRatio
        }, 1 + spread / width, 1 + spread / height);
        return tempMatrix;
    }
    return undefined;
}

function drawWorldShadow(canvas, outBounds, shape) {
    const {shapeBounds: shapeBounds} = shape;
    let from, to;
    if (Platform.fullImageShadow) {
        copy(tempBounds, canvas.bounds);
        move(tempBounds, outBounds.x - shapeBounds.x, outBounds.y - shapeBounds.y);
        from = canvas.bounds, to = tempBounds;
    } else {
        from = shapeBounds, to = outBounds;
    }
    canvas.copyWorld(shape.canvas, from, to);
}

const {toOffsetOutBounds: toOffsetOutBounds} = BoundsHelper;

const offsetOutBounds = {};

function innerShadow(ui, current, shape) {
    let copyBounds, transform;
    const {__nowWorld: nowWorld} = ui;
    const {innerShadow: innerShadow} = ui.__;
    const {worldCanvas: worldCanvas, bounds: bounds, renderBounds: renderBounds, shapeBounds: shapeBounds, scaleX: scaleX, scaleY: scaleY} = shape;
    const other = current.getSameCanvas();
    const end = innerShadow.length - 1;
    toOffsetOutBounds(bounds, offsetOutBounds, renderBounds);
    innerShadow.forEach((item, index) => {
        let otherScale = 1;
        if (item.scaleFixed) {
            const sx = Math.abs(nowWorld.scaleX);
            if (sx > 1) otherScale = 1 / sx;
        }
        other.save();
        other.setWorldShadow(offsetOutBounds.offsetX + (item.x || 0) * scaleX * otherScale, offsetOutBounds.offsetY + (item.y || 0) * scaleY * otherScale, (item.blur || 0) * scaleX * otherScale);
        transform = Effect.getShadowTransform(ui, other, shape, item, offsetOutBounds, otherScale, true);
        if (transform) other.setTransform(transform);
        drawWorldShadow(other, offsetOutBounds, shape);
        other.restore();
        if (worldCanvas) {
            other.copyWorld(other, renderBounds, nowWorld, "copy");
            other.copyWorld(worldCanvas, nowWorld, nowWorld, "source-out");
            copyBounds = nowWorld;
        } else {
            other.copyWorld(shape.canvas, shapeBounds, bounds, "source-out");
            copyBounds = renderBounds;
        }
        other.fillWorld(copyBounds, ColorConvert.string(item.color), "source-in");
        LeafHelper.copyCanvasByWorld(ui, current, other, copyBounds, item.blendMode);
        if (end && index < end) other.clearWorld(copyBounds);
    });
    other.recycle(copyBounds);
}

const getInnerShadowSpread = getShadowRenderSpread;

function blur(ui, current, origin) {
    const {blur: blur} = ui.__;
    origin.setWorldBlur(blur * ui.__nowWorld.a);
    origin.copyWorldToInner(current, ui.__nowWorld, ui.__layout.renderBounds);
    origin.filter = "none";
}

function backgroundBlur(_ui, _current, _shape) {}

const EffectModule = {
    shadow: shadow,
    innerShadow: innerShadow,
    blur: blur,
    backgroundBlur: backgroundBlur,
    getShadowRenderSpread: getShadowRenderSpread,
    getShadowTransform: getShadowTransform,
    isTransformShadow(_shadow) {
        return undefined;
    },
    getInnerShadowSpread: getInnerShadowSpread
};

const {excludeRenderBounds: excludeRenderBounds} = LeafBoundsHelper;

let usedGrayscaleAlpha;

Group.prototype.__renderMask = function(canvas, options) {
    let child, maskCanvas, contentCanvas, maskOpacity, currentMask, mask;
    const {children: children} = this;
    for (let i = 0, len = children.length; i < len; i++) {
        child = children[i], mask = child.__.mask;
        if (mask) {
            if (currentMask) {
                maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity, undefined, true);
                maskCanvas = contentCanvas = null;
            }
            if (mask === "clipping" || mask === "clipping-path") excludeRenderBounds(child, options) || child.__render(canvas, options);
            maskOpacity = child.__.opacity;
            usedGrayscaleAlpha = false;
            if (mask === "path" || mask === "clipping-path") {
                if (maskOpacity < 1) {
                    currentMask = "opacity-path";
                    if (!contentCanvas) contentCanvas = getCanvas(canvas);
                } else {
                    currentMask = "path";
                    canvas.save();
                }
                child.__clip(contentCanvas || canvas, options);
            } else {
                currentMask = mask === "grayscale" ? "grayscale" : "alpha";
                if (!maskCanvas) maskCanvas = getCanvas(canvas);
                if (!contentCanvas) contentCanvas = getCanvas(canvas);
                child.__render(maskCanvas, options);
            }
            continue;
        }
        const childBlendMode = maskOpacity === 1 && child.__.__blendMode;
        if (childBlendMode) maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity, undefined, false);
        excludeRenderBounds(child, options) || child.__render(contentCanvas || canvas, options);
        if (childBlendMode) maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity, childBlendMode, false);
    }
    maskEnd(this, currentMask, canvas, contentCanvas, maskCanvas, maskOpacity, undefined, true);
};

function maskEnd(leaf, maskMode, canvas, contentCanvas, maskCanvas, maskOpacity, blendMode, recycle) {
    switch (maskMode) {
      case "grayscale":
        if (!usedGrayscaleAlpha) usedGrayscaleAlpha = true, maskCanvas.useGrayscaleAlpha(leaf.__nowWorld);

      case "alpha":
        usePixelMask(leaf, canvas, contentCanvas, maskCanvas, blendMode, recycle);
        break;

      case "opacity-path":
        copyContent(leaf, canvas, contentCanvas, maskOpacity, blendMode, recycle);
        break;

      case "path":
        if (recycle) canvas.restore();
    }
}

function getCanvas(canvas) {
    return canvas.getSameCanvas(false, true);
}

function usePixelMask(leaf, canvas, content, mask, blendMode, recycle) {
    const realBounds = leaf.__nowWorld;
    content.resetTransform();
    content.opacity = 1;
    content.useMask(mask, realBounds);
    if (recycle) mask.recycle(realBounds);
    copyContent(leaf, canvas, content, 1, blendMode, recycle);
}

function copyContent(leaf, canvas, content, maskOpacity, blendMode, recycle) {
    const realBounds = leaf.__nowWorld;
    canvas.resetTransform();
    canvas.opacity = maskOpacity;
    canvas.copyWorld(content, realBounds, undefined, blendMode);
    recycle ? content.recycle(realBounds) : content.clearWorld(realBounds);
}

const money = "";

const letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz";

const langBefore = "" + money;

const langAfter = "";

const langSymbol = "";

const langBreak$1 = "";

const beforeChar = "{[(<'\"" + langBefore;

const afterChar = ">)]}%!?,.:;'\"" + langAfter;

const symbolChar = afterChar + "_#~&*+\\=|" + langSymbol;

const breakChar = "- " + langBreak$1;

const cjkRangeList = [ [ 19968, 40959 ], [ 13312, 19903 ], [ 131072, 173791 ], [ 173824, 177983 ], [ 177984, 178207 ], [ 178208, 183983 ], [ 183984, 191471 ], [ 196608, 201551 ], [ 201552, 205743 ], [ 11904, 12031 ], [ 12032, 12255 ], [ 12272, 12287 ], [ 12288, 12351 ], [ 12736, 12783 ], [ 12800, 13055 ], [ 13056, 13311 ], [ 63744, 64255 ], [ 65072, 65103 ], [ 127488, 127743 ], [ 194560, 195103 ] ];

const cjkReg = new RegExp(cjkRangeList.map(([start, end]) => `[\\u${start.toString(16)}-\\u${end.toString(16)}]`).join("|"));

function mapChar(str) {
    const map = {};
    str.split("").forEach(char => map[char] = true);
    return map;
}

const letterMap = mapChar(letter);

const beforeMap = mapChar(beforeChar);

const afterMap = mapChar(afterChar);

const symbolMap = mapChar(symbolChar);

const breakMap = mapChar(breakChar);

var CharType;

(function(CharType) {
    CharType[CharType["Letter"] = 0] = "Letter";
    CharType[CharType["Single"] = 1] = "Single";
    CharType[CharType["Before"] = 2] = "Before";
    CharType[CharType["After"] = 3] = "After";
    CharType[CharType["Symbol"] = 4] = "Symbol";
    CharType[CharType["Break"] = 5] = "Break";
})(CharType || (CharType = {}));

const {Letter: Letter$1, Single: Single$1, Before: Before$1, After: After$1, Symbol: Symbol$1, Break: Break$1} = CharType;

function getCharType(char) {
    if (letterMap[char]) {
        return Letter$1;
    } else if (breakMap[char]) {
        return Break$1;
    } else if (beforeMap[char]) {
        return Before$1;
    } else if (afterMap[char]) {
        return After$1;
    } else if (symbolMap[char]) {
        return Symbol$1;
    } else if (cjkReg.test(char)) {
        return Single$1;
    } else {
        return Letter$1;
    }
}

const TextRowHelper = {
    trimRight(row) {
        const {words: words} = row;
        let trimRight = 0, len = words.length, char;
        for (let i = len - 1; i > -1; i--) {
            char = words[i].data[0];
            if (char.char === " ") {
                trimRight++;
                row.width -= char.width;
            } else {
                break;
            }
        }
        if (trimRight) words.splice(len - trimRight, trimRight);
    }
};

function getTextCase(char, textCase, firstChar) {
    switch (textCase) {
      case "title":
        return firstChar ? char.toUpperCase() : char;

      case "upper":
        return char.toUpperCase();

      case "lower":
        return char.toLowerCase();

      default:
        return char;
    }
}

const {trimRight: trimRight} = TextRowHelper;

const {Letter: Letter, Single: Single, Before: Before, After: After, Symbol: Symbol, Break: Break} = CharType;

let word, row, wordWidth, rowWidth, realWidth;

let char, charWidth, startCharSize, charSize, charType, lastCharType, langBreak, afterBreak, paraStart;

let textDrawData, rows = [], bounds, findMaxWidth;

function createRows(drawData, content, style) {
    textDrawData = drawData;
    rows = drawData.rows;
    bounds = drawData.bounds;
    findMaxWidth = !bounds.width && !style.autoSizeAlign;
    const {__letterSpacing: __letterSpacing, paraIndent: paraIndent, textCase: textCase} = style;
    const {canvas: canvas} = Platform, {width: width} = bounds;
    if (style.__isCharMode) {
        const wrap = style.textWrap !== "none";
        const breakAll = style.textWrap === "break";
        paraStart = true;
        lastCharType = null;
        startCharSize = charWidth = charSize = wordWidth = rowWidth = 0;
        word = {
            data: []
        }, row = {
            words: []
        };
        if (__letterSpacing) content = [ ...content ];
        for (let i = 0, len = content.length; i < len; i++) {
            char = content[i];
            if (char === "\n") {
                if (wordWidth) addWord();
                row.paraEnd = true;
                addRow();
                paraStart = true;
            } else {
                charType = getCharType(char);
                if (charType === Letter && textCase !== "none") char = getTextCase(char, textCase, !wordWidth);
                charWidth = canvas.measureText(char).width;
                if (__letterSpacing) {
                    if (__letterSpacing < 0) charSize = charWidth;
                    charWidth += __letterSpacing;
                }
                langBreak = charType === Single && (lastCharType === Single || lastCharType === Letter) || lastCharType === Single && charType !== After;
                afterBreak = (charType === Before || charType === Single) && (lastCharType === Symbol || lastCharType === After);
                realWidth = paraStart && paraIndent ? width - paraIndent : width;
                if (wrap && (width && rowWidth + wordWidth + charWidth > realWidth)) {
                    if (breakAll) {
                        if (wordWidth) addWord();
                        if (rowWidth) addRow();
                    } else {
                        if (!afterBreak) afterBreak = charType === Letter && lastCharType == After;
                        if (langBreak || afterBreak || charType === Break || charType === Before || charType === Single || wordWidth + charWidth > realWidth) {
                            if (wordWidth) addWord();
                            if (rowWidth) addRow();
                        } else {
                            if (rowWidth) addRow();
                        }
                    }
                }
                if (char === " " && paraStart !== true && rowWidth + wordWidth === 0) ; else {
                    if (charType === Break) {
                        if (char === " " && wordWidth) addWord();
                        addChar(char, charWidth);
                        addWord();
                    } else if (langBreak || afterBreak) {
                        if (wordWidth) addWord();
                        addChar(char, charWidth);
                    } else {
                        addChar(char, charWidth);
                    }
                }
                lastCharType = charType;
            }
        }
        if (wordWidth) addWord();
        if (rowWidth) addRow();
        rows.length > 0 && (rows[rows.length - 1].paraEnd = true);
    } else {
        content.split("\n").forEach(content => {
            textDrawData.paraNumber++;
            rowWidth = canvas.measureText(content).width;
            rows.push({
                x: paraIndent || 0,
                text: content,
                width: rowWidth,
                paraStart: true
            });
            if (findMaxWidth) setMaxWidth();
        });
    }
}

function addChar(char, width) {
    if (charSize && !startCharSize) startCharSize = charSize;
    word.data.push({
        char: char,
        width: width
    });
    wordWidth += width;
}

function addWord() {
    rowWidth += wordWidth;
    word.width = wordWidth;
    row.words.push(word);
    word = {
        data: []
    };
    wordWidth = 0;
}

function addRow() {
    if (paraStart) {
        textDrawData.paraNumber++;
        row.paraStart = true;
        paraStart = false;
    }
    if (charSize) {
        row.startCharSize = startCharSize;
        row.endCharSize = charSize;
        startCharSize = 0;
    }
    row.width = rowWidth;
    if (bounds.width) trimRight(row); else if (findMaxWidth) setMaxWidth();
    rows.push(row);
    row = {
        words: []
    };
    rowWidth = 0;
}

function setMaxWidth() {
    if (rowWidth > (textDrawData.maxWidth || 0)) textDrawData.maxWidth = rowWidth;
}

const CharMode = 0;

const WordMode = 1;

const TextMode = 2;

function layoutChar(drawData, style, width, _height) {
    const {rows: rows} = drawData;
    const {textAlign: textAlign, paraIndent: paraIndent, __letterSpacing: __letterSpacing} = style;
    const justifyLast = width && textAlign.includes("both");
    const justify = justifyLast || width && textAlign.includes("justify");
    const justifyLetter = justify && textAlign.includes("letter");
    let charX, remainingWidth, addWordWidth, addLetterWidth, indentWidth, mode, wordChar, wordsLength, isLastWord, canJustify;
    rows.forEach(row => {
        if (row.words) {
            indentWidth = paraIndent && row.paraStart ? paraIndent : 0, wordsLength = row.words.length;
            if (justify) {
                canJustify = !row.paraEnd || justifyLast;
                remainingWidth = width - row.width - indentWidth;
                if (justifyLetter) addLetterWidth = remainingWidth / (row.words.reduce((total, item) => total + item.data.length, 0) - 1); else addWordWidth = wordsLength > 1 ? remainingWidth / (wordsLength - 1) : 0;
            }
            mode = __letterSpacing || row.isOverflow || justifyLetter ? CharMode : addWordWidth ? WordMode : TextMode;
            if (row.isOverflow && !__letterSpacing) row.textMode = true;
            if (mode === TextMode) {
                row.x += indentWidth;
                toTextChar$1(row);
            } else {
                row.x += indentWidth;
                charX = row.x;
                row.data = [];
                row.words.forEach((word, index) => {
                    if (mode === WordMode) {
                        wordChar = {
                            char: "",
                            x: charX
                        };
                        charX = toWordChar(word.data, charX, wordChar);
                        if (row.isOverflow || wordChar.char !== " ") row.data.push(wordChar);
                    } else {
                        charX = toChar(word.data, charX, row.data, row.isOverflow, canJustify && addLetterWidth);
                    }
                    if (canJustify) {
                        isLastWord = index === wordsLength - 1;
                        if (addWordWidth) {
                            if (!isLastWord) charX += addWordWidth, row.width += addWordWidth;
                        } else if (addLetterWidth) {
                            row.width += addLetterWidth * (word.data.length - (isLastWord ? 1 : 0));
                        }
                    }
                });
            }
            row.words = null;
        }
    });
}

function toTextChar$1(row) {
    row.text = "";
    row.words.forEach(word => {
        word.data.forEach(char => {
            row.text += char.char;
        });
    });
}

function toWordChar(data, charX, wordChar) {
    data.forEach(char => {
        wordChar.char += char.char;
        charX += char.width;
    });
    return charX;
}

function toChar(data, charX, rowData, isOverflow, addLetterWidth) {
    data.forEach(char => {
        if (isOverflow || char.char !== " ") {
            char.x = charX;
            rowData.push(char);
        }
        charX += char.width;
        addLetterWidth && (charX += addLetterWidth);
    });
    return charX;
}

function layoutText(drawData, style) {
    const {rows: rows, bounds: bounds} = drawData, countRows = rows.length;
    const {__lineHeight: __lineHeight, __baseLine: __baseLine, __letterSpacing: __letterSpacing, __clipText: __clipText, textAlign: textAlign, verticalAlign: verticalAlign, paraSpacing: paraSpacing, autoSizeAlign: autoSizeAlign} = style;
    let {x: x, y: y, width: width, height: height} = bounds, realHeight = __lineHeight * countRows + (paraSpacing ? paraSpacing * (drawData.paraNumber - 1) : 0);
    let starY = __baseLine;
    if (__clipText && realHeight > height) {
        realHeight = Math.max(height, __lineHeight);
        if (countRows > 1) drawData.overflow = countRows;
    } else if (height || autoSizeAlign) {
        switch (verticalAlign) {
          case "middle":
            y += (height - realHeight) / 2;
            break;

          case "bottom":
            y += height - realHeight;
        }
    }
    starY += y;
    let row, rowX, rowWidth, layoutWidth = width || autoSizeAlign ? width : drawData.maxWidth;
    for (let i = 0, len = countRows; i < len; i++) {
        row = rows[i];
        row.x = x;
        if (row.width < width || row.width > width && !__clipText) {
            switch (textAlign) {
              case "center":
                row.x += (layoutWidth - row.width) / 2;
                break;

              case "right":
                row.x += layoutWidth - row.width;
            }
        }
        if (row.paraStart && paraSpacing && i > 0) starY += paraSpacing;
        row.y = starY;
        starY += __lineHeight;
        if (drawData.overflow > i && starY > realHeight) {
            row.isOverflow = true;
            drawData.overflow = i + 1;
        }
        rowX = row.x;
        rowWidth = row.width;
        if (__letterSpacing < 0) {
            if (row.width < 0) {
                rowWidth = -row.width + style.fontSize + __letterSpacing;
                rowX -= rowWidth;
                rowWidth += style.fontSize;
            } else {
                rowWidth -= __letterSpacing;
            }
        }
        if (rowX < bounds.x) bounds.x = rowX;
        if (rowWidth > bounds.width) bounds.width = rowWidth;
        if (__clipText && width && width < rowWidth) {
            row.isOverflow = true;
            if (!drawData.overflow) drawData.overflow = rows.length;
        }
    }
    bounds.y = y;
    bounds.height = realHeight;
}

function clipText(drawData, style, x, width) {
    if (!width) return;
    const {rows: rows, overflow: overflow} = drawData;
    let {textOverflow: textOverflow} = style;
    rows.splice(overflow);
    if (textOverflow && textOverflow !== "show") {
        if (textOverflow === "hide") textOverflow = ""; else if (textOverflow === "ellipsis") textOverflow = "...";
        let char, charRight;
        const ellipsisWidth = textOverflow ? Platform.canvas.measureText(textOverflow).width : 0;
        const right = x + width - ellipsisWidth;
        const list = style.textWrap === "none" ? rows : [ rows[overflow - 1] ];
        list.forEach(row => {
            if (row.isOverflow && row.data) {
                let end = row.data.length - 1;
                for (let i = end; i > -1; i--) {
                    char = row.data[i];
                    charRight = char.x + char.width;
                    if (i === end && charRight < right) {
                        break;
                    } else if (charRight < right && char.char !== " " || !i) {
                        row.data.splice(i + 1);
                        row.width -= char.width;
                        break;
                    }
                    row.width -= char.width;
                }
                row.width += ellipsisWidth;
                row.data.push({
                    char: textOverflow,
                    x: charRight
                });
                if (row.textMode) toTextChar(row);
            }
        });
    }
}

function toTextChar(row) {
    row.text = "";
    row.data.forEach(char => {
        row.text += char.char;
    });
    row.data = null;
}

function decorationText(drawData, style) {
    let type, offset = 0;
    const {fontSize: fontSize, textDecoration: textDecoration} = style;
    drawData.decorationHeight = fontSize / 11;
    if (isObject(textDecoration)) {
        type = textDecoration.type;
        if (textDecoration.color) drawData.decorationColor = ColorConvert.string(textDecoration.color);
        if (textDecoration.offset) offset = Math.min(fontSize * .3, Math.max(textDecoration.offset, -fontSize * .15));
    } else type = textDecoration;
    switch (type) {
      case "under":
        drawData.decorationY = [ fontSize * .15 + offset ];
        break;

      case "delete":
        drawData.decorationY = [ -fontSize * .35 ];
        break;

      case "under-delete":
        drawData.decorationY = [ fontSize * .15 + offset, -fontSize * .35 ];
    }
}

const {top: top, right: right, bottom: bottom, left: left} = Direction4;

function getDrawData(content, style) {
    if (!isString(content)) content = String(content);
    let x = 0, y = 0;
    let width = style.__getInput("width") || 0;
    let height = style.__getInput("height") || 0;
    const {__padding: padding} = style;
    if (padding) {
        if (width) x = padding[left], width -= padding[right] + padding[left], !width && (width = .01); else if (!style.autoSizeAlign) x = padding[left];
        if (height) y = padding[top], height -= padding[top] + padding[bottom], !height && (height = .01); else if (!style.autoSizeAlign) y = padding[top];
    }
    const drawData = {
        bounds: {
            x: x,
            y: y,
            width: width,
            height: height
        },
        rows: [],
        paraNumber: 0,
        font: Platform.canvas.font = style.__font
    };
    createRows(drawData, content, style);
    if (padding) padAutoText(padding, drawData, style, width, height);
    layoutText(drawData, style);
    if (style.__isCharMode) layoutChar(drawData, style, width);
    if (drawData.overflow) clipText(drawData, style, x, width);
    if (style.textDecoration !== "none") decorationText(drawData, style);
    return drawData;
}

function padAutoText(padding, drawData, style, width, height) {
    if (!width && style.autoSizeAlign) {
        switch (style.textAlign) {
          case "left":
            offsetText(drawData, "x", padding[left]);
            break;

          case "right":
            offsetText(drawData, "x", -padding[right]);
        }
    }
    if (!height && style.autoSizeAlign) {
        switch (style.verticalAlign) {
          case "top":
            offsetText(drawData, "y", padding[top]);
            break;

          case "bottom":
            offsetText(drawData, "y", -padding[bottom]);
        }
    }
}

function offsetText(drawData, attrName, value) {
    const {bounds: bounds, rows: rows} = drawData;
    bounds[attrName] += value;
    for (let i = 0; i < rows.length; i++) rows[i][attrName] += value;
}

const TextConvertModule = {
    getDrawData: getDrawData
};

function string(color, opacity) {
    if (!color) return "#000";
    const doOpacity = isNumber(opacity) && opacity < 1;
    if (isString(color)) {
        if (doOpacity && ColorConvert.object) color = ColorConvert.object(color); else return color;
    }
    let a = isUndefined(color.a) ? 1 : color.a;
    if (doOpacity) a *= opacity;
    const rgb = color.r + "," + color.g + "," + color.b;
    return a === 1 ? "rgb(" + rgb + ")" : "rgba(" + rgb + "," + a + ")";
}

const ColorConvertModule = {
    string: string
};

Object.assign(TextConvert, TextConvertModule);

Object.assign(ColorConvert, ColorConvertModule);

Object.assign(Paint, PaintModule);

Object.assign(PaintImage, PaintImageModule);

Object.assign(PaintGradient, PaintGradientModule);

Object.assign(Effect, EffectModule);

Object.assign(Creator, {
    interaction: (target, canvas, selector, options) => new Interaction(target, canvas, selector, options),
    hitCanvas: (options, manager) => new LeaferCanvas(options, manager),
    hitCanvasManager: () => new HitCanvasManager
});

useCanvas();

export { Interaction, Layouter, LeaferCanvas, PathNodeHandleType, Picker, Renderer, Selector, Watcher, useCanvas };
